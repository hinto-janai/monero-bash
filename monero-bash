#!/usr/bin/env bash
#
# monero-bash - a wrapper for Monero, written in Bash
#
# Copyright (c) 2022 hinto.janaiyo <https://github.com/hinto-janaiyo>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

#git <monero-bash/b82e556>
#nix <1658718989>
#hbc <06b0e03>
#lib <stdlib/ask.sh/1eaba1f>
#lib <stdlib/const.sh/1eaba1f>
#lib <stdlib/crypto.sh/1eaba1f>
#lib <stdlib/date.sh/1eaba1f>
#lib <stdlib/debug.sh/1eaba1f>
#lib <stdlib/is.sh/1eaba1f>
#lib <stdlib/lock.sh/1eaba1f>
#lib <stdlib/log.sh/1eaba1f>
#lib <stdlib/panic.sh/1eaba1f>
#lib <stdlib/readonly.sh/1eaba1f>
#lib <stdlib/safety.sh/1eaba1f>
#lib <stdlib/trace.sh/1eaba1f>
#lib <stdlib/type.sh/1eaba1f>
#src <crypto/key.sh>
#src <debug.sh>
#src <monero_bash/install.sh>
#src <monero_bash/uninstall.sh>
#src <parse/config.sh>
#src <parse/options.sh>
#src <parse/p2pool.sh>
#src <parse/state.sh>
#src <pkg/copy.sh>
#src <pkg/download.sh>
#src <pkg/extract.sh>
#src <pkg/hook.sh>
#src <pkg/info.sh>
#src <pkg/prompt.sh>
#src <pkg/remove.sh>
#src <pkg/tmp.sh>
#src <pkg/trap.sh>
#src <pkg/update.sh>
#src <pkg/upgrade.sh>
#src <pkg/verify.sh>
#src <print/changelog.sh>
#src <print/compromised.sh>
#src <print/error.sh>
#src <print/help.sh>
#src <print/pkg.sh>
#src <print/size.sh>
#src <print/title.sh>
#src <print/version.sh>
#src <process/reset_files.sh>
#src <readonly.sh>
#src <rpc.sh>
#src <safety/path.sh>
#src <safety/pipe.sh>
#src <safety/pkg.sh>
#src <safety/root.sh>
#src <safety/wget_curl.sh>
#src <status/monerod.sh>
#src <status/p2pool.sh>
#src <status/table.sh>
#src <status/xmrig.sh>
#src <struct/pkg.sh>
#src <systemd/create.sh>
#src <systemd/reload.sh>
#src <wallet/create.sh>
#src <wallet/list.sh>
#src <wallet/password.sh>
#src <wallet/select.sh>
#src <wallet/start.sh>

#-------------------------------------------------------------------------------- BEGIN SAFETY
POSIXLY_CORRECT= || exit 90
	# bash builtins
\unset -f alias bg bind break builtin caller cd command compgen complete compopt continue declare dirs disown echo enable eval exec exit export false fc fg getopts hash help history jobs kill let local logout mapfile popd printf pushd pwd read readarray readonly return set shift shopt source suspend test times trap true type typeset ulimit umask unalias unset wait || exit 91
	# gnu core-utils
\unset -f arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp csplit cut date dd df dir dircolors dirname du echo env expand expr factor false fmt fold groups head hostid hostname id install join kill link ln logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm rmdir runcon seq shred shuf sleep sort split stat stdbuf stty sum tac tail tee test timeout touch tr true truncate tsort tty uname unexpand uniq unlink uptime users vdir wc who whoami yes || exit 92
\unalias -a || exit 93
unset POSIXLY_CORRECT || exit 94
unset -f . : [ || exit 95
set -eo pipefail || exit 96

#-------------------------------------------------------------------------------- BEGIN LIB
trap 'printf "%s\n" "@@@@@@ LIB PANIC @@@@@@" "[line] ${LINENO}" "[file] $0" "[code] $?";set +eo pipefail;trap - ERR;while :;do read;done;exit 112' ERR || exit 112
ask::yes() {
	local STD_ASK_REPONSE || return 44
	read -r STD_ASK_REPONSE
	case $STD_ASK_REPONSE in
		""|y|Y|yes|Yes|YES) return 0 ;;
		*) return 2 ;;
	esac
}
ask::no() {
	local STD_ASK_RESPONSE || return 44
	read -r STD_ASK_RESPONSE
	case $STD_ASK_RESPONSE in
		y|Y|yes|Yes|YES) return 2 ;;
		*) return 0 ;;
	esac
}
ask::sudo() {
	sudo -v
}
const::char() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="char not found: $i"; return 33; }
		declare -r -g "$i" || return 44
	done
	return 0
}
const::array() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="array not found: $i"; return 33; }
		declare -r -g -a "$i" || return 44
	done
	return 0
}
const::map() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="map not found: $i"; return 33; }
		declare -r -g -A "$i" || return 44
	done
	return 0
}
const::int() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		case "$i" in
			''|*[!0-9]*) { STD_TRACE_RETURN="not integer: $i"; return 33; } ;;
		esac
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="integer not found: $i"; return 44; }
		declare -r -g -i "$i" || return 55
	done
	return 0
}
const::bool() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="bool not found: $i"; return 33; }
		declare -r -g "$i" || return 44
	done
}
const::ref() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="ref not found: $i"; return 33; }
		declare -r -g -n "$i" || return 44
	done
	return 0
}
crypto::bytes() {
	[[ $# = 0 ]] && return 1
	head -c $1 /dev/random
}
crypto::num() {
	case $# in
		1) shuf -i 0-$1 -n 1; return;;
		2) shuf -i $1-$2 -n 1; return;;
		*) return 1;;
	esac
}
crypto::uuid() {
	local STD_CRYPTO_UUID || return 1
	mapfile STD_CRYPTO_UUID < /proc/sys/kernel/random/uuid
	printf "%s" ${STD_CRYPTO_UUID//$'\n'}
}
crypto::encrypt() {
	[[ $# != 2 ]] && return 1
	printf "%s\n" "$1" | gpg --batch --symmetric --armor --quiet --cipher-algo AES256 --passphrase "$2"
}
crypto::decrypt() {
	printf "%s\n" "$1" | gpg --batch --decrypt --quiet --passphrase "$2"
}
date::unix_translate() {
	if [[ -p /dev/stdin ]]; then
		local i || return 11
		for i in $(</dev/stdin); do
			date -d @"$i" || return 22
		done
		return 0
	fi
	[[ $# = 0 ]] && return 33
	while [[ $# != 0 ]]; do
		date -d @"$1" || return 44
		shift
	done
	return 0
}
date::unix() { printf "%s\n" "$EPOCHSECONDS" ;}
date::time() { date +"%T" ;}
date::calendar() { date +"%Y-%m-%d" ;}
date::now() { date +"%Y-%m-%d %T" ;}
date::year() { date +"%Y" ;}
date::month() { date +"%m" ;}
date::day() { date +"%d" ;}
date::hour() { date +"%H" ;}
date::minute() { date +"%M" ;}
date::second() { date +"%S" ;}
debug() {
	[[ $STD_DEBUG != true ]] && return 0
	trap 'STD_DEBUG_CMD="$BASH_COMMAND" STD_DEBUG_FUNC=(${BASH_LINENO[@]}) STD_DEBUG_CMD_NUM="$LINENO" STD_DEBUG_PIPE=(${PIPESTATUS[@]});debug::trap' DEBUG
}
debug::trap() {
	if [[ -z $STD_DEBUG_INIT ]]; then
		declare -g STD_DEBUG_INIT
		STD_DEBUG_INIT=${EPOCHREALTIME//./}
		printf "\r\e[2K\033[1;90m%s\033[1;93m%s\033[0m%s\033[1;93m%s" \
			"[debug 0.000000] " "[ \$_ ] " "${STD_DEBUG_CMD_NUM}: $STD_DEBUG_CMD " "-> "
		local f
		local i=1
		for f in ${STD_DEBUG_FUNC[@]-1}; do
			[[ $f = 0 ]] && break
			printf "\033[1;91m%s\033[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
			((i++))
		done
		printf "\033[0m\n"
		return
	fi
	local STD_DEBUG_ADJUSTED STD_DEBUG_DOT
	STD_DEBUG_ADJUSTED=$((${EPOCHREALTIME//./}-STD_DEBUG_INIT))
	case ${#STD_DEBUG_ADJUSTED} in
		1) STD_DEBUG_ADJUSTED=00000${STD_DEBUG_ADJUSTED//$'\n'};;
		2) STD_DEBUG_ADJUSTED=0000${STD_DEBUG_ADJUSTED//$'\n'};;
		3) STD_DEBUG_ADJUSTED=000${STD_DEBUG_ADJUSTED//$'\n'};;
		4) STD_DEBUG_ADJUSTED=00${STD_DEBUG_ADJUSTED//$'\n'};;
		5) STD_DEBUG_ADJUSTED=0${STD_DEBUG_ADJUSTED//$'\n'};;
	esac
	STD_DEBUG_DOT=$((${#STD_DEBUG_ADJUSTED}-6))
	if [[ $STD_DEBUG_DOT -eq 0 ]]; then
		printf "\r\e[2K\033[1;90m%s\033[1;93m%s\033[0m%s\033[1;93m%s" \
			"[debug 0.${STD_DEBUG_ADJUSTED}] " "[ \$_ ] " "${STD_DEBUG_CMD_NUM}: $STD_DEBUG_CMD " "-> "
	else
		printf "\r\e[2K\033[1;90m%s\033[1;93m%s\033[0m%s\033[1;93m%s" \
			"[debug ${STD_DEBUG_ADJUSTED:0:${STD_DEBUG_DOT}}.${STD_DEBUG_ADJUSTED:${STD_DEBUG_DOT}}] " \
			"[ \$_ ] " "${STD_DEBUG_CMD_NUM}: $STD_DEBUG_CMD " "-> "
	fi
	local f
	local i=1
	for f in ${STD_DEBUG_FUNC[@]-1}; do
		[[ $f = 0 ]] && break
		printf "\033[1;91m%s\033[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
		((i++))
	done
	printf "\033[0m\n"
}
is::int() {
	if [[ -p /dev/stdin ]]; then
		local i || return 11
		for i in $(</dev/stdin); do
			[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not integer: $i"; return 22; }
		done
		return 0
	fi
	[[ $# = 0 ]] && return 33
	local i || return 44
	for i in "$@"; do
		[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not integer: $i"; return 55; }
	done
}
is::int_pos() {
	if [[ -p /dev/stdin ]]; then
		local i || return 11
		for i in $(</dev/stdin); do
			[ $i -gt -1 ] &>/dev/null || { STD_TRACE_RETURN="not pos int: $i"; return 22; }
			[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not pos int: $i"; return 33; }
		done
		return 0
	fi
	[[ $# = 0 ]] && return 44
	local i || return 55
	for i in "$@"; do
		[ $i -gt -1 ] &>/dev/null || { STD_TRACE_RETURN="not pos int: $i"; return 66; }
		[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not pos int: $i"; return 77; }
	done
}
is::int_neg() {
	if [[ -p /dev/stdin ]]; then
		local i || return 11
		for i in $(</dev/stdin); do
			[ $i -lt 0 ] &>/dev/null || { STD_TRACE_RETURN="not neg int: $i"; return 22; }
			[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not neg int: $i"; return 33; }
		done
		return 0
	fi
	[[ $# = 0 ]] && return 44
	local i || return 55
	for i in "$@"; do
		[ $i -lt 0 ] &>/dev/null || { STD_TRACE_RETURN="not neg int: $i"; return 66; }
		[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not neg int: $i"; return 77; }
	done
}
lock::alloc() {
	POSIXLY_CORRECT= || return 7
	\unset -f umask trap set return echo unset local return unalias mapfile command || return 8
	\unalias -a || return 9
	unset -v POSIXLY_CORRECT || return 10
	[[ $# = 0 ]] && return 11
	declare -g -A STD_LOCK_FILE || return 12
	set +f || return 13
	local i f || return 14
	for i in "$@"; do
		for f in /tmp/std_lock_"$i"_*; do
			[[ -e "$f" ]] && { STD_TRACE_RETURN="lock file found: $f"; return 15; }
		done
	done
	local STD_LOCK_UUID || return 22
	until [[ $# = 0 ]]; do
		mapfile STD_LOCK_UUID < /proc/sys/kernel/random/uuid || return 23
		STD_LOCK_UUID[0]=${STD_LOCK_UUID[0]//$'\n'/}
		STD_LOCK_UUID[0]=${STD_LOCK_UUID//-/}
		STD_LOCK_FILE[$1]="/tmp/std_lock_${1}_${STD_LOCK_UUID[0]}" || return 33
		local STD_DEFAULT_UMASK
		STD_DEFAULT_UMASK=$(umask)
		umask 177
		echo > "${STD_LOCK_FILE[$1]}" || return 44
		umask $STD_DEFAULT_UMASK
		shift || return 45
	done
}
lock::free() {
	POSIXLY_CORRECT= || return 7
	\unset -f : unset return rm command || return 8
	\unalias -a || return 9
	unset -v POSIXLY_CORRECT || return 10
	[[ $# = 0 ]] && return 11
	until [[ $# = 0 ]]; do
		if [[ $1 = '@' ]]; then
			command rm "${STD_LOCK_FILE[@]}" || :
			unset -v STD_LOCK_FILE || :
			return 0
		else
			command rm "${STD_LOCK_FILE[$1]}" || { STD_TRACE_RETURN="lock rm fail: ${STD_LOCK_FILE[$1]}"; return 22; }
			unset -v "STD_LOCK_FILE[$1]" || return 23
		fi
		shift
	done
}
log::ok() {
	printf "\r\e[2K"
	printf "\r\e[1;32m[  OK  ]\e[0m %s\n" "$@"
}
log::info() {
	printf "\r\e[2K"
	printf "\r\e[1;37m[ INFO ]\e[0m %s\n" "$@"
}
log::warn() {
	printf "\r\e[2K"
	printf "\r\e[1;33m[ WARN ]\e[0m %s\n" "$@"
}
log::fail() {
	printf "\r\e[2K"
	printf "\r\e[1;31m[ FAIL ]\e[0m %s\n" "$@"
}
log::danger() {
	printf "\r\e[2K"
	printf "\r\e[1;31m[DANGER]\e[0m %s\n" "$@"
}
log::tab() {
	printf "\r\e[2K"
	printf "\r\e[0m         %s\n" "$@"
}
log::prog() {
	printf "\r\e[2K"
	printf "\r\e[1;37m[ \e[0m....\e[1;37m ]\e[0m %s " "$@"
}
log::debug() {
	[[ $STD_LOG_DEBUG != true ]] && return 0
	if [[ -z $STD_LOG_DEBUG_INIT ]]; then
		declare -g STD_LOG_DEBUG_INIT
		STD_LOG_DEBUG_INIT=${EPOCHREALTIME//[!0-9]/}
		printf "\r\e[2K\e[1;90m%s\e[0m%s" "[log::debug 0.000000] " "$* "
		if [[ $STD_LOG_DEBUG_VERBOSE = true ]]; then
			printf "\e[1;93m%s" "-> "
			local f i
			i=1
			for f in ${BASH_LINENO[@]}; do
				[[ $f = 0 ]] && break
				printf "\e[1;91m%s\e[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
				((i++))
			done
		fi
		printf "\e[0m\n"
		return
	fi
	local STD_LOG_DEBUG_ADJUSTED STD_LOG_DEBUG_DOT
	STD_LOG_DEBUG_ADJUSTED=$((${EPOCHREALTIME//[!0-9]/}-STD_LOG_DEBUG_INIT))
	case ${#STD_LOG_DEBUG_ADJUSTED} in
		1) STD_LOG_DEBUG_ADJUSTED=00000${STD_LOG_DEBUG_ADJUSTED};;
		2) STD_LOG_DEBUG_ADJUSTED=0000${STD_LOG_DEBUG_ADJUSTED};;
		3) STD_LOG_DEBUG_ADJUSTED=000${STD_LOG_DEBUG_ADJUSTED};;
		4) STD_LOG_DEBUG_ADJUSTED=00${STD_LOG_DEBUG_ADJUSTED};;
		5) STD_LOG_DEBUG_ADJUSTED=0${STD_LOG_DEBUG_ADJUSTED};;
	esac
	STD_LOG_DEBUG_DOT=$((${#STD_LOG_DEBUG_ADJUSTED}-6))
	if [[ $STD_LOG_DEBUG_DOT -eq 0 ]]; then
		printf "\r\e[2K\e[1;90m%s\e[0m%s" "[log::debug 0.${STD_LOG_DEBUG_ADJUSTED}] " "$* "
	else
		printf "\r\e[2K\e[1;90m%s\e[0m%s" \
			"[log::debug ${STD_LOG_DEBUG_ADJUSTED:0:${STD_LOG_DEBUG_DOT}}.${STD_LOG_DEBUG_ADJUSTED:${STD_LOG_DEBUG_DOT}}] " "$* "
	fi
	if [[ $STD_LOG_DEBUG_VERBOSE = true ]]; then
		printf "\e[1;93m%s" "-> "
		local f i
		i=1
		for f in ${BASH_LINENO[@]}; do
			[[ $f = 0 ]] && break
			printf "\e[1;91m%s\e[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
			((i++))
		done
	fi
	printf "\e[0m\n"
}
panic() {
	local STD_PANIC_CODE="$?" STD_TRACE_FUNC=("${BASH_LINENO[@]}") STD_TRACE_CMD_NUM=${BASH_LINENO[0]}|| exit 98
	POSIXLY_CORRECT= || exit 11
	\unset -f trap set return exit printf echo local unalias unset builtin kill || exit 22
	\unalias -a || exit 33
	unset POSIXLY_CORRECT || exit 44
	unset : || exit 55
	printf "\e[7m\e[0;m%s\e[0m\n" "@@@@@@@@  panic  @@@@@@@@"
	local STD_PANIC_CMD
	mapfile -s $((STD_TRACE_CMD_NUM-1)) -n 1 STD_PANIC_CMD < $0
	printf "\e[1;95m%s\e[0m%s\n" "[bash] " "$BASH_VERSION"
	printf "\e[1;96m%s\e[0m%s\n" "[unix] " "$EPOCHSECONDS"
	printf "\e[1;97m%s\e[0m%s\n" "[file] " "${BASH_SOURCE[-1]}"
	printf "\e[1;91m%s\e[0m%s\n" "[code] " "$STD_PANIC_CODE"
	printf "\e[1;94m%s\e[0m%s\n" "[ wd ] " "$PWD"
	printf "\e[1;93m%s\e[0m%s" "[ \$_ ] " "$STD_TRACE_CMD_NUM: ${STD_PANIC_CMD//$'\t'/}"
	local f
	local i=1
	STD_TRACE_FUNC=("${STD_TRACE_FUNC[@]:1}")
	for f in ${STD_TRACE_FUNC[@]}; do
		[[ $f = 0 ]] && break
		printf "\e[1;92m%s\e[0m%s\n" "[func] " "${f}: ${FUNCNAME[${i}]}()"
		((i++))
	done
	local STD_TRACE_LINE_ARRAY
	local STD_ORIGINAL_LINE="$STD_TRACE_CMD_NUM"
	if [[ $STD_TRACE_CMD_NUM -lt 5 ]]; then
		local STD_TRACE_CMD_NUM=1
		mapfile -n 9 STD_TRACE_LINE_ARRAY < $0
	else
		local STD_TRACE_CMD_NUM=$((STD_TRACE_CMD_NUM-4))
		mapfile -s $((STD_TRACE_CMD_NUM-1)) -n 9 STD_TRACE_LINE_ARRAY < $0
	fi
	for i in {0..8}; do
		[[ ${STD_TRACE_LINE_ARRAY[$i]} ]] || break
		if [[ $STD_TRACE_CMD_NUM = "$STD_ORIGINAL_LINE" ]]; then
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;97m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				2) printf "\e[1;97m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				3) printf "\e[1;97m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				4) printf "\e[1;97m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				5) printf "\e[1;97m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				*) printf "\e[1;97m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
			esac
		else
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;90m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				2) printf "\e[1;90m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				3) printf "\e[1;90m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				4) printf "\e[1;90m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				5) printf "\e[1;90m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				*) printf "\e[1;90m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
			esac
		fi
		((STD_TRACE_CMD_NUM++))
	done
	printf "\e[0;m%s\n" "@@@@@@@@  panic  @@@@@@@@"
	while :; do read -s -r; done
	printf "\e[0;m%s\n" "@ loop fail, killing \$$ @"
	builtin kill -s KILL 0
	[[ $1 =~ ^[0-9]+$ ]] && exit $1 || exit 99
}
readonly BLACK="\e[0;30m"
readonly RED="\e[0;31m"
readonly GREEN="\e[0;32m"
readonly YELLOW="\e[0;33m"
readonly BLUE="\e[0;34m"
readonly PURPLE="\e[0;35m"
readonly CYAN="\e[0;36m"
readonly WHITE="\e[0;37m"
readonly BBLACK="\e[1;90m"
readonly BRED="\e[1;91m"
readonly BGREEN="\e[1;92m"
readonly BYELLOW="\e[1;93m"
readonly BBLUE="\e[1;94m"
readonly BPURPLE="\e[1;95m"
readonly BCYAN="\e[1;96m"
readonly BWHITE="\e[1;97m"
readonly UBLACK="\e[4;30m"
readonly URED="\e[4;31m"
readonly UGREEN="\e[4;32m"
readonly UYELLOW="\e[4;33m"
readonly UBLUE="\e[4;34m"
readonly UPURPLE="\e[4;35m"
readonly UCYAN="\e[4;36m"
readonly UWHITE="\e[4;37m"
readonly IBLACK="\e[0;90m"
readonly IRED="\e[0;91m"
readonly IGREEN="\e[0;92m"
readonly IYELLOW="\e[0;93m"
readonly IBLUE="\e[0;94m"
readonly IPURPLE="\e[0;95m"
readonly ICYAN="\e[0;96m"
readonly IWHITE="\e[0;97m"
readonly BOLD="\e[1m"
readonly ITALIC="\e[3m"
readonly OFF="\e[0m"
safety::builtin() {
	POSIXLY_CORRECT= || exit 11
	\unset -f "$@" || exit 22
	\unalias -a || exit 33
	unset POSIXLY_CORRECT || exit 44
}
safety::bash() {
	[[ ${BASH_VERSINFO[0]} -ge 5 ]] || { STD_TRACE_RETURN="bash not v5+: ${BASH_VERSINFO[0]}"; return 11; }
}
safety::gnu_linux() {
	[[ $OSTYPE = linux-gnu* ]] || { STD_TRACE_RETURN="os not gnu/linux: $OSTYPE"; return 11; }
}
___BEGIN___ERROR___TRACE___() {
	POSIXLY_CORRECT= || exit 8
	\unset -f true false trap set return exit printf unset local return read unalias mapfile kill builtin wait || exit 9
	\unalias -a || exit 10
	unset -v POSIXLY_CORRECT || exit 11
	unset -f : || exit 1
	trap 'STD_TRACE_CMD="$BASH_COMMAND" STD_TRACE_FUNC=(${BASH_LINENO[@]}) STD_TRACE_CMD_NUM="$LINENO" STD_TRACE_PIPE=(${PIPESTATUS[@]}); ___ENDOF___ERROR___TRACE___ > /dev/tty || exit 100' ERR || exit 12
	unset -v STD_TRACE_CMD STD_TRACE_FUNC_NUM STD_TRACE_CMD_NUM STD_TRACE_PIPE || exit 13
	set -E -e -o pipefail || exit 14
	return 0
}
___ENDOF___ERROR___TRACE___() {
	POSIXLY_CORRECT= || exit 15
	\unset -f true false trap set return exit printf unset local return read unalias mapfile kill builtin wait || exit 16
	\unalias -a || exit 17
	unset -v POSIXLY_CORRECT || exit 18
	unset -f : || exit 1
	if [[ -z $STD_TRACE_PIPE ]]; then
		POSIXLY_CORRECT= || exit 19
		\unset -f trap set return exit return || exit 20
		\unalias -a || exit 21
		unset POSIXLY_CORRECT || exit 22
		unset -v STD_TRACE_CMD STD_TRACE_FUNC_NUM STD_TRACE_CMD_NUM STD_TRACE_PIPE || exit 23
		set +E +eo pipefail || exit 24
		trap - ERR || exit 25
		return 0
	fi
	printf "\e[1;91m%s\n" "========  BEGIN ERROR TRACE  ========"
	printf "\e[1;95m%s\e[0m%s\n" "[bash] " "$BASH_VERSION"
	printf "\e[1;96m%s\e[0m%s\n" "[unix] " "$EPOCHSECONDS"
	printf "\e[1;91m%s" "[code] "
	for i in "${STD_TRACE_PIPE[@]}"; do
		printf "\e[0m%s" "$i"
	done
	printf "\n\e[1;97m%s\e[0m%s\n" "[file] " "${BASH_SOURCE[-1]}"
	printf "\e[1;94m%s\e[0m%s\n" "[ wd ] " "$PWD"
	printf "\e[1;93m%s\e[0m%s\n" "[ \$_ ] " "${STD_TRACE_CMD_NUM}: $STD_TRACE_CMD"
	local f
	local i=1
	for f in "${STD_TRACE_FUNC[@]}"; do
		[[ $f = 0 ]] && break
		printf "\e[1;92m%s\e[0m%s\n" "[func] " "${f}: ${FUNCNAME[${i}]}()"
		((i++))
	done
	local STD_TRACE_LINE_ARRAY
	local STD_ORIGINAL_LINE="$STD_TRACE_CMD_NUM"
	if [[ $STD_TRACE_CMD_NUM -lt 5 ]]; then
		local STD_TRACE_CMD_NUM=1
		mapfile -n 9 STD_TRACE_LINE_ARRAY < "$0"
	else
		local STD_TRACE_CMD_NUM=$((STD_TRACE_CMD_NUM-4))
		mapfile -s $((STD_TRACE_CMD_NUM-1)) -n 9 STD_TRACE_LINE_ARRAY < "$0"
	fi
	for i in {0..8}; do
		[[ ${STD_TRACE_LINE_ARRAY[$i]} ]] || break
	  local STD_TRACE_SPACING="    "
		if [[ $STD_TRACE_CMD_NUM = "$STD_ORIGINAL_LINE" ]]; then
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;97m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				2) printf "\e[1;97m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				3) printf "\e[1;97m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				4) printf "\e[1;97m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				5) printf "\e[1;97m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				*) printf "\e[1;97m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
			esac
		else
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;90m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				2) printf "\e[1;90m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				3) printf "\e[1;90m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				4) printf "\e[1;90m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				5) printf "\e[1;90m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				*) printf "\e[1;90m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
			esac
		fi
		((STD_TRACE_CMD_NUM++))
	done
	[[ $STD_TRACE_RETURN ]] && printf "\e[38;5;196m%s\e[0;1m%s\e[0m\n" "[STD_TRACE_RETURN]" " $STD_TRACE_RETURN"
	printf "\e[1;91m%s\e[0m\n" "========  ENDOF ERROR TRACE  ========"
	unset -v STD_TRACE_CMD STD_TRACE_FUNC_NUM STD_TRACE_CMD_NUM STD_TRACE_PIPE || exit 26
	set +E +eo pipefail || exit 27
	trap - ERR || exit 28
	if [[ $BASH_SUBSHELL != 0 ]]; then
		printf "\e[1;93m%s\e[0m\n" "======  SUB-SHELLS TERMINATED  ======"
	fi
	builtin kill -s TERM 0
	exit 99
	printf "\e[1;97m%s\e[0m\n" "=KILL/EXIT FAIL, BEGIN INFINITE LOOP="
	while :; do read -s -r; done
	while true; do read -s -r; done
	while true; do false; done
	while :; do :; done
}
char() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p ${i%=*} &>/dev/null && { STD_TRACE_RETURN="char already found: $i"; return 33; }
		declare -g "$i" || return 44
	done
	return 0
}
array() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		{ declare -p ${i%=*} &>/dev/null || [[ -v ${i%=*} ]]; } && { STD_TRACE_RETURN="array already found: $i"; return 33; }
		declare -g -a "$i" || return 44
	done
	return 0
}
map() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		{ declare -p ${i%=*} &>/dev/null || [[ -v ${i%=*} ]]; } && { STD_TRACE_RETURN="map already found: $i"; return 33; }
		declare -g -A "$i" || return 44
	done
	return 0
}
int() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		if [[ $i = *=* ]]; then
			case ${i/*=} in
				''|*[!0-9]*) { STD_TRACE_RETURN="not integer: $i"; return 33; } ;;
			esac
		fi
		declare -p ${i%=*} &>/dev/null && { STD_TRACE_RETURN="integer already found: $i"; return 44; }
		declare -g -i "$i" || return 55
	done
	return 0
}
bool() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p ${i%=*} &>/dev/null && { STD_TRACE_RETURN="bool already found: $i"; return 33; }
		case $i in
			*=true) declare -g ${i%=*}=true || return 44 ;;
			*=false) declare -g ${i%=*}=false || return 55 ;;
			*) return 66 ;;
		esac
	done
}
ref() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p ${i%=*} &>/dev/null && { STD_TRACE_RETURN="ref already found: $i"; return 33; }
		declare -g -n "$i" || return 44
	done
	return 0
}
free() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		{ declare -p ${i%=*} &>/dev/null || [[ -v ${i%=*} ]]; } || { STD_TRACE_RETURN="no var found: $i"; return 33; }
		unset -v "$i" || { STD_TRACE_RETURN="could not free: $i"; return 44; }
	done
	return 0
}
free::func() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -F "$i" &>/dev/null || { STD_TRACE_RETURN="no func found: $i"; return 33; }
		unset -f "$i" || { STD_TRACE_RETURN="could not free: $i"; return 44; }
	done
	return 0
}
declare -frg ask::yes
declare -frg ask::no
declare -frg ask::sudo
declare -frg const::char
declare -frg const::array
declare -frg const::map
declare -frg const::int
declare -frg const::bool
declare -frg const::ref
declare -frg crypto::bytes
declare -frg crypto::num
declare -frg crypto::uuid
declare -frg crypto::encrypt
declare -frg crypto::decrypt
declare -frg date::unix_translate
declare -frg date::unix
declare -frg date::time
declare -frg date::calendar
declare -frg date::now
declare -frg date::year
declare -frg date::month
declare -frg date::day
declare -frg date::hour
declare -frg date::minute
declare -frg date::second
declare -frg debug
declare -frg debug::trap
declare -frg is::int
declare -frg is::int_pos
declare -frg is::int_neg
declare -frg lock::alloc
declare -frg lock::free
declare -frg log::ok
declare -frg log::info
declare -frg log::warn
declare -frg log::fail
declare -frg log::danger
declare -frg log::tab
declare -frg log::prog
declare -frg log::debug
declare -frg panic
declare -frg safety::builtin
declare -frg safety::bash
declare -frg safety::gnu_linux
declare -frg ___BEGIN___ERROR___TRACE___
declare -frg ___ENDOF___ERROR___TRACE___
declare -frg char
declare -frg array
declare -frg map
declare -frg int
declare -frg bool
declare -frg ref
declare -frg free
declare -frg free::func

#-------------------------------------------------------------------------------- BEGIN SRC
trap 'printf "%s\n" "@@@@@@ SRC PANIC @@@@@@" "[line] ${LINENO}" "[file] $0" "[code] $?";set +eo pipefail;trap - ERR;while :;do read;done;exit 115' ERR || exit 115
crypto::key::create() {
	log::debug "creating one-time key with 4096 bits of entropy"
	char CRYPTO_KEY
	CRYPTO_KEY=$(mktemp /tmp/monero-bash-crypto-key.XXXXXXXXXX)
	chmod 600 "$CRYPTO_KEY"
	crypto::bytes 512 | base64 > "$CRYPTO_KEY"
	log::debug "created one-time key: $CRYPTO_KEY"
	return 0
}
crypto::key::remove() {
	log::debug "deleting one-time key: $CRYPTO_KEY"
	[[ -e $CRYPTO_KEY ]]
	rm "$CRYPTO_KEY"
	free CRYPTO_KEY
}
DEBUG() {
	log::debug "starting ${FUNCNAME}()"
	log::debug "entering debug function mode"
	printf "${BRED}%s\n${BWHITE}%s\n${BWHITE}%s\n${BWHITE}%s\n${BWHITE}%s\n${BGREEN}%s${OFF}\n" \
		"====    MONERO-BASH DEBUG MODE   ===="
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		"@ you are executing a monero-bash   @" \
		"@ function directly, use carefully! @" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		"function(): "
	local DEBUG_FUNCTION || return 1
	read -r DEBUG_FUNCTION || return 2
	if ! declare -fp "$DEBUG_FUNCTION" &>/dev/null; then
		log::fail "$DEBUG_FUNCTION not found"
		exit 1
	fi
	log::debug "executing debug function: $DEBUG_FUNCTION"
	$DEBUG_FUNCTION
	exit
}
monero_bash::install:trap::user() {
	trap "" INT
	log::prog "Deleting user [monero-bash]"
	if sudo userdel monero-bash; then
		log::ok "Deleted user [monero-bash]"
	else
		log::fail "Could not delete user [monero-bash]"
	fi
}
monero_bash::install::trap::clean() {
	print::error "Install failed, starting cleanup"
	trap "" INT
	if [[ -d "$DOT" ]]; then
		log::debug "DOT found: $DOT"
		log::prog "Deleting: $DOT"
		if rm -rf "$DOT" &>/dev/null; then
			log::ok "Deleted: $DOT"
		else
			log::fail "Could not delete: $DOT"
		fi
	else
		log::debug "no DOT found at: $DOT"
	fi
	if [[ -e "$BINARY" || -h "$BINARY" ]]; then
		log::debug "BINARY found: $BINARY"
		log::prog "Deleting: $BINARY"
		if sudo rm -rf "$BINARY" &>/dev/null; then
			log::ok "Deleted: $BINARY"
		else
			log::fail "Could not delete: $BINARY"
		fi
	else
		log::debug "no BINARY found at: $BINARY"
	fi
	if [[ -e "$SYMLINK" || -h "$SYMLINK" ]]; then
		local SYMLINK_OUTPUT="$(ls "$SYMLINK")"
		if [[ $SYMLINK_OUTPUT = *${BINARY}* ]]; then
			log::prog "SYMLINK found: $SYMLINK"
			log::prog "Deleting: $SYMLINK"
			if sudo rm -rf "$SYMLINK" &>/dev/null; then
				log::ok "Deleted: $SYMLINK"
			else
				log::fail "Could not delete: $SYMLINK"
			fi
		else
			log::debug "no SYMLINK found at: $SYMLINK"
		fi
	fi
	exit 0
}
monero_bash::install() {
log::debug "starting ${FUNCNAME}()"
if [[ -d "$HOME"/.monero-bash ]]; then
	print::error "[monero-bash] install folder already found: $HOME/.monero-bash"
	print::exit  "Exiting for safety..."
fi
if [[ -e "$BINARY" || -h "$BINARY" ]]; then
	print::error "/usr/local/bin/monero-bash already found!"
	print::exit  "Exiting for safety..."
fi
printf "${BRED}%s${OFF}\n" \
	"#-----------------------------------------------------------------#" \
	"#                    monero-bash installation                     #" \
	"#-----------------------------------------------------------------#"
local INSTALL_DATA_PATH
if [[ -d "$HOME"/.bitmonero ]]; then
	printf "${OFF}%s\n%s${BYELLOW}%s${OFF}%s" \
		"Monero data folder already detected" \
		"Use " \
		"$HOME/.bitmonero? " \
		"(Y/n) "
	if ask::yes; then
		INSTALL_DATA_PATH="$HOME/.bitmonero"
	else
		printf "%s\n\n" "Skipping: $HOME/.bitmonero"
	fi
fi
while :; do
	if [[ -z $INSTALL_DATA_PATH ]]; then
		printf "%s" "Monero data path [Enter for default]: "
		read -r INSTALL_DATA_PATH
	fi
	if [[ -z $INSTALL_DATA_PATH ]]; then
		INSTALL_DATA_PATH="$HOME/.bitmonero"
	fi
	printf "\n${BWHITE}%s${BYELLOW}%s\n${OFF}%s" \
		"DATA PATH: " \
		"$INSTALL_DATA_PATH" \
		"Is this okay? (Y/n) "
	if ask::yes; then
		echo
		break
	else
		unset -v INSTALL_DATA_PATH
	fi
	echo
done
if [[ ! -e $SYMLINK && ! -h $SYMLINK ]]; then
	printf "${OFF}%s${BRED}%s${OFF}%s${BRED}%s${OFF}\n" \
		"Symlink creation: " \
		"[monero-bash] " \
		"-> " \
		"[mb]"
	printf "${OFF}%s${BRED}%s${OFF}%s${BCYAN}%s${OFF}\n" \
		"This allows you to use " \
		"[monero-bash] " \
		"like so: " \
		"mb update && mb upgrade"
	printf "${OFF}%s" "Create symlink? (Y/n) "
	if ask::yes; then
		local INSTALL_SYMLINK=true
		printf "%s\n" "Will create [mb] symlink"
	else
		printf "%s\n" "Skipping [mb] symlink..."
	fi
fi
local i
printf "\n${BRED}%s" "#"
for ((i=0; i < 65; i++)); do
	read -r -t 0.01 || true
	printf "%s" "-"
done
printf "${BRED}%s${OFF}\n\n" "#"
printf "${OFF}%s${BYELLOW}%s\n" \
	"[monero-bash] will install in | " "$HOME/.monero-bash" \
	"The PATH will be set in       | " "/usr/local/bin/monero-bash" \
	"[.bitmonero] will be set in   | " "$INSTALL_DATA_PATH"
if [[ $INSTALL_SYMLINK = true ]]; then
	printf "${OFF}%s${BYELLOW}%s\n" \
	"A PATH symlink will be set in | " "/usr/local/bin/mb"
fi
echo
printf "${BWHITE}%s${OFF}\n" \
	"A no-login user called [monero-bash] will be created for process security" \
	"[Monero] and [P2Pool] will run as this user. [XMRig] by default, runs as ROOT." \
	"This can be changed in [monero-bash.conf]: XMRIG_ROOT=false"
echo
printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}" \
	"Start " \
	"[monero-bash] " \
	"install? (Y/n) "
if ! ask::yes; then
	printf "$${OFF}%s\n" "Canceling [monero-bash] installation..."
	exit 1
fi
if ! ask::sudo; then
	print::exit "sudo is required for installation"
fi
log::prog "verifying [monero-bash] file hashes"
if sha256sum --check "txt/hashlist" &>/dev/null; then
	log::ok "[monero-bash] file hashes"
else
	log::fail "[monero-bash] file hashes"
	print::error "Hash verification has failed."
	print::exit "Have the files been moved for modified?"
fi
log::prog "creating [monero-bash] user"
local NOLOGIN_SHELL
NOLOGIN_SHELL="$(which nologin)"
log::debug "[nologin] shell found: $NOLOGIN_SHELL"
trap 'monero_bash::install::trap::clean' EXIT
if ! sudo useradd --no-create-home --system --shell "$NOLOGIN_SHELL" monero-bash; then
	print::error "Could not create [monero-bash] user"
	print::exit "Exiting for safety..."
else
	trap 'monero::install::trap::user; monero_bash::install::trap::clean' EXIT
	log::ok "created [monero-bash] user"
fi
log::prog "creating [.monero-bash] folders"
mkdir "$DOT"
mkdir "$PACKAGES"
mkdir "$PKG_MONERO_BASH"
mkdir "$WALLETS"
log::ok "created [.monero-bash] folders"
log::prog "cleaning git files"
[[ -e docs ]]         && rm -rf doc
[[ -e lib ]]          && rm -rf lib
[[ -e tests ]]        && rm -rf tests
[[ -e utils ]]        && rm -rf utils
[[ -e src ]]          && rm -rf src
[[ -e CHANGELOG.md ]] && rm -f CHANGELOG.md
[[ -e README.md ]]    && rm -f README.md
[[ -e LICENSE ]]      && rm -f LICENSE
[[ -e hbc.add ]]      && rm -f hbc.add
[[ -e hbc.conf ]]     && rm -f hbc.conf
[[ -e main.sh ]]      && rm -f main.sh
[[ -e .git ]]         && rm -rf .git
[[ -e .gitignore ]]   && rm -f .gitignore
[[ -e .gitmodules ]]  && rm -f .gitmodules
log::ok "cleaned git files"
log::prog "moving folder to: [$HOME/.monero-bash]"
mv -f "$RELATIVE" "$PACKAGES"
log::ok "moved folder to: [$HOME/.monero-bash]"
log::prog "creating config folder"
mkdir -p "$CONFIG"
cp "$SRC_CONFIG/monero-bash.conf" "$CONFIG/"
cp "$SRC_CONFIG/monerod.conf" "$CONFIG/"
cp "$SRC_CONFIG/monero-wallet-cli.conf" "$CONFIG/"
log::ok "created config folder"
log::prog "adding [monero-bash] to PATH"
sudo ln -s "$MAIN" /usr/local/bin/monero-bash
log::ok "added [monero-bash] to PATH"
if [[ $INSTALL_SYMLINK = true ]]; then
	log::prog "creating [mb] PATH symlink"
	sudo ln -s "$MAIN" /usr/local/bin/mb
	log::ok "created [mb] PATH symlink"
fi
log::prog "setting Monero data path"
sed -i "s@data-dir.*@data-dir=$INSTALL_DATA_PATH@g" "$CONFIG_MONEROD"
log::ok "set Monero data path"
log::debug "setting FIRST_TIME = false"
sed -i "s/FIRST_TIME=.*/FIRST_TIME=\"false\"/g" "$STATE"
log::debug "set FIRST_TIME = false"
log::prog "setting folder permissions"
sudo chown "$USER:$USER" "$DOT"
sudo chmod -R 770 "$DOT"
log::ok "set folder permissions"
trap - EXIT
printf "${BGREEN}%s${OFF}\n" \
	"" \
	"#-----------------------------------------------------------------#" \
	"#                monero-bash installation complete                #" \
	"#-----------------------------------------------------------------#"
printf "${BWHITE}%s${BYELLOW}%s\n" \
	"monero-bash path    | " "$HOME/.monero-bash" \
	"Monero data path    | " "$INSTALL_DATA_PATH" \
	"Wallet files        | " "$WALLETS" \
	"Package folders     | " "$PACKAGES" \
	"Configuration files | " "$CONFIG"
echo
printf "${BWHITE}%s${BRED}%s${BWHITE}%s\n" \
	"Type: " \
	"[monero-bash help] " \
	"to get started"
exit 0
}
monero_bash::uninstall() {
log::debug "starting ${FUNCNAME}()"
printf "${BWHITE}%s\n${BWHITE}%s${BRED}%s${BWHITE}%s\n${BWHITE}%s${OFF}\n" \
	"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
	"@ " \
	"THIS WILL UNINSTALL [monero-bash], DELETE /.monero-bash/ AND EVERYTHING INSIDE IT " \
	"@" \
	"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
print::size
printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}" \
	"Uninstall " \
	"[monero-bash]" \
	"?"
if ! ask::yes; then
	print::exit "Canceling [monero-bash] uninstall"
fi
local WALLET_COUNT
WALLET_COUNT=$(ls "$WALLETS" | wc -l) || exit 1
if [[ $WALLET_COUNT != 0 ]]; then
	printf "${BWHITE}%s\n${BWHITE}%s${BRED}%s${BWHITE}%s\n${BWHITE}%s\n${BRED}%s" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		"@ " \
		"         WARNING: WALLETS FOUND          " \
		"@" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		"ARE YOU SURE YOU WANT TO UNINSTALL? (y/N) "
	if ask::no; then
		exit 1
	fi
fi
if ! ask::sudo; then
	print::exit "sudo is needed to uninstall"
fi
local i
for i in {10..0}; do
	printf "\r\e[2K${BYELLOW}%s" "Uninstalling in ${i}..."
	sleep 1
done
log::info "stopping all processes"
if [[ $MONERO_VER ]]; then
	if systemctl status monero-bash-monerod &>/dev/null; then
		process::systemd::stop monerod
	fi
fi
if [[ $P2POOL_VER ]]; then
	if systemctl status monero-bash-p2pool &>/dev/null; then
		process::systemd::stop p2pool
	fi
fi
if [[ $XMRIG_VER ]]; then
	if systemctl status monero-bash-xmrig &>/dev/null; then
		process::systemd::stop xmrig
	fi
fi
trap "" INT
___BEGIN___ERROR___TRACE___
log::prog "Removing $DOT"
rm -rf "$DOT"
log::ok "Removed $DOT"
log::prog "Removing from PATH"
sudo rm /usr/local/bin/monero-bash
[[ -e /usr/local/bin/mb ]] && sudo rm /usr/local/bin/monero-bash
log::ok "Removed from PATH"
log::prog "Removing systemd services"
[[ -e "$SYSTEMD/monero-bash-monerod.service" ]] && sudo rm "$SYSTEMD/monero-bash-monerod.service"
[[ -e "$SYSTEMD/monero-bash-p2pool.service" ]]  && sudo rm "$SYSTEMD/monero-bash-p2pool.service"
[[ -e "$SYSTEMD/monero-bash-xmrig.service" ]]   && sudo rm "$SYSTEMD/monero-bash-xmrig.service"
log::ok "Removed systemd services"
___ENDOF___ERROR___TRACE___
echo
log::ok "Successfully uninstalled [monero-bash]"
exit 0
}
parse::config() {
	log::debug "starting ${FUNCNAME}()"
	local i IFS=$'\n' CONFIG_ARRAY CONFIG_PATH || return 1
	if [[ -e "${RELATIVE}/config/monero-bash.conf" ]]; then
		log::debug "config found, using: ${RELATIVE}/config/monero-bash.conf"
		mapfile CONFIG_ARRAY < "${RELATIVE}/config/monero-bash.conf" || return 2
	else
		print::exit "[monero-bash.conf] not found"
	fi
	for i in ${CONFIG_ARRAY[@]}; do
		[[ $i =~ ^AUTO_START_MONEROD=true*$ ]]        && declare -g AUTO_START_MONEROD=true
		[[ $i =~ ^AUTO_STOP_MONEROD=true*$ ]]         && declare -g AUTO_STOP_MONEROD=true
		[[ $i =~ ^XMRIG_ROOT=true*$ ]]                && declare -g XMRIG_ROOT=true
		[[ $i =~ ^AUTO_UPDATE=true*$ ]]               && declare -g AUTO_UPDATE=true
		[[ $i =~ ^RPC_IP=* ]]                         && declare -g RPC_IP="${i/*=/}"
		[[ $i =~ ^MONERO_BASH_DEBUG=true*$ ]]         && declare -g STD_LOG_DEBUG=true
		[[ $i =~ ^MONERO_BASH_DEBUG_VERBOSE=true*$ ]] && declare -g STD_LOG_DEBUG_VERBOSE=true
	done
	[[ $AUTO_START_MONEROD != true ]]        && declare -g AUTO_START_MONEROD=false
	[[ $AUTO_STOP_MONEROD != true ]]         && declare -g AUTO_STOP_MONEROD=false
	[[ $XMRIG_ROOT != true ]]                && declare -g XMRIG_ROOT=false
	[[ $AUTO_UPDATE != true ]]               && declare -g AUTO_UPDATE=false
	[[ -z $RPC_IP ]]                         && declare -g RPC_IP="localhost:18081"
	[[ $MONERO_BASH_DEBUG != true ]]         && declare -g MONERO_BASH_DEBUG=false
	[[ $MONERO_BASH_DEBUG_VERBOSE != true ]] && declare -g MONERO_BASH_DEBUG_VERBOSE=false
	log::debug "--- monero-bash.conf settings ---"
	log::debug "AUTO_START_MONEROD        | $AUTO_START_MONEROD"
	log::debug "AUTO_STOP_MONEROD         | $AUTO_STOP_MONEROD"
	log::debug "XMRIG_ROOT                | $XMRIG_ROOT"
	log::debug "AUTO_UPDATE               | $AUTO_UPDATE"
	log::debug "RPC_IP                    | $RPC_IP"
	log::debug "RPC_VERBOSE               | $RPC_VERBOSE"
	log::debug "MONERO_BASH_DEBUG         | $STD_LOG_DEBUG"
	log::debug "MONERO_BASH_DEBUG_VERBOSE | $STD_LOG_DEBUG_VERBOSE"
}
parse::options::pkg() {
	[[ $# = 1 ]] && print::help::command "$1"
	shift
	case "$1" in
		*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
		monero|Monero|MONERO) OPTION_MONERO=true;;
		*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
		*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
		*)
			print::error "Invalid option: $1"
			print::exit  "Pick one/multiple packages: [bash|monero|p2pool|xmrig]"
			;;
	esac
	until [[ $# = 0 ]]; do
	shift
	case "$1" in
		*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
		monero|Monero|MONERO) OPTION_MONERO=true;;
		*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
		*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
		--verbose|-v)         OPTION_VERBOSE=true;;
		--force|-f)           OPTION_FORCE=true;;
		"")                   return 0;;
		*)
			print::error "Invalid option: $1"
			print::exit  "Pick one/multiple packages: [bash|monero|p2pool|xmrig]"
			;;
	esac
	done
}
parse::options::process() {
	[[ $# = 1 ]] && print::help::command "$1"
	shift
	case "$1" in
		*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
		monero|Monero|MONERO) OPTION_MONERO=true;;
		*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
		*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
		*)
			print::error "Invalid option: $1"
			print::exit  "Pick one/multiple processes: [bash|monero|p2pool|xmrig]"
			;;
	esac
	until [[ $# = 0 ]]; do
	shift
	case "$1" in
		*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
		monero|Monero|MONERO) OPTION_MONERO=true;;
		*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
		*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
		"")                   return 0;;
		*)
			print::error "Invalid option: $1"
			print::exit  "Pick one/multiple processes: [bash|monero|p2pool|xmrig]"
			;;
	esac
	done
}
parse::options::systemd() {
	[[ $# = 1 ]] && print::help::command "$1"
	until [[ $# = 0 ]]; do
	shift
	case "$1" in
		monero|Monero|MONERO) OPTION_MONERO=true;;
		*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
		*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
		"")                   return 0;;
		*)
			print::error "Invalid option: $1"
			print::exit  "Pick one/multiple processes: [monero|p2pool|xmrig]"
			;;
	esac
	done
}
parse::options() {
log::debug "starting ${FUNCNAME}"
log::debug "user input: $*"
log::debug "unsetting OPTION variables"
unset -v OPTION_BASH OPTION_MONERO OPTION_P2POOL OPTION_XMRIG OPTION_VERBOSE OPTION_FORCE
case "$1" in
	new)  wallet::create;;
	list) wallet::list;;
	size) print::size;;
	update)
		case "$2" in
			--verbose|-v) OPTION_VERBOSE=true;;
			"")           :;;
			*)            print::help::command update;;
		esac
		___BEGIN___ERROR___TRACE___
		pkg::update
		___ENDOF___ERROR___TRACE___
		;;
	install)
		parse::options::pkg "$@"
		___BEGIN___ERROR___TRACE___
		pkg::prompt install
		___ENDOF___ERROR___TRACE___
		;;
	remove)
		parse::options::pkg "$@"
		___BEGIN___ERROR___TRACE___
		remove::prompt
		___ENDOF___ERROR___TRACE___
		;;
	upgrade)
		parse::options::pkg "$@"
		___BEGIN___ERROR___TRACE___
		pkg::prompt
		___ENDOF___ERROR___TRACE___
		;;
	full)
		[[ $# = 1 ]] && print::help::command "$1"
		shift
		[[ $# -gt 1 ]] && print::exit "Pick one process: [monero|p2pool|xmrig]"
		case "$1" in
			*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
			monero|Monero|MONERO) OPTION_MONERO=true;;
			*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
			*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
			*)
				print::error "Invalid process: $1"
				print::exit  "Pick one process: [monero|p2pool|xmrig]"
				;;
		esac
		process::full
		;;
	config)
		parse::options::process "$@"
		process::config
		;;
	default)
		[[ $# = 1 ]] && print::help::command "$1"
		shift
		case "$1" in
			*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
			monero|Monero|MONERO) OPTION_MONERO=true;;
			*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
			*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
			*)
				print::error "Invalid option: $1"
				print::error  "Pick one/multiple processes: [bash|monero|p2pool|xmrig]"
				;;
		esac
		until [[ $# = 0 ]]; do
		shift
		case "$1" in
			*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
			monero|Monero|MONERO) OPTION_MONERO=true;;
			*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
			*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
			--config|-c)          OPTION_CONFIG=true;;
			--systemd|-s)         OPTION_SYSTEMD=true;;
			*)
				print::error "Invalid process: $1"
				print::exit  "Pick one process: [bash|monero|p2pool|xmrig]"
				;;
		esac
		done
		process::default
		;;
	start)
		parse::options::systemd "$@"
		systemd::start
		;;
	stop)
		parse::options::systemd "$@"
		systemd::stop
		;;
	kill)
		parse::options::systemd "$@"
		systemd::kill
		;;
	restart)
		parse::options::systemd "$@"
		systemd::restart
		;;
	watch)
		parse::options::systemd "$@"
		systemd::watch
		;;
	edit)
		parse::options::systemd "$@"
		systemd::edit
		;;
	refresh)
		parse::options::systemd "$@"
		systemd::refresh
		;;
	enable)
		parse::options::systemd "$@"
		systemd::enable
		;;
	disable)
		parse::options::systemd "$@"
		systemd::disable
		;;
	status)  status;;
	version) print::version;;
	uninstall) monero_bash::uninstall;;
	rpc)
		[[ $# = 1 ]] && print::help::command "$1"
		shift
		rpc "$@"
		;;
	changes)
		shift
		[[ $# = 0 ]] && print::changelog && exit
		until [[ $# = 0 ]]; do
			if declare -fp print::changelog::"${1/v}" &>/dev/null; then
				print::changelog::"${1/v}"
			else
				print::error "Version $1 does not exist/is not available"
			fi
			shift
		done
		;;
	help)
		shift
		___BEGIN___ERROR___TRACE___
		if [[ $1 ]]; then
			print::help::command "$@"
		else
			print::help
		fi
		___ENDOF___ERROR___TRACE___
		;;
	*)
		log::debug "user input failed: $*"
		print::error "Invalid option: $*"
		print::exit "$(printf "${OFF}%s${BYELLOW}%s${OFF}\n" "For help, type: " "monero-bash help")"
		;;
esac
exit
}
parse::p2pool() {
	log::debug "starting ${FUNCNAME}()"
	local i IFS=$'\n' CONFIG_ARRAY || return 1
	mapfile CONFIG_ARRAY < "$CONFIG_P2POOL" || return 2
	for i in "${CONFIG_ARRAY[@]}"; do
		[[ $i =~ ^P2POOL_WALLET=*$ ]]       && declare -g P2POOL_WALLET="${i/*=/}"
		[[ $i =~ ^P2POOL_HOST=*$ ]]         && declare -g P2POOL_HOST="${i/*=/}"
		[[ $i =~ ^P2POOL_RPC_PORT=*$ ]]     && declare -g P2POOL_RPC_PORT="${i/*=/}"
		[[ $i =~ ^P2POOL_ZMQ_PORT=*$ ]]     && declare -g P2POOL_ZMQ_PORT="${i/*=/}"
		[[ $i =~ ^P2POOL_STRATUM=*$ ]]      && declare -g P2POOL_STRATUM="${i/*=/}"
		[[ $i =~ ^P2POOL_P2P=*$ ]]          && declare -g P2POOL_P2P="${i/*=/}"
		[[ $i =~ ^P2POOL_ADD_PEERS=*$ ]]    && declare -g P2POOL_ADD_PEERS="${i/*=/}"
		[[ $i =~ ^P2POOL_LIGHT_MODE=*$ ]]   && declare -g P2POOL_LIGHT_MODE="${i/*=/}"
		[[ $i =~ ^P2POOL_CONFIG=*$ ]]       && declare -g P2POOL_CONFIG="${i/*=/}"
		[[ $i =~ ^P2POOL_LOG_LEVEL=*$ ]]    && declare -g P2POOL_LOG_LEVEL="${i/*=/}"
		[[ $i =~ ^P2POOL_DATA_API=*$ ]]     && declare -g P2POOL_DATA_API="${i/*=/}"
		[[ $i =~ ^P2POOL_LOCAL_API=*$ ]]    && declare -g P2POOL_LOCAL_API="${i/*=/}"
		[[ $i =~ ^P2POOL_NO_CACHE=*$ ]]     && declare -g P2POOL_NO_CACHE="${i/*=/}"
		[[ $i =~ ^P2POOL_NO_COLOR=*$ ]]     && declare -g P2POOL_NO_COLOR="${i/*=/}"
		[[ $i =~ ^P2POOL_NO_RANDOMX=*$ ]]   && declare -g P2POOL_NO_RANDOMX="${i/*=/}"
		[[ $i =~ ^P2POOL_OUT_PEERS=*$ ]]    && declare -g P2POOL_OUT_PEERS="${i/*=/}"
		[[ $i =~ ^P2POOL_IN_PEERS=*$ ]]     && declare -g P2POOL_IN_PEERS="${i/*=/}"
		[[ $i =~ ^P2POOL_START_MINING=*$ ]] && declare -g P2POOL_START_MINING="${i/*=/}"
		[[ $i =~ ^P2POOL_MINI=*$ ]]         && declare -g P2POOL_MINI="${i/*=/}"
		[[ $i =~ ^P2POOL_NO_AUTODIFF=*$ ]]  && declare -g P2POOL_NO_AUTODIFF="${i/*=/}"
		[[ $i =~ ^P2POOL_RPC_LOGIN=*$ ]]    && declare -g P2POOL_RPC_LOGIN="${i/*=/}"
	done
	[[ -z $P2POOL_HOST ]]             && declare -g P2POOL_HOST=127.0.0.1
	[[ -z $P2POOL_RPC_PORT ]]         && declare -g P2POOL_RPC_PORT=18081
	[[ -z $P2POOL_ZMQ_PORT ]]         && declare -g P2POOL_ZMQ_PORT=18083
	[[ $P2POOL_LIGHT_MODE != true ]]  && declare -g P2POOL_LIGHT_MODE=false
	[[ -z $P2POOL_LOG_LEVEL ]]        && declare -g P2POOL_LOG_LEVEL=2
	[[ $P2POOL_NO_CACHE != true ]]    && declare -g P2POOL_NO_CACHE=false
	[[ $P2POOL_NO_COLOR != true ]]    && declare -g P2POOL_NO_COLOR=false
	[[ $P2POOL_NO_RANDOMX != true ]]  && declare -g P2POOL_NO_RANDOMX=false
	[[ $P2POOL_MINI != true ]]        && declare -g P2POOL_MINI=false
	[[ $P2POOL_NO_AUTODIFF != true ]] && declare -g P2POOL_NO_AUTODIFF=false
	declare -g P2POOL_COMMAND || return 3
	P2POOL_COMMAND="--wallet $P2POOL_WALLET"
	P2POOL_COMMAND="$P2POOL_COMMAND --host $P2POOL_HOST"
	P2POOL_COMMAND="$P2POOL_COMMAND --rpc-port $P2POOL_RPC_PORT"
	P2POOL_COMMAND="$P2POOL_COMMAND --zmq-port $P2POOL_ZMQ_PORT"
	[[ $P2POOL_STRATUM ]]            && P2POOL_COMMAND="$P2POOL_COMMAND --stratum $P2POOL_STRATUM"
	[[ $P2POOL_P2P ]]                && P2POOL_COMMAND="$P2POOL_COMMAND --p2p $P2POOL_P2P"
	[[ $P2POOL_ADD_PEERS ]]          && P2POOL_COMMAND="$P2POOL_COMMAND --addpeers $P2POOL_ADD_PEERS"
	[[ $P2POOL_LIGHT_MODE = true ]]  && P2POOL_COMMAND="$P2POOL_COMMAND --light-mode"
	P2POOL_COMMAND="$P2POOL_COMMAND --loglevel $P2POOL_LOG_LEVEL"
	[[ $P2POOL_CONFIG ]]             && P2POOL_COMMAND="$P2POOL_COMMAND --config $P2POOL_CONFIG"
	[[ $P2POOL_DATA_API ]]           && P2POOL_COMMAND="$P2POOL_COMMAND --data-api $P2POOL_DATA_API"
	[[ $P2POOL_LOCAL_API ]]          && P2POOL_COMMAND="$P2POOL_COMMAND --local-api $P2POOL_LOCAL_API"
	[[ $P2POOL_NO_CACHE = true ]]    && P2POOL_COMMAND="$P2POOL_COMMAND --no-cache"
	[[ $P2POOL_NO_COLOR = true ]]    && P2POOL_COMMAND="$P2POOL_COMMAND --no-color"
	[[ $P2POOL_NO_RANDOMX = true ]]  && P2POOL_COMMAND="$P2POOL_COMMAND --no-randomx"
	[[ $P2POOL_OUT_PEERS ]]          && P2POOL_COMMAND="$P2POOL_COMMAND --out-peers $P2POOL_OUT_PEERS"
	[[ $P2POOL_IN_PEERS ]]           && P2POOL_COMMAND="$P2POOL_COMMAND --in-peers $P2POOL_IN_PEERS"
	[[ $P2POOL_START_MINING ]]       && P2POOL_COMMAND="$P2POOL_COMMAND --start-mining $P2POOL_START_MINING"
	[[ $P2POOL_MINI = true ]]        && P2POOL_COMMAND="$P2POOL_COMMAND --mini"
	[[ $P2POOL_NO_AUTODIFF = true ]] && P2POOL_COMMAND="$P2POOL_COMMAND --no-autodiff"
	[[ $P2POOL_RPC_LOGIN ]]          && P2POOL_COMMAND="$P2POOL_COMMAND --rpc-login $P2POOL_RPC_LOGIN"
	log::debug "--- p2pool.conf settings ---"
	log::debug "P2POOL_WALLET       | $P2POOL_WALLET"
	log::debug "P2POOL_HOST         | $P2POOL_HOST"
	log::debug "P2POOL_RPC_PORT     | $P2POOL_RPC_PORT"
	log::debug "P2POOL_ZMQ_PORT     | $P2POOL_ZMQ_PORT"
	log::debug "P2POOL_STRATUM      | $P2POOL_STRATUM"
	log::debug "P2POOL_P2P          | $P2POOL_P2P"
	log::debug "P2POOL_ADD_PEERS    | $P2POOL_ADD_PEERS"
	log::debug "P2POOL_LIGHT_MODE   | $P2POOL_LIGHT_MODE"
	log::debug "P2POOL_CONFIG       | $P2POOL_CONFIG"
	log::debug "P2POOL_LOG_LEVEL    | $P2POOL_LOG_LEVEL"
	log::debug "P2POOL_DATA_API     | $P2POOL_DATA_API"
	log::debug "P2POOL_LOCAL_API    | $P2POOL_LOCAL_API"
	log::debug "P2POOL_NO_CACHE     | $P2POOL_NO_CACHE"
	log::debug "P2POOL_NO_COLOR     | $P2POOL_NO_COLOR"
	log::debug "P2POOL_NO_RANDOMX   | $P2POOL_NO_RANDOMX"
	log::debug "P2POOL_OUT_PEERS    | $P2POOL_OUT_PEERS"
	log::debug "P2POOL_IN_PEERS     | $P2POOL_IN_PEERS"
	log::debug "P2POOL_START_MINING | $P2POOL_START_MINING"
	log::debug "P2POOL_MINI         | $P2POOL_MINI"
	log::debug "P2POOL_NO_AUTODIFF  | $P2POOL_NO_AUTODIFF"
	log::debug "P2POOL_RPC_LOGIN    | $P2POOL_RPC_LOGIN"
	log::debug "final p2pool command: $P2POOL_COMMAND"
	return 0
}
parse::state() {
	log::debug "starting ${FUNCNAME}()"
	local i IFS=$'\n' STATE_ARRAY STATE_PATH || return 1
	if [[ -e "$RELATIVE/txt/state" ]]; then
		log::debug "state found, using: ${RELATIVE}/txt/state"
		mapfile STATE_ARRAY < "${RELATIVE}/txt/state" || return 2
	else
		print::exit "state file was not found"
	fi
	for i in ${STATE_ARRAY[@]}; do
		[[ $i =~ ^FIRST_TIME=true*$ ]]      && declare -g FIRST_TIME=true
		[[ $i =~ ^MONERO_BASH_VER=* ]]      && declare -g MONERO_BASH_VER="${i/*=/}"
		[[ $i =~ ^MONERO_VER=* ]]           && declare -g MONERO_VER="${i/*=/}"
		[[ $i =~ ^P2POOL_VER=* ]]           && declare -g P2POOL_VER="${i/*=/}"
		[[ $i =~ ^XMRIG_VER=* ]]            && declare -g XMRIG_VER="${i/*=/}"
		[[ $i =~ ^MONERO_BASH_OLD=true*$ ]] && declare -g MONERO_BASH_OLD=true
		[[ $i =~ ^MONERO_OLD=true*$ ]]      && declare -g MONERO_OLD=true
		[[ $i =~ ^P2POOL_OLD=true*$ ]]      && declare -g P2POOL_OLD=true
		[[ $i =~ ^XMRIG_OLD=true*$ ]]       && declare -g XMRIG_OLD=true
	done
	[[ $FIRST_TIME != true ]]        && declare -g FIRST_TIME=
	[[ $MONERO_BASH_OLD != true ]]   && declare -g MONERO_BASH_OLD=
	[[ $MONERO_OLD != true ]]        && declare -g MONERO_OLD=
	[[ $P2POOL_OLD != true ]]        && declare -g P2POOL_OLD=
	[[ $XMRIG_OLD != true ]]         && declare -g XMRIG_OLD=
	log::debug "--- state file ---"
	log::debug "FIRST_TIME        | $FIRST_TIME"
	log::debug "MINE_UNCONFIGURED | $MINE_UNCONFIGURED"
	log::debug "MONERO_BASH_VER   | $MONERO_BASH_VER"
	log::debug "MONERO_VER        | $MONERO_VER"
	log::debug "P2POOL_VER        | $P2POOL_VER"
	log::debug "XMRIG_VER         | $XMRIG_VER"
	log::debug "MONERO_BASH_OLD   | $MONERO_BASH_OLD"
	log::debug "MONERO_OLD        | $MONERO_OLD"
	log::debug "P2POOL_OLD        | $P2POOL_OLD"
	log::debug "XMRIG_OLD         | $XMRIG_OLD"
}
pkg::copy() {
	log::debug "starting ${FUNCNAME}()"
	if [[ $MONERO_BASH_OLD = true ]]; then
		struct::pkg bash
		pkg::copy::cp
	fi
	if [[ $MONERO_OLD = true ]]; then
		struct::pkg monero
		pkg::copy::cp
	fi
	if [[ $P2POOL_OLD = true ]]; then
		struct::pkg p2pool
		pkg::copy::cp
	fi
	if [[ $XMRIG_OLD = true ]]; then
		struct::pkg xmrig
		pkg::copy::cp
	fi
	return 0
}
pkg::copy::cp() {
		log::prog "${PKG[pretty]}"
		mkdir -p "${PKG[directory]}"
		cp -fr "${TMP_PKG[${PKG[short]}_folder]}/*" "${PKG[directory]}"
		log::debug "copied ${TMP_PKG[${PKG[short]}_folder]} contents into ${PKG[directory]}"
		log::ok "${PKG[pretty]}"
}
pkg::download() {
	log::debug "starting ${FUNCNAME}()"
	if [[ $MONERO_BASH_OLD = true ]]; then
		struct::pkg bash
		pkg::tmp::download
		pkg::download::multi &
	fi
	if [[ $MONERO_OLD = true ]]; then
		struct::pkg monero
		pkg::tmp::download
		pkg::download::multi &
	fi
	if [[ $P2POOL_OLD = true ]]; then
		struct::pkg p2pool
		pkg::tmp::download
		pkg::download::multi &
	fi
	if [[ $XMRIG_OLD = true ]]; then
		struct::pkg xmrig
		pkg::tmp::download
		pkg::download::multi &
	fi
	log::debug "waiting for download threads to complete"
	if ! wait -n; then
		print::exit "Upgrade failure - download failed"
	fi
	return 0
}
pkg::download::multi() {
	log::debug "starting download thread for: ${PKG[pretty]}"
	[[ ${PKG[name]} = xmrig ]] && $DOWNLOAD_OUT "${TMP_PKG[${PKG[short]}_sig]}" "$LINK_SIG" &
	$DOWNLOAD_OUT "${TMP_PKG[${PKG[short]}_hash]}" "$LINK_HASH" &
	$DOWNLOAD_CMD "${TMP_PKG[${PKG[short]}_pkg]}" "$LINK_PKG" &
	TMP_PKG[${PKG[short]}_tar]="$(ls ${TMP_PKG[${PKG[short]}_pkg]})"
	TMP_PKG[${PKG[short]}_tar]="${TMP_PKG[${PKG[short]}_pkg]}/${TMP_PKG[${PKG[short]}_tar]}"
	log::debug "downloaded tar: ${TMP_PKG[${PKG[short]}_tar]}"
}
pkg::extract() {
	log::debug "starting ${FUNCNAME}()"
	if [[ $MONERO_BASH_OLD = true ]]; then
		struct::pkg bash
		pkg::extract::multi &
	fi
	if [[ $MONERO_OLD = true ]]; then
		struct::pkg monero
		pkg::extract::multi &
	fi
	if [[ $P2POOL_OLD = true ]]; then
		struct::pkg p2pool
		pkg::extract::multi &
	fi
	if [[ $XMRIG_OLD = true ]]; then
		struct::pkg xmrig
		pkg::extract::multi &
	fi
	log::debug "waiting for extraction threads to complete"
	if ! wait -n; then
		print::exit "Upgrade failure - extraction failed"
	fi
	return 0
}
pkg::extract::multi() {
	log::debug "starting extraction thread for: ${PKG[pretty]}"
	tar -xf "${TMP_PKG[${PKG[short]}_tar]}" -C "${TMP_PKG[${PKG[short]}_pkg]}"
	log::debug "extraction complete for: ${TMP_PKG[${PKG[short]}_tar]}"
	rm "${TMP_PKG[${PKG[short]}_tar]}"
	log::debug "removed tar: ${TMP_PKG[${PKG[short]}_tar]}"
	TMP_PKG[${PKG[short]}_folder]="$(ls ${TMP_PKG[${PKG[short]}_pkg]})"
	log::debug "extracted package folder: ${TMP_PKG[${PKG[short]}_folder]}"
}
pkg::hook::pre() {
	log::debug "starting ${FUNCNAME}()"
	if [[ $MONERO_BASH_OLD = true ]]; then
		pkg::hook::pre::bash
	else
		log::ok "no hooks found"
	fi
}
pkg::hook::post() {
	log::debug "starting ${FUNCNAME}()"
	log::debug "recreating old state in: $STATE"
	echo "${HOOK_BASH_STATE[@]}" > "$STATE"
	[[ $MONERO_BASH_OLD = true ]] && pkg::hook::post::bash
	if [[ $MONERO_OLD = true ]]; then
		struct::pkg monero
		pkg::hook::post::config
		pkg::hook::post::systemd
	fi
	if [[ $P2POOL_OLD = true ]]; then
		struct::pkg monero
		pkg::hook::post::config
		pkg::hook::post::systemd
	fi
	if [[ $XMRIG_OLD = true ]]; then
		struct::pkg monero
		pkg::hook::post::config
		pkg::hook::post::systemd
	fi
	if [[ $MONERO_OLD = true || $P2POOL_OLD = true || $XMRIG_OLD = true ]]; then
		log::prog "Reloading systemd..."
		systemd::reload
		log::ok "Reloaded systemd"
	fi
	log::prog "Setting permissions..."
	sudo chmod -R 770 "$PACKAGES"
	sudo chown -R "monero-bash:$USER" "$PACKAGES"
	log::ok "Set permissions"
}
pkg::hook::post::config() {
	log::debug "starting ${FUNCNAME}() for: ${PKG[pretty]}"
	log::prog "${PKG[pretty]} | config file check: ${PKG[conf_name]}..."
	if [[ -e ${PKG[config]} ]]; then
		log::ok "${PKG[pretty]} | config file found: ${PKG[conf_name]}"
	else
		log::debug "no config found, copying $SRC_CONFIG/${PKG[conf_name]} to $CONFIG"
		cp "$SRC_CONFIG/${PKG[conf_name]}" "$CONFIG"
		log::ok "${PKG[pretty]} | config file installed: ${PKG[conf_name]}"
	fi
	if [[ ${PKG[name]} = monero ]]; then
		log::prog "${PKG[pretty]} | config file check: monero-wallet-cli.conf..."
		if [[ -e "$CONFIG/monero-wallet-cli.conf" ]]; then
			log::ok "${PKG[pretty]} | config file found: monero-wallet-cli.conf"
		else
			log::debug "no config found, copying $SRC_CONFIG/monero-wallet-cli.conf to $CONFIG"
			cp "$SRC_CONFIG/${PKG[conf_name]}" "$CONFIG"
			log::ok "${PKG[pretty]} | config file installed: monero-wallet-cli.conf"
		fi
	fi
}
pkg::hook::post:systemd() {
	log::debug "starting ${FUNCNAME}() for: ${PKG[pretty]}"
	log::prog "${PKG[pretty]} | systemd service check: ${PKG[service]}..."
	if [[ -e "$SYSTEMD/${PKG[service]}" ]]; then
		log::ok "${PKG[pretty]} | systemd service found: ${PKG[service]}"
	else
		log::debug "no systemd service found, creating: $SYSTEMD/${PKG[service]}"
		systemd::create
		log::ok "${PKG[pretty]} | systemd service installed: ${PKG[service]}"
	fi
}
pkg::hook::pre::bash() {
	log::debug "starting ${FUNCNAME}()"
	log::prog "monero-bash | saving state..."
	map HOOK_BASH_STATE
	mapfile HOOK_BASH_STATE < "$STATE"
	log::ok "monero-bash | state saved"
}
pkg::hook::post::bash() {
	log::debug "starting ${FUNCNAME}()"
	unset -v DIFF
	local DIFF
	local IFS=$'\n' i
	log::prog "monero-bash | diff for: monero-bash.conf..."
	if DIFF=$(diff --side-by-side --left-column "$CONFIG_MONERO_BASH" "${TMP_PKG[bash_pkg]}/config/monero-bash.conf"); then
		log::ok "monero-bash | no diff: monero-bash.conf"
	else
		log::debug "--- monero-bash.conf diff ---"
		for i in $DIFF; do
			log::debug "$i"
		done
		DIFF=$(echo "$DIFF" | sed -e 's/[[:space:]]\+(//g' -e 's/[[:space:]]\+|.*$//g' -e 's/[[:space:]]\+>\t//g' -e 's/[[:space:]]\+>$//g')
		echo "$DIFF" > "$CONFIG_MONERO_BASH"
		log::ok "monero-bash | diff applied: monero-bash.conf"
	fi
	unset -v DIFF
	local DIFF
	log::prog "monero-bash | diff for: state..."
	if DIFF=$(diff --side-by-side --left-column "$STATE" "${TMP_PKG[bash_pkg]}/txt/state"); then
		log::ok "monero-bash | no diff: state"
	else
		log::debug "--- state diff ---"
		for i in $DIFF; do
			log::debug "$i"
		done
		DIFF=$(echo "$DIFF" | sed -e 's/[[:space:]]\+(//g' -e 's/[[:space:]]\+|.*$//g' -e 's/[[:space:]]\+>\t//g' -e 's/[[:space:]]\+>$//g')
		echo "$DIFF" > "$STATE"
		log::ok "monero-bash | diff applied: state"
	fi
	unset -v DIFF
	local DIFF
	[[ $P2POOL_VER ]] || return 0
	log::prog "p2pool | diff for: p2pool.conf..."
	if DIFF=$(diff --side-by-side --left-column "$CONFIG_P2POOL" "${TMP_PKG[bash_pkg]}/config/p2pool.conf"); then
		log::debug "p2pool | no diff: p2pool.conf"
	else
		log::debug "--- p2pool.conf diff ---"
		for i in $DIFF; do
			log::debug "$i"
		done
		DIFF=$(echo "$DIFF" | sed -e 's/[[:space:]]\+(//g' -e 's/[[:space:]]\+|.*$//g' -e 's/[[:space:]]\+>\t//g' -e 's/[[:space:]]\+>$//g')
		echo "$DIFF" > "$CONFIG_P2POOL"
		log::ok "p2pool | diff applied: p2pool.conf"
	fi
	return 0
}
pkg::info() {
	log::debug "starting ${FUNCNAME}()"
	pkg::tmp::info info
	map VER HTML LINK_DOWN LINK_HASH LINK_SIG
	local UPDATE_FOUND
	declare -a SCRATCH
	if [[ $MONERO_BASH_OLD = true ]]; then
		struct::pkg bash
		pkg::update::multi &
	fi
	if [[ $MONERO_OLD = true ]]; then
		struct::pkg monero
		pkg::update::multi &
	fi
	if [[ $P2POOL_OLD = true ]]; then
		struct::pkg p2pool
		pkg::update::multi &
	fi
	if [[ $XMRIG_OLD = true ]]; then
		struct::pkg xmrig
		pkg::update::multi &
	fi
	log::debug "waiting for metadata threads to complete"
	if ! wait -n; then
		print::exit "Update failure - unable to connect to GitHub"
	fi
	if [[ $MONERO_BASH_OLD = true ]]; then
		struct::pkg bash
		pkg::update::ver
		pkg::info::down
		pkg::info::hash
	fi
	if [[ $MONERO_OLD = true ]]; then
		struct::pkg monero
		pkg::update::ver
		pkg::info::down
		pkg::info::hash
	fi
	if [[ $P2POOL_OLD = true ]]; then
		struct::pkg p2pool
		pkg::update::ver
		pkg::info::down
		pkg::info::hash
	fi
	if [[ $XMRIG_OLD = true ]]; then
		struct::pkg xmrig
		pkg::update::ver
		pkg::info::down
		pkg::info::hash
		pkg::info::sig
	fi
}
pkg::info::down() {
	log::debug "starting ${FUNCNAME}()"
	if [[ ${PKG[name]} = monero ]]; then
		LINK_DOWN="https://downloads.getmonero.org/cli/linux64"
		log::debug "package Monero detected, LINK_DOWN: $LINK_DOWN"
		return 0
	fi
	if [[ ${HTML[${PKG[short]}} = true ]]; then
		LINK_DOWN[${PKG[short]}]="$(grep -o "/${PKG[author]}/${PKG[name]}/releases/download/.*/${PKG[regex]}" "${TMP_INFO[${PKG[short]}]}")"
		LINK_DOWN[${PKG[short]}]="${LINK_DOWN[${PKG[short]}]//\"*}"
		LINK_DOWN[${PKG[short]}]="https://github.com/${LINK_DOWN[${PKG[short]}]}"
	else
		LINK_DOWN[${PKG[short]}]="$(grep -o "https://github.com/${PKG[author]}/${PKG[name]}/releases/download/.*/${PKG[regex]}" "${TMP_INFO[${PKG[short]}]}")"
		LINK_DOWN[${PKG[short]}]="${LINK_DOWN[${PKG[short]}]//\"}"
	fi
	log::debug "${PKG[name]} download link found: $LINK_DOWN"
}
pkg::info::hash() {
	log::debug "starting ${FUNCNAME}()"
	if [[ ${PKG[name]} = monero ]]; then
		LINK_HASH="https://downloads.getmonero.org/cli/linux64"
		log::debug "package Monero detected, LINK_HASH: $LINK_HASH"
		return 0
	fi
	LINK_HASH="https://github.com/${PKG[author]}/${PKG[name]}/releases/download/${VER[${PKG[short]}]}/${PKG[hash]}"
	log::debug "${PKG[name]} hash link: $LINK_HASH"
}
pkg::info::sig() {
	log::debug "starting ${FUNCNAME}()"
	LINK_SIG="https://github.com/${PKG[author]}/${PKG[name]}/releases/download/${VER[${PKG[short]}]}/${PKG[sig]}"
	log::debug "${PKG[name]} sig link: $LINK_SIG"
}
pkg::prompt() {
	log::debug "starting ${FUNCNAME}()"
	local PROMPT_VERB PROMPT_NOUN
	if [[ $1 = install ]]; then
		PROMPT_VERB="Installing"
		PROMPT_NOUN="install"
	else
		PROMPT_VERB="Upgrading"
		PROMPT_NOUN="upgrade"
	fi
	if [[ $OPTION_VERBOSE = true ]]; then
		STD_LOG_DEBUG=true
		printf "${BBLUE}%s${OFF}\n" "$PROMPT_VERB verbosely...!"
	fi
	[[ $OPTION_FORCE = true ]]   && printf "${BBLUE}%s${OFF}\n" "$PROMPT_VERB forcefully...!"
	local UPGRADE_LIST
	[[ $OPTION_BASH = true ]]   && UPGRADE_LIST="[monero-bash]"
	[[ $OPTION_MONERO = true ]] && UPGRADE_LIST="$UPGRADE_LIST [monero]"
	[[ $OPTION_P2POOL = true ]] && UPGRADE_LIST="$UPGRADE_LIST [p2pool]"
	[[ $OPTION_XMRIG = true ]]  && UPGRADE_LIST="$UPGRADE_LIST [xmrig]"
	if [[ $OPTION_FORCE != true ]]; then
		if [[ $OPTION_BASH = true && $MONERO_BASH_OLD != true ]]; then
			printf "${OFF}%s\n" "[monero-bash] ($MONERO_BASH_VER) is up to date"
			UPGRADE_LIST="${UPGRADE_LIST/\[monero-bash\]}"
		fi
		if [[ $OPTION_MONERO = true && $MONERO_OLD != true ]]; then
			printf "${OFF}%s\n" "[monero] ($MONERO_VER) is up to date"
			UPGRADE_LIST="${UPGRADE_LIST/\[monero\]}"
		fi
		if [[ $OPTION_P2POOL = true && $P2POOL_OLD != true ]]; then
			printf "${OFF}%s\n" "[p2pool] ($P2POOL_VER) is up to date"
			UPGRADE_LIST="${UPGRADE_LIST/\[p2pool\]}"
		fi
		if [[ $OPTION_XMRIG = true && $XMRIG_OLD != true ]]; then
			printf "${OFF}%s\n" "[xmrig] ($XMRIG_VER) is up to date"
			UPGRADE_LIST="${UPGRADE_LIST/\[xmrig\]}"
		fi
		if [[ $UPGRADE_LIST = " " || -z $UPGRADE_LIST ]]; then
			log::debug "UPGRADE_LIST is empty, exiting"
			exit 1
		fi
	fi
	printf "${BWHITE}%s${OFF}%s\n\n${BWHITE}%s" \
		"Packages to $PROMPT_NOUN: " \
		"$UPGRADE_LIST" \
		"Continue with ${PROMPT_NOUN}? (Y/n) "
	if ! ask::yes; then
		print::exit "Canceling $PROMPT_NOUN"
	fi
	if ! ask::sudo; then
		print::exit "sudo is required"
	fi
	log::debug "starting $PROMPT_NOUN of packages: $UPGRADE_LIST"
	UPGRADE_LIST=("$UPGRADE_LIST")
	UPGRADE_LIST=("${UPGRADE_LIST[@]//[}")
	UPGRADE_LIST=("${UPGRADE_LIST[@]//]}")
	pkg::upgrade
}
pkg::remove::prompt() {
	log::debug "starting ${FUNCNAME}()"
	local REMOVE_LIST || return 1
	if [[ $OPTION_REMOVE_BASH = true ]]; then
		printf "${OFF}%s\n%s${BYELLOW}%s${OFF}%s\n" \
			"[monero-bash] ($MONERO_BASH_VER) cannot be removed normally" \
			"type: " \
			"[monero-bash uninstall]" \
			"to cleanly uninstall monero-bash from your system"
		exit 1
	fi
	[[ $OPTION_REMOVE_MONERO = true ]] && REMOVE_LIST="$REMOVE_LIST [monero]"
	[[ $OPTION_REMOVE_P2POOL = true ]] && REMOVE_LIST="$REMOVE_LIST [p2pool]"
	[[ $OPTION_REMOVE_XMRIG = true ]]  && REMOVE_LIST="$REMOVE_LIST [xmrig]"
	if [[ $OPTION_REMOVE_MONERO = true && -z $MONERO_VER ]]; then
		printf "${OFF}%s\n" "[monero] is not installed"
		REMOVE_LIST="${REMOVE_LIST/\[monero\]}"
	fi
	if [[ $OPTION_REMOVE_P2POOL = true && -z $P2POOL_VER ]]; then
		printf "${OFF}%s\n" "[p2pool] is not installed"
		REMOVE_LIST="${REMOVE_LIST/\[p2pool\]}"
	fi
	if [[ $OPTION_REMOVE_XMRIG = true && -z $XMRIG_VER ]]; then
		printf "${OFF}%s\n" "[xmrig] is not installed"
		REMOVE_LIST="${REMOVE_LIST/\[xmrig\]}"
	fi
	[[ $REMOVE_LIST = " " ]] && exit 1
	printf "${BWHITE}%s${OFF}%s\n\n${BWHITE}%s" \
		"Packages to remove: " \
		"$REMOVE_LIST" \
		"Continue with removal? (y/N) "
	if ask::no; then
		print::exit "Canceling installation"
	fi
	if ! ask::sudo; then
		print::exit "sudo is required"
	fi
	[[ $OPTION_REMOVE_MONERO = true ]] && struct::pkg monero && pkg::remove
	[[ $OPTION_REMOVE_P2POOL = true ]] && struct::pkg p2pool && pkg::remove
	[[ $OPTION_REMOVE_XMRIG = true ]]  && struct::pkg xmrig  && pkg::remove
}
pkg::remove() {
	log::debug "starting ${FUNCNAME}() on package: ${PKG[name]}"
	trap "" INT
	print::remove
	trap 'trap::remove &' EXIT
	log::prog "${PKG[directory]}..."
	rm "${PKG[directory]}"
	log::ok "${PKG[directory]} deleted"
	log::prog "${PKG[service]}..."
	sudo rm "$SYSTEMD/${PKG[service]}"
	log::ok "${PKG[service]} deleted"
	log::prog "Updating local state..."
	sudo sed \
		-i -e "s/${PKG[var]}_VER=./${PKG[var]}_VER=/" "$STATE" \
		-i -e "s/${PKG[var]}_OLD=./${PKG[var]}_OLD=\"true\"/" "$STATE"
	log::ok "Updated local state"
	trap - INT EXIT
	log::prog "Reloading systemd..."
	systemd::reload
	log::ok "Reloaded systemd"
	print::removed
	exit 0
}
pkg::tmp::download() {
	log::debug "starting ${FUNCNAME}()"
	pkg::tmp::remove
	log::debug "creating tmp package files/folders"
	declare -Ag TMP_PKG
	TMP_PKG[${PKG[short]}_main]="$(mktemp -d /tmp/monero-bash.XXXXXXXXXX)"
	TMP_PKG[${PKG[short]}_pkg]="$(mktemp -d ${TMP_PKG[${PKG[short]}_main]}/monero-bash-pkg.XXXXXXXXXX)"
	TMP_PKG[${PKG[short]}_gpg]="$(mktemp ${TMP_PKG[${PKG[short]}_main]}/monero-bash-gpg.XXXXXXXXXX)"
	TMP_PKG[${PKG[short]}_sig]="$(mktemp ${TMP_PKG[${PKG[short]}_main]}/monero-bash-sig.XXXXXXXXXX)"
	TMP_PKG[${PKG[short]}_hash]="$(mktemp ${TMP_PKG[${PKG[short]}_main]}/monero-bash-hash.XXXXXXXXXX)"
	log::debug "--- tmp pkg folders ---"
	log::debug "TMP_PKG[main] | ${TMP_PKG[main]}"
	log::debug "TMP_PKG[pkg]  | ${TMP_PKG[pkg]}"
	log::debug "TMP_PKG[gpg]  | ${TMP_PKG[gpg]}"
	log::debug "TMP_PKG[sig]  | ${TMP_PKG[sig]}"
	log::debug "TMP_PKG[hash] | ${TMP_PKG[hash]}"
}
pkg::tmp::info() {
	log::debug "starting ${FUNCNAME}()"
	pkg::tmp::remove
	log::debug "creating tmp package info files"
	map TMP_INFO TMP_INFO[main] TMP_INFO[bash] TMP_INFO[monero] TMP_INFO[p2pool] TMP_INFO[xmrig]
	if [[ $1 = update ]]; then
		TMP_INFO[main]="$(mktemp -d /tmp/monero-bash-info.XXXXXXXXXX)"
		TMP_INFO[bash]="$(mktemp ${TMP_INFO[main]}/bash-info.XXXXXXXXXX)"
		[[ $MONERO_VER ]] && TMP_INFO[monero]="$(mktemp ${TMP_INFO[monero]}/monero-info.XXXXXXXXXX)"
		[[ $P2POOL_VER ]] && TMP_INFO[p2pool]="$(mktemp ${TMP_INFO[p2pool]}/p2pool-info.XXXXXXXXXX)"
		[[ $XMRIG_VER ]]  && TMP_INFO[xmrig]="$(mktemp ${TMP_INFO[xmrig]}/xmrig-info.XXXXXXXXXX)"
	elif [[ $1 = info ]]; then
		TMP_INFO[main]="$(mktemp -d /tmp/monero-bash-info.XXXXXXXXXX)"
		[[ $MONERO_BASH_OLD = true ]] && TMP_INFO[bash]="$(mktemp ${TMP_INFO[main]}/bash-info.XXXXXXXXXX)"
		[[ $MONERO_OLD = true ]]      && TMP_INFO[monero]="$(mktemp ${TMP_INFO[monero]}/monero-info.XXXXXXXXXX)"
		[[ $P2POOL_OLD = true ]]      && TMP_INFO[p2pool]="$(mktemp ${TMP_INFO[p2pool]}/p2pool-info.XXXXXXXXXX)"
		[[ $XMRIG_OLD = true ]]       && TMP_INFO[xmrig]="$(mktemp ${TMP_INFO[xmrig]}/xmrig-info.XXXXXXXXXX)"
	fi
	log::debug "--- tmp info folders ---"
	log::debug "TMP_INFO[main]   | ${TMP_INFO[main]}"
	log::debug "TMP_INFO[bash]   | ${TMP_INFO[bash]}"
	log::debug "TMP_INFO[monero] | ${TMP_INFO[monero]}"
	log::debug "TMP_INFO[p2pool] | ${TMP_INFO[p2pool]}"
	log::debug "TMP_INFO[xmrig]  | ${TMP_INFO[xmrig]}"
	return 0
}
pkg::tmp::remove() {
	log::debug "starting ${FUNCNAME}()"
	if find /tmp/monero-bash* &>/dev/null; then
		log::debug "old tmp folders found, removing"
		rm -rf /tmp/monero-bash*
	else
		log::debug "no old tmp folders found, skipping"
	fi
}
pkg::trap::pkg_folders() {
	log::debug "starting ${FUNCNAME}()"
	printf "${BRED}%s${BYELLOW}%s${OFF}%s${BWHITE}%s${OFF}\n" \
	"[monero-bash] " \
	"exit signal caught " \
	"| " \
	"cleaning up temporary files"
	tmp::remove
}
pkg::trap::state::old() {
	log::debug "starting ${FUNCNAME}()"
	echo "${HOOK_BASH_STATE[@]}" > "$STATE"
}
pkg::trap::remove() {
	log::debug "starting ${FUNCNAME}()"
	printf "${BRED}%s${BYELLOW}%s${OFF}%s${BWHITE}%s${OFF}\n" \
	"[monero-bash] " \
	"exit signal caught " \
	"| " \
	"updating local state"
	sudo sed \
		-i -e "s/${PKG[var]}_VER=./${PKG[var]}_VER=/" "$STATE" \
		-i -e "s/${PKG[var]}_OLD=./${PKG[var]}_OLD=\"true\"/" "$STATE"
}
pkg::update() {
	if [[ $OPTION_VERBOSE = true ]]; then
		STD_LOG_DEBUG=true
	fi
	log::debug "starting ${FUNCNAME}()"
	trap '{ pkg::tmp::remove; lock::free monero_bash_update; } &' EXIT
	if ! lock::alloc "monero_bash_update"; then
		print::error "Could not get update lock!"
		print::exit  "Is there another [monero-bash] update running?"
	fi
	pkg::tmp::info update
	map VER HTML
	local UPDATE_FOUND
	declare -a SCRATCH
	print::update
	struct::pkg bash
	pkg::update::multi &
	if [[ $MONERO_VER ]]; then
		struct::pkg monero
		pkg::update::multi &
	fi
	if [[ $P2POOL_VER ]]; then
		struct::pkg p2pool
		pkg::update::multi &
	fi
	if [[ $XMRIG_VER ]]; then
		struct::pkg xmrig
		pkg::update::multi &
	fi
	log::debug "waiting for metadata threads to complete"
	if ! wait -n; then
		print::exit "Update failure - unable to connect to GitHub"
	fi
	struct::pkg bash
	pkg::update::result
	if [[ $MONERO_VER ]]; then
		struct::pkg monero
		pkg::update::ver
		pkg::update::result
	fi
	if [[ $P2POOL_VER ]]; then
		struct::pkg p2pool
		pkg::update::ver
		pkg::update::result
	fi
	if [[ $XMRIG_VER ]]; then
		struct::pkg xmrig
		pkg::update::ver
		pkg::update::result
	fi
	if [[ $UPDATE_FOUND ]]; then
		echo
		printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
			"Updates found, type: " \
			"[monero-bash upgrade] " \
			"to upgrade all packages"
	else
		print::updated
	fi
	log::debug "update() done"
	exit 0
}
pkg::update::multi() {
	log::debug "starting metadata thread for: ${PKG[pretty]}"
	if $DOWNLOAD_OUT "${TMP_INFO[${PKG[short]}]}" "${PKG[link_api]}"; then
		log::debug "downloaded ${PKG[link_api]} into ${TMP_INFO[${PKG[short]}]}"
	else
		HTML[${PKG[short]}]=true
		log::debug "GitHub API failure for ${PKG[pretty]} | Switching to HTML filter mode..."
		if $DOWNLOAD_OUT "${TMP_INFO[${PKG[short]}]}" "${PKG[link_html]}"; then
			log::debug "downloaded ${PKG[link_html]} into ${TMP_INFO[${PKG[short]}]}"
		else
			log::debug "Update failure for ${PKG[pretty]} - HTML mode failure"
			return 1
		fi
	fi
	return 0
}
pkg::update::ver() {
	if [[ ${HTML[${PKG[short]}} = true ]]; then
		SCRATCH=($(grep -o -m 1 "/${PKG[author]}/${PKG[name]}/releases/tag/.*\"" "${TMP_INFO[${PKG[short]}]}"))
		VER[${PKG[short]}]="${SCRATCH[0]}"
		VER[${PKG[short]}]="${VER[${PKG[short]}//*tag\/}"
		VER[${PKG[short]}]="${VER[${PKG[short]}//\"}"
	else
		VER[${PKG[short]}]="$(grep -m 1 "tag_name" "${TMP_INFO[${PKG[short]}]}")"
		VER[${PKG[short]}]="${VER[${PKG[short]}//*: }"
		VER[${PKG[short]}]="${VER[${PKG[short]}//\"}"
		VER[${PKG[short]}]="${VER[${PKG[short]}//,}"
	fi
}
pkg::update::result() {
	local UPDATE_NAME
	case "${PKG[short]}" in
		*bash*) UPDATE_NAME="monero-bash | ";;
		monero) UPDATE_NAME="Monero      | ";;
		*p2p*)  UPDATE_NAME="P2Pool      | ";;
		*xmr*)  UPDATE_NAME="XMRig       | ";;
	esac
	if [[ ${PKG[current_version]} = "${VER[${PKG[short]}]}" ]]; then
		printf "${BWHITE}%s${BGREEN}%s\n" \
			"$UPDATE_NAME" "${PKG[current_version]}"
	else
		sed -i "s/${PKG[var]}_OLD=.*/${PKG[var]}_OLD=true/" "$STATE"
		UPDATE_FOUND=true
		printf "${BWHITE}%s${BRED}%s${BWHITE}%s${BGREEN}%s\n" \
			"$UPDATE_NAME" "${PKG[current_version]} " "-> " "${VER[${PKG[short]}]}"
	fi
	return 0
}
pkg::upgrade() {
	log::debug "starting ${FUNCNAME}()"
	if [[ $UPGRADE_LIST ]]; then
		log::debug "packages getting upgraded: $UPGRADE_LIST"
	elif [[ $INSTALL_LIST ]]; then
		log::debug "packages getting installed: $UPGRADE_LIST"
	fi
	trap '{ pkg::trap::pkg_folders; lock::free monero_bash_upgrade; } &' EXIT
	if lock::alloc monero_bash_upgrade; then
		log::debug "created lock file: ${STD_LOCK_FILE[monero_bash_upgrade]}"
	else
		log::debug "lock file already found: ${STD_LOCK_FILE[monero_bash_upgrade]}"
		print::error "Could not get upgrade lock!"
		print::exit  "Is there another [monero-bash] upgrade running?"
	fi
	print::download
	log::prog "Fetching metadata... "
	pkg::info
	pkg::download
	print::verify
	pkg::verify
	print::pkg::hooks::pre
	pkg::hooks::pre
	if [[ $UPGRADE_LIST ]]; then
		print::upgrade
	elif [[ $INSTALL_LIST ]]; then
		print::install
	fi
	pkg::extract
	trap '{ pkg::copy &>/dev/null; pkg::hooks::post &>/dev/null; pkg::trap::pkg_folders; lock::free monero_bash_upgrade; } &' EXIT
	pkg::copy
	print::pkg::hooks::post
	pkg::hooks::post
	log::debug "freeing lock file: ${STD_LOCK_FILE[monero_bash_upgrade]}"
	lock::free monero_bash_upgrade
	if [[ $UPGRADE_LIST ]]; then
		print::upgrade
	elif [[ $INSTALL_LIST ]]; then
		print::install
	fi
	trap - EXIT
	log::debug "pkg::upgrade() done"
	exit 0
}
pkg::verify() {
	log::debug "starting ${FUNCNAME}()"
	if [[ $MONERO_BASH_OLD = true ]]; then
		struct::pkg bash
		pkg::verify::key
	fi
	if [[ $MONERO_OLD = true ]]; then
		struct::pkg monero
		pkg::verify::key
	fi
	if [[ $P2POOL_OLD = true ]]; then
		struct::pkg p2pool
		pkg::verify::key
	fi
	if [[ $XMRIG_OLD = true ]]; then
		struct::pkg xmrig
		pkg::verify::key
	fi
	map HASH
	if [[ $MONERO_BASH_OLD = true ]]; then
		struct::pkg bash
		pkg::verify::hash_calc &
	fi
	if [[ $MONERO_OLD = true ]]; then
		struct::pkg monero
		pkg::verify::hash_calc &
	fi
	if [[ $P2POOL_OLD = true ]]; then
		struct::pkg p2pool
		pkg::verify::hash_calc &
	fi
	if [[ $XMRIG_OLD = true ]]; then
		struct::pkg xmrig
		pkg::verify::hash_calc &
	fi
	if [[ $MONERO_BASH_OLD = true ]]; then
		struct::pkg bash
		pkg::verify::hash
		pkg::verify::pgp
	fi
	if [[ $MONERO_OLD = true ]]; then
		struct::pkg monero
		pkg::verify::hash
		pkg::verify::pgp
	fi
	if [[ $P2POOL_OLD = true ]]; then
		struct::pkg p2pool
		pkg::verify::hash
		pkg::verify::pgp
	fi
	if [[ $XMRIG_OLD = true ]]; then
		struct::pkg xmrig
		pkg::verify::hash
		pkg::verify::pgp
	fi
}
pkg::verify::key() {
	log::debug "starting ${FUNCNAME}() for: ${PKG[pretty]}"
	if gpg --list-keys "${PKG[fingerprint]}" &>/dev/null; then
		log::debug "PGP key found: ${PKG[gpg_owner]} - ${PKG[fingerprint]}"
	else
		log::debug "PGP key not found: ${PKG[gpg_owner]} - ${PKG[fingerprint]}"
		log::debug "Importing from: $PKG_MONERO_BASH/gpg/${PKG[gpg_owner]}.asc"
		gpg --quiet --import "$PKG_MONERO_BASH/gpg/${PKG[gpg_owner]}.asc"
	fi
}
pkg::verify::hash_calc() {
	log::debug "starting ${FUNCNAME}() for: ${PKG[pretty]}"
	HASH[${PKG[short]}]=$(sha256sum "${TMP_PKG[${PKG[short]}_tar]}")
}
pkg::verify::hash() {
	log::debug "starting ${FUNCNAME}() for: ${PKG[pretty]}"
	log::prog "${PKG[pretty]} HASH..."
	if grep -o "${HASH[${PKG[short]}]}" "${TMP_PKG[${PKG[short]}_hash]}" &>/dev/null; then
		log::debug "${PKG[pretty]} hash match found: ${TMP_PKG[${PKG[short]}_hash]}"
		local HASH_START HASH_END HASH_DIGIT
		HASH_DIGIT="${#TMP_PKG[${PKG[short]}_hash]}"
		HASH_START="${TMP_PKG[${PKG[short]}_hash]:0:6}"
		HASH_END="$((HASH_DIGIT-6))"
		HASH_END="${TMP_PKG[${PKG[short]}_hash]:${HASH_END}}"
		log::ok "${PKG[pretty]} HASH: ${HASH_START}...${HASH_END}"
	else
		print::compromised::hash
		exit 1
	fi
}
pkg::verify::pgp() {
	log::debug "starting ${FUNCNAME}() for: ${PKG[pretty]}"
	log::prog "${PKG[pretty]} PGP..."
	if [[ ${PKG[name]} = xmrig ]]; then
		TMP_PKG[${PKG[short]}_hash]="${TMP_PKG[${PKG[short]}_sig]}"
	fi
	if gpg --verify "${TMP_PKG[${PKG[short]}_hash]}" &> "${TMP_PKG[${PKG[short]}_gpg]}"; then
		log::debug "PGP success: $(cat ${TMP_PKG[${PKG[short]}_gpg]})"
		log::ok "${PKG[pretty]} PGP signed by: ${PKG[gpg_owner]}"
	else
		log::debug "PGP failure"
		print::compromised::pgp
		exit 1
	fi
}
print::changelog::title() {
	log::debug "starting ${FUNCNAME}()"
	local CHANGELOG_TITLE CHANGELOG_RELEASE_DATE || return 1
	CHANGELOG_VERSION="$1"
	CHANGELOG_RELEASE_DATE="$2"
	printf "${BCYAN}%s\n" \
		"#==============================#" \
		"# monero-bash $CHANGELOG_VERSION changelog #" \
		"#==============================#" \
		"# RELEASE DATE | $CHANGELOG_RELEASE_DATE" \
		""
}
print::changelog() {
	print::changelog::2.0.0
}
print::changelog::2.0.0() {
	print::changelog::title "v2.0.0"
}
print::changelog::1.6.0() {
	print::changelog::title "v1.6.0" "July 2, 2022"
	printf "${BCYAN}%s\n" \
		"# Updates"
	printf "  ${BOLD}${BWHITE}%s\n" \
		"v1 END OF LIFE"
	printf "    ${OFF}%s\n" \
		"- monero-bash v2.0.0 in progress, a rewrite to make the code safer, faster, and easier to debug" \
		"- Major version upgrades (v1.X.X > v2.X.X) will include changes that break backwards compatability" \
		"- v1.X.X versions will still function, but you will not be able to upgrade monero-bash past v1.9.9" \
		""
	printf "${BCYAN}%s\n" \
		"# Fixes"
	printf "  ${BOLD}${BWHITE}%s\n    ${OFF}%s\n" \
		"systemd" "- Service file permission fix (700 > 600)" \
		"P2Pool"  "- Fetch PGP key from GitHub" \
		"Misc"    "- Fix text coloring issues"
}
print::compromised::hash() {
	log::debug "package hash error has occurred for: ${PKG[name]}"
	printf "${BWHITE}%s\n${BRED}%s\n${BRED}%s\n${BRED}%s\n${BRED}%s\n${BWHITE}%s\n" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		" WARNING: HASH ERROR!                       " \
		" [${PKG[pretty]}] hash did not match!       " \
		" [${PKG[author]}] might be compromised!     " \
		" (or more likely, there was an error)       " \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	printf "${BWHITE}%s${BRED}%s${OFF}\n" \
		"INVALID HASH: " \
		"${HASH[${PKG[short]}]}"
	exit 1
}
print::compromised::pgp() {
	log::debug "package pgp error has occurred for: ${PKG[name]}"
	printf "${BWHITE}%s\n${BBLUE}%s\n${BBLUE}%s\n${BBLUE}%s\n${BBLUE}%s\n${BWHITE}%s\n" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		" WARNING: PGP ERROR!                       " \
		" [${PKG[pretty]}] PGP signature failed!     " \
		" [${PKG[gpg_owner]}] might be compromised!  " \
		" (or more likely, there was an error)       " \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	printf "${BWHITE}%s${BRED}%s\n${BWHITE}%s\n${OFF}%s\n" \
		"TAR FILE HASH: " \
		"${HASH[${PKG[short]}]}" \
		"BAD SIGNATURE: " \
		"$(cat ${TMP_PKG[${PKG[short]}_gpg]})"
	exit 1
}
print::error() {
	until [[ $# = 0 ]]; do
		printf "${BRED}%s${OFF}%s\n" "[monero-bash error] " "$1"
		shift
	done
}
print::exit() {
	until [[ $# = 0 ]]; do
		printf "${BRED}%s${OFF}%s\n" "[monero-bash error] " "$1"
		shift
	done
	exit 1
}
print::help() {
	log::debug "starting ${FUNCNAME}()"
	printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s${BPURPLE}%s\n\n" \
		"USAGE: " "monero-bash " "[command] " "<argument> " "[--option]"
	printf "${BWHITE}%s${OFF}\n" "WALLET"
	printf "    ${OFF}%s\n" \
		"monero-bash                                Open interactive wallet menu" \
		"list                                       List wallets"
	printf "    ${OFF}%s${BYELLOW}%s${OFF}%s\n" \
		"new     " "<wallet type>                      " "Enter wallet creation mode"
	printf "\n${BWHITE}%s${OFF}\n" "PACKAGE"
	printf "    ${OFF}%s${BYELLOW}%s${BPURPLE}%s${OFF}%s\n" \
		"install " "<packages> " "[--verbose]             " "Install one/multiple packages" \
		"remove  " "<packages> " "[--verbose]             " "Remove one/multiple packages"
	printf "    ${OFF}%s${BPURPLE}%s${OFF}%s\n" \
		"update  " "[--verbose]                        " "Check for package updates" \
		"upgrade " "[--verbose] [--force]              " "Upgrade all out-of-date packages"
	printf "\n${BWHITE}%s${OFF}\n" "PROCESS"
	printf "    ${OFF}%s${BYELLOW}%s${OFF}%s\n" \
		"full    " "<process>                          " "Start <process> fully attached in foreground" \
		"config  " "<processes>                        " "Enter interactive configuration for <process>"
	printf "    ${OFF}%s${BYELLOW}%s${BPURPLE}%s${OFF}%s\n" \
		"default " "<processes> " "[--config] [--systemd] " "Reset your config/systemd file to the default"
	printf "\n${BWHITE}%s${OFF}\n" "SYSTEMD"
	printf "    ${OFF}%s${BYELLOW}%s${OFF}%s\n" \
		"start   " "<processes>                        " "Start process as systemd background process" \
		"stop    " "<processes>                        " "Gracefully stop systemd background process" \
		"kill    " "<processes>                        " "Forcefully kill systemd background process" \
		"restart " "<processes>                        " "Restart systemd background process" \
		"enable  " "<processes>                        " "Enable <process> to auto-start on computer boot" \
		"disable " "<processes>                        " "Disable <process> from auto-starting on computer boot" \
		"edit    " "<processes>                        " "Edit systemd service file" \
		"refresh " "<processes>                        " "Refresh your systemd service file to match your config" \
		"watch   " "<processes>                        " "Watch live output of systemd background process"
	printf "\n${BWHITE}%s${OFF}\n"    "STATS"
	printf "    %s\n" \
		"status                                     Print status of all running processes" \
		"size                                       Print size of all packages and folders" \
		"version                                    Print current package versions"
	printf "\n${BWHITE}%s${OFF}\n"    "OTHER"
	printf "    ${OFF}%s${BYELLOW}%s${OFF}%s\n" \
		"rpc     " "<JSON-RPC method>                  " "Send a JSON-RPC call to monerod" \
		"changes " "<monero-bash version>              " "Print current/specified monero-bash changelog" \
		"help    " "<command>                          " "Print help for a command, or all if none specified"
}
print::help::command() {
	until [[ $# = 0 ]]; do
	log::debug "starting ${FUNCNAME}() for: $1"
	case "$1" in
		monero-bash)
			printf "${BWHITE}%s${BRED}%s\n\n" "USAGE: " "monero-bash"
			printf "${OFF}%s\n" \
			"Open the interactive wallet menu." \
			"" \
			"Looks for wallets inside the wallet folder:" \
			"[\$HOME/.monero-bash/wallets]" \
			"Ignores [.keys] files, only looking for wallet files." \
			"" \
			"Allows selection of existing wallets and interactive" \
			"creation of a new wallet with these types: " \
			"" \
			"--generate-new-wallet         | [new]" \
			"--generate-from-view-key      | [view]" \
			"--restore-from-seed           | [seed]" \
			"--generate-from-json          | [json]" \
			"--generate-from-spend-key     | [spend]" \
			"--generate-from-device        | [device]" \
			"--generate-from-keys          | [private]" \
			"--generate-from-multisig-keys | [multisig]" \
			"" \
			"Each time the [monero-bash] title is printed, it rolls" \
			"some RNG to print varying levels of title rarity:" \
			"" \
			"RED    # | common    | 60%" \
			"BLUE   x | rare      | 30%" \
			"PURPLE : | ultra     | 9%" \
			"GOLDEN / | legendary | 0.99%" \
			"GREEN  # | lottery   | 0.0030519%"
			;;
		list)
			printf "${BWHITE}%s${BRED}%s${OFF}%s\n\n" "USAGE: " "monero-bash " "list"
			printf "${OFF}%s\n" \
			"Print the full list and amount of wallets." \
			"" \
			"Looks for wallets inside of the wallet folder:" \
			"[\$HOME/.monero-bash/wallets]" \
			"Ignores [.keys] files, only looking for wallet files." \
			"" \
			"Each time the [monero-bash] title is printed, it rolls" \
			"some RNG to print varying levels of title rarity:" \
			"" \
			"RED    # | common    | 60%" \
			"BLUE   x | rare      | 30%" \
			"PURPLE : | ultra     | 9%" \
			"GOLDEN / | legendary | 0.99%" \
			"GREEN  # | lottery   | 0.0030519%"
			;;
		new)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "new " "<wallet type>"
			printf "${OFF}%s\n" \
			"Create a new wallet." \
			"" \
			"If a wallet type is given, wallet creation is started" \
			"with that type, if no wallet type is given, interactive" \
			"wallet creation mode is started. Creates wallets inside" \
			"of the wallet folder: [\$HOME/.monero-bash/wallets]" \
			"Allows creation of a wallet with these types:" \
			"" \
			"--generate-new-wallet         | [new]" \
			"--generate-from-view-key      | [view]" \
			"--restore-from-seed           | [seed]" \
			"--generate-from-json          | [json]" \
			"--generate-from-spend-key     | [spend]" \
			"--generate-from-device        | [device]" \
			"--generate-from-keys          | [private]" \
			"--generate-from-multisig-keys | [multisig]"
			;;
		install)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "install " "<packages> " "[--verbose]"
			printf "${OFF}%s\n" \
			"Start the installation process of packages." \
			"" \
			"Packages are installed in their respective folders in:" \
			"[\$HOME/.monero-bash/packages/<PACKAGE_NAME>]" \
			"and [systemd] service files are created, if not already" \
			"found in: [/etc/systemd/system]" \
			"" \
			"Packages are verified by hash and PGP signature before" \
			"installation. PGP keys are automatically verified, then" \
			"imported if not already found. If verification fails, the" \
			"package will not be installed. The rest of the packages" \
			"will continue to be installed." \
			"" \
			"A single package or multiple packages can be installed at the same time." \
			"" \
			"--- PACKAGE LIST ---" \
			"[monero]" \
			"[p2pool]" \
			"[xmrig]" \
			"" \
			"If the [--verbose] option is given, detailed" \
			"debug information will be printed during the install."
			;;
		remove)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "remove " "<packages> " "[--verbose]"
			printf "${OFF}%s\n" \
			"Start the removal process of packages." \
			"" \
			"Packages folders are deleted: [\$HOME/.monero-bash/packages/<PACKAGE_NAME>]" \
			"and systemd service files are removed: [/etc/systemd/system/<PACKAGE_NAME>.service]" \
			"Configuration files are left alone: [\$HOME/.monero-bash/config/<PACKAGE_CONFIG>]" \
			"A single package or multiple packages can be removed at the same time." \
			"" \
			"--- PACKAGE LIST ---" \
			"[monero]" \
			"[p2pool]" \
			"[xmrig]" \
			"" \
			"If the [--verbose] option is given, detailed" \
			"debug information will be printed during the removal."
			;;
		update)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "update " "[--verbose]"
			printf "${OFF}%s\n" \
			"Check for new versions of installed packages." \
			"" \
			"If a new version is found, the new update will" \
			"be printed along with the old version:" \
			"<PACKAGE_NAME> | [OLD_VERSION] -> [NEW_VERSION]" \
			"The package version from that point will be" \
			"printed in [RED] instead of [GREEN] until it" \
			"is upgraded with [monero-bash upgrade]." \
			"" \
			"If the [--verbose] option is given, detailed" \
			"debug information will be printed during the update."
			;;
		upgrade)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "upgrade " "[--verbose]"
			printf "${OFF}%s\n" \
			"Upgrade all installed packages that are out-of-date." \
			"" \
			"Packages folders are upgraded:" \
			"[\$HOME/.monero-bash/packages/<PACKAGE_NAME>]" \
			"" \
			"Packages are verified by hash and PGP signature before" \
			"upgrade. PGP keys are automatically verified, then" \
			"imported if not already found. If verification fails, the" \
			"package will not be upgraded. The rest of the packages" \
			"will continue to be upgraded." \
			"" \
			"--- PACKAGE LIST ---" \
			"[monero]" \
			"[p2pool]" \
			"[xmrig]" \
			"" \
			"If the [--verbose] option is given, detailed" \
			"debug information will be printed during the upgrade."
			;;
		full)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "full " "<process>"
			printf "${OFF}%s\n" \
			"Start a process attached to the current terminal." \
			"" \
			"The process will be started in the foreground in the" \
			"current terminal with configuration sourced from the" \
			"process's configuration file found in:" \
			"[\$HOME/.monero-bash/config/<PROCESS_CONFIG>]" \
			"" \
			"The process will be ran as the [monero-bash] user for" \
			"security reasons. It has a [nologin] shell. The exeception" \
			"is [XMRig] which runs as [root] for hugepage allocation." \
			"This can be disabled by editing the XMRIG_ROOT option in:" \
			"[\$HOME/.monero-bash/config/monero-bash.conf]"\
			"" \
			"#---------------------------------------------------------------#" \
			"# PROCESS | USER        | CONFIG FILE                           #" \
			"#---------------------------------------------------------------#" \
			"# Monero  | monero-bash | monerod.conf & monero-wallet-cli.conf #" \
			"# P2Pool  | monero-bash | p2pool.conf (& optional p2pool.json)  #" \
			"# XMRig   | root        | xmrig.json                            #" \
			"#---------------------------------------------------------------#"
			;;
		config)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "config " "<processes>"
			printf "${OFF}%s\n" \
			"Start interactive configuration for processes." \
			"" \
			"This will edit the configuration files found in:" \
			"[\$HOME/.monero-bash/config/<PROCESS_CONFIG>]" \
			"" \
			"#-----------------------------------------------------#" \
			"# PROCESS     | CONFIG FILE                           #" \
			"#-----------------------------------------------------#" \
			"# monero-bash | monero-bash.conf                      #" \
			"# Monero      | monerod.conf & monero-wallet-cli.conf #" \
			"# P2Pool      | p2pool.conf                           #" \
			"# XMRig       | xmrig.json                            #" \
			"#-----------------------------------------------------#" \
			"" \
			"After configuration, a prompt will ask you if you'd like to" \
			"refresh your [systemd] service to match the configuration." \
			"This can also manually be done with: [monero-bash refresh <processes>]"
			;;
		default)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "default " "<processes> " "[--config] [--systemd]"
			printf "${OFF}%s\n" \
			"Reset config files/systemd services to the default." \
			"" \
			"This will reset the configuration files of <process>" \
			"found in: [\$HOME/.monero-bash/config/<PROCESS_CONFIG>]" \
			"and the [systemd] service files found in: [/etc/systemd/system]" \
			"to a generic default version." \
			"" \
			"#-----------------------------------------------------------------------------------#" \
			"# PROCESS     | CONFIG FILE                           | SYSTEMD SERVICE FILE        #" \
			"#-----------------------------------------------------------------------------------#" \
			"# monero-bash | monero-bash.conf                      |                             #" \
			"# Monero      | monerod.conf & monero-wallet-cli.conf | monero-bash-monerod.service #" \
			"# P2Pool      | p2pool.conf                           | monero-bash-p2pool.service  #" \
			"# XMRig       | xmrig.json                            | monero-bash-xmrig.service   #" \
			"#-----------------------------------------------------------------------------------#" \
			"" \
			"If no options are supplied, both the config file and systemd file are reset."
			;;
		start)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "start " "<processes>"
			printf "${OFF}%s\n" \
			"Start a process in the background with systemd" \
			"" \
			"The process will be started in the background with a" \
			"[systemd] service file found in: [/etc/systemd/system]" \
			"" \
			"The process will be ran as the [monero-bash] user for" \
			"security reasons. It has a [nologin] shell. The exeception" \
			"is [XMRig] which runs as [root] for hugepage allocation." \
			"This can be disabled by editing the XMRIG_ROOT option in:" \
			"[\$HOME/.monero-bash/config/monero-bash.conf]"\
			"and then refreshing the [systemd] service with:" \
			"[monero-bash refresh xmrig]" \
			"" \
			"#-----------------------------------------------------#" \
			"# PROCESS | USER        | SYSTEMD SERVICE FILE        #" \
			"#-----------------------------------------------------#" \
			"# Monero  | monero-bash | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash | monero-bash-p2pool.service  #" \
			"# XMRig   | root        | monero-bash-xmrig.service   #" \
			"#-----------------------------------------------------#"
			;;
		stop)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "stop " "<processes>"
			printf "${OFF}%s\n" \
			"Gracefully stop a background process with systemd" \
			"" \
			"[systemd] service files are found in: [/etc/systemd/system]" \
			"" \
			"#---------------------------------------#" \
			"# PROCESS | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------#" \
			"# Monero  | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash-p2pool.service  #" \
			"# XMRig   | monero-bash-xmrig.service   #" \
			"#---------------------------------------#"
			;;
		kill)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "kill " "<processes>"
			printf "${OFF}%s\n" \
			"Forcefully kill a background process with systemd" \
			"" \
			"[systemd] service files are found in: [/etc/systemd/system]" \
			"" \
			"#---------------------------------------#" \
			"# PROCESS | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------#" \
			"# Monero  | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash-p2pool.service  #" \
			"# XMRig   | monero-bash-xmrig.service   #" \
			"#---------------------------------------#"
			;;
		restart)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "restart " "<processes>"
			printf "${OFF}%s\n" \
			"Gracefully restart a background process with systemd" \
			"" \
			"[systemd] service files are found in: [/etc/systemd/system]" \
			"" \
			"#---------------------------------------#" \
			"# PROCESS | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------#" \
			"# Monero  | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash-p2pool.service  #" \
			"# XMRig   | monero-bash-xmrig.service   #" \
			"#---------------------------------------#"
			;;
		enable)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "enable " "<processes>"
			printf "${OFF}%s\n" \
			"Enable a background process to auto-start" \
			"on computer boot with systemd" \
			"" \
			"[systemd] service files are found in: [/etc/systemd/system]" \
			"" \
			"#---------------------------------------#" \
			"# PROCESS | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------#" \
			"# Monero  | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash-p2pool.service  #" \
			"# XMRig   | monero-bash-xmrig.service   #" \
			"#---------------------------------------#"
			;;
		disable)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "disable " "<processes>"
			printf "${OFF}%s\n" \
			"Disable background process from auto-start" \
			"on computer boot with systemd" \
			"" \
			"[systemd] service files are found in: [/etc/systemd/system]" \
			"" \
			"#---------------------------------------#" \
			"# PROCESS | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------#" \
			"# Monero  | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash-p2pool.service  #" \
			"# XMRig   | monero-bash-xmrig.service   #" \
			"#---------------------------------------#"
			;;
		edit)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "edit " "<processes>"
			printf "${OFF}%s\n" \
			"Edit a process's systemd service file." \
			"" \
			"After editing, systemd is reloaded automatically." \
			"[systemd] service files are found in: [/etc/systemd/system]" \
			"" \
			"#---------------------------------------#" \
			"# PROCESS | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------#" \
			"# Monero  | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash-p2pool.service  #" \
			"# XMRig   | monero-bash-xmrig.service   #" \
			"#---------------------------------------#"
			;;
		refresh)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "refresh " "<processes> "
			printf "${OFF}%s\n" \
			"Refresh [systemd] to match configuration files." \
			"" \
			"This will reset the [systemd] service of <process>" \
			"to match the configuration options found in:" \
			"[\$HOME/.monero-bash/config/<PROCESS_CONFIG>]" \
			"" \
			"By default, packages will come with a generic [systemd] service file." \
			"" \
			"#---------------------------------------------------------------------------#" \
			"# PROCESS     | CONFIG FILE TO MATCH          | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------------------------------------------#" \
			"# Monero      | monerod.conf                  | monero-bash-monerod.service #" \
			"# P2Pool      | p2pool.conf                   | monero-bash-p2pool.service  #" \
			"# XMRig       | monero-bash.conf + xmrig.json | monero-bash-xmrig.service   #" \
			"#---------------------------------------------------------------------------#" \
			"" \
			"If no options are supplied, both the config file and systemd file are reset."
			;;
		watch)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "watch " "<processes>"
			printf "${OFF}%s\n" \
			"Watch live output of a background systemd process" \
			"" \
			"The terminal will switch to output of <processes>" \
			"To exit and return: <CTRL+C>" \
			"If multiple procceses are selected, they are queued." \
			"" \
			"--- PROCESSES ---" \
			"[monero]" \
			"[p2pool]" \
			"[xmrig]"
			;;
		status)
			printf "${BWHITE}%s${BRED}%s${OFF}%s\n\n" "USAGE: " "monero-bash " "status"
			printf "${OFF}%s\n" \
			"Print status of all running processes." \
			"" \
			"#---------------------------------------------------------------------------#" \
			"# PROCESS     | INFORMATION PRINTED                                         #" \
			"#---------------------------------------------------------------------------#" \
			"# Monero      | Blockchain stats + /.bitmonero/ size                        #" \
			"# P2Pool      | Wallet + Latest share + Latest payout + Shares per hour/day #" \
			"# XMRig       | Wallet + Hashrate + Shares + Pool                           #" \
			"#---------------------------------------------------------------------------#"
			;;
		size)
			printf "${BWHITE}%s${BRED}%s${OFF}%s\n\n" "USAGE: " "monero-bash " "size"
			printf "${OFF}%s\n" "Print size of installed packages and blockchain folder."
			;;
		version)
			printf "${BWHITE}%s${BRED}%s${OFF}%s\n\n" "USAGE: " "monero-bash " "version"
			printf "${OFF}%s\n" \
			"Print version of installed packages." \
			"" \
			"Versions will be printed in [BOLD RED] if they" \
			"are out-of-date. Otherwise they will be printed" \
			"in [BOLD GREEN]."
			;;
		rpc)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BBLUE}%s${BYELLOW}%s${BGREEN}%s\n\n" "USAGE: " "monero-bash " "rpc " "[host:port] " "<JSON-RPC method> " "[name:value]"
			printf "${OFF}%s\n" \
			"Send a JSON-RPC call to monerod." \
			"" \
			"This will send a JSON-RPC call to the monerod IP" \
			"specified in [\$HOME/.monero-bash/config/monero-bash.conf]" \
			"Setting RPC_VERBOSE to true will make [monero-bash] print" \
			"the payload before sending." \
			"" \
			"The default IP is your own monerod: [127.0.0.1:18081]" \
			"But any monerod IP is able to be used: [node.community.rino.io:18081]" \
			"" \
			"The code for this function is originally from: https://github.com/jtgrassie/xmrpc" \
			"Copyright (c) 2014-2022, The Monero Project"
			printf "\n${BWHITE}%s${OFF}\n" "EXAMPLE"
			printf "    ${BRED}%s${OFF}%s${BYELLOW}%s\n" "monero-bash " "rpc " "get_block"
			printf "    ${BRED}%s${OFF}%s${BBLUE}%s${BYELLOW}%s\n" "monero-bash " "rpc " "node.community.rino.io:18081 " "get_block"
			printf "    ${BRED}%s${OFF}%s${BBLUE}%s${BYELLOW}%s${BGREEN}%s\n" \
			"monero-bash " "rpc " "127.0.0.1:18081 " "get_block " "height:123456" \
			"monero-bash " "rpc " "localhost:18081 " "get_block " "hash:418015bb9ae982a1975da7d79277c2705727a56894ba0fb246adaabb1f4632e3"
			printf "\n${BWHITE}%s${OFF}\n" "JSON RPC Methods"
			printf "    ${OFF}%s\n" \
			"get_block_count" \
			"on_get_block_hash" \
			"get_block_template" \
			"submit_block" \
			"get_last_block_header" \
			"get_block_header_by_hash" \
			"get_block_header_by_height" \
			"get_block_headers_range" \
			"get_block" \
			"get_connections" \
			"get_info" \
			"hard_fork_info" \
			"set_bans" \
			"get_bans" \
			"get_output_histogram" \
			"get_version" \
			"get_coinbase_tx_sum" \
			"get_fee_estimate" \
			"get_alternate_chains" \
			"relay_tx" \
			"sync_info" \
			"get_txpool_backlog" \
			"get_output_distribution"
			;;
		changes)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "changes " "<monero-bash version>"
			printf "${OFF}%s\n" \
			"Print the changelog of [monero-bash]." \
			"" \
			"If no version is given, the current version's" \
			"changelog will be printed."
			;;
		help)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "help " "<command>"
			printf "${OFF}%s\n" \
			"Print help for [monero-bash] commands." \
			"" \
			"If no command is given, the general help" \
			"menu will be printed for all commands."
			;;
		*) print::error "Invalid option: $1 command does not exist";;
	esac
	shift
	done
	exit
}
print::download() {
	printf "${BCYAN}%s${OFF}\n" "#------------------# Downloading"
}
print::update() {
	printf "${BBLUE}%s${OFF}\n" "#------------------# Updating"
}
print::remove() {
	printf "${BRED}%s${OFF}\n" "#------------------# Removing [${PKG[pretty]}]"
}
print::verify() {
	printf "${BYELLOW}%s${OFF}\n" "#------# Verifying"
}
print::install() {
	printf "${BRED}%s${OFF}\n" "#------# Installing"
}
print::upgrade() {
	printf "${BRED}%s${OFF}\n" "#------# Upgrading"
}
print::hook::pre() {
	printf "${BPURPLE}%s${OFF}\n" "#------# Hooks::Pre"
}
print::hook::post() {
	printf "${BPURPLE}%s${OFF}\n" "#------# Hooks::Post"
}
print::installed() {
	printf "${BGREEN}%s${OFF}\n" "#------------------# Install done"
}
print::upgraded() {
	printf "${BGREEN}%s${OFF}\n" "#------------------# Upgrade done"
}
print::removed() {
	printf "${BRED}%s${OFF}\n" "#------------------# Removed [${PKG[pretty]}]"
}
print::updated() {
	printf "${BCYAN}%s${OFF}\n" "#------------------# All packages up-to-date"
}
print::size() {
	log::debug "starting ${FUNCNAME}()"
	log::debug "getting folder sizes"
	local SIZE_MONERO_BASH SIZE_MONERO SIZE_P2POOL SIZE_XMRIG SIZE_BITMONERO SIZE_DOT || return 1
	SIZE_MONERO_BASH=$(du -h "$PKG_MONERO_BASH")
	SIZE_MONERO=$(du -h "$PKG_MONERO")
	SIZE_P2POOL=$(du -h "$PKG_P2POOL")
	SIZE_XMRIG=$(du -h "$PKG_XMRIG")
	SIZE_DOT=$(du -h "$DOT")
	if [[ -d "$HOME/.bitmonero" ]]; then
		SIZE_BITMONERO=$(du -h "$HOME/.bitmonero")
	else
		SIZE_BITMONERO="not found"
	fi
	log::debug "printing folder sizes"
	printf "${BWHITE}%s${BYELLOW}%s\n" \
		"monero-bash    | " "${SIZE_MONERO_BASH/$'\t'*}" \
		"Monero         | " "${SIZE_MONERO/$'\t'*}" \
		"P2Pool         | " "${SIZE_P2POOL/$'\t'*}" \
		"XMRig          | " "${SIZE_XMRIG/$'\t'*}" \
		"/.bitmonero/   | " "${SIZE_BITMONERO/$'\t'*}" \
		"/.monero-bash/ | " "${SIZE_DOT/$'\t'*}"
	return 0
}
print::title() {
	log::debug "starting ${FUNCNAME}()"
	log::debug "seeding title rng"
	local TITLE_RANDOM
	TITLE_RANDOM=$RANDOM
	if [[ $TITLE_RANDOM -le 19660 ]]; then
			printf "${BRED}%s${OFF}\n" \
				"###################" \
				"#   monero-bash   #" \
				"###################"
		log::debug "title luck: common 60%"
	elif [[ $TITLE_RANDOM -le 29490 ]]; then
			printf "${BBLUE}%s${OFF}\n" \
				"xxxxxxxxxxxxxxxxxxx" \
				"x   monero-bash   x" \
				"xxxxxxxxxxxxxxxxxxx"
		log::debug "title luck: rare 30%"
	elif [[ $TITLE_RANDOM -le 32439 ]]; then
			printf "${BPURPLE}%s${OFF}\n" \
				":::::::::::::::::::" \
				":   monero-bash   :" \
				":::::::::::::::::::"
		log::debug "title luck: ultra 9%"
	elif [[ $TITLE_RANDOM -le 32766 ]]; then
			printf "${BYELLOW}%s${OFF}\n" \
				"///////////////////" \
				"/   monero-bash   /" \
				"///////////////////"
		log::debug "title luck: legendary 0.99%"
	else
		printf "${BGREEN}%s${OFF}\n" \
			"###################" \
			"#   monero-bash   #" \
			"###################"
		log::debug "title luck: lottery 0.0030519%"
	fi
}
print::version() {
	log::debug "starting ${FUNCNAME}()"
	printf "${BWHITE}%s" \
		"monero-bash | "
	if [[ $MONERO_BASH_OLD = true ]]; then
		printf "${BRED}%s\n" "$MONERO_BASH_VER"
	else
		printf "${BGREEN}%s\n" "$MONERO_BASH_VER"
	fi
	printf "${BWHITE}%s" \
		"Monero      | "
	if [[ $MONERO_OLD = true ]]; then
		printf "${BRED}%s\n" "$MONERO_VER"
	else
		printf "${BGREEN}%s\n" "$MONERO_VER"
	fi
	printf "${BWHITE}%s" \
		"P2Pool      | "
	if [[ $P2POOL_OLD = true ]]; then
		printf "${BRED}%s\n" "$P2POOL_VER"
	else
		printf "${BGREEN}%s\n" "$P2POOL_VER"
	fi
	printf "${BWHITE}%s" \
		"XMRig       | "
	if [[ $XMRIG_OLD = true ]]; then
		printf "${BRED}%s\n" "$XMRIG_VER"
	else
		printf "${BGREEN}%s\n" "$XMRIG_VER"
	fi
	printf "${OFF}%s"
}
process::reset_files() {
	log::debug "starting ${FUNCNAME}()"
	if [[ -z ${PKG[version]} ]]; then
		print::exit "${PKG[pretty]} is not installed"
	fi
	case "${PKG[name]}" in
		*bash*)
			printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
				"This will overwrite your current " \
				"[${PKG[pretty]}] " \
				"config with a new default version"
			;;
		*)
			printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
				"This will overwrite your current " \
				"[${PKG[pretty]}] " \
				"config & systemd service files with new default versions"
			;;
	esac
	printf "${BWHITE}%s${OFF}" "Continue? (y/N) "
	if ask::no; then
		print::exit "Canceling reset"
	fi
	if ! ask::sudo; then
		print::exit "sudo is required"
	fi
	case "${PKG[name]}" in
		*bash*)
			cp -f "$PKG_MONERO_BASH/config/monero-bash.conf" "$CONFIG"
			;;
		monero)
			cp -f "$PKG_MONERO_BASH/config/monerod.conf" "$CONFIG"
			cp -f "$PKG_MONERO_BASH/config/monero-wallet-cli.conf" "$CONFIG"
			systemd::create
			systemd::reload
			;;
		p2pool)
			cp -f "$PKG_MONERO_BASH/config/p2pool.conf" "$CONFIG"
			systemd::create
			systemd::reload
			;;
		xmrig)
			cp -f "$PKG_MONERO_BASH/config/xmrig.json" "$CONFIG"
			systemd::create
			systemd::reload
			;;
	esac
	return 0
}
REAL="$(realpath $0)"
RELATIVE="$(dirname "$REAL")"
BINARY="/usr/local/bin/monero-bash"
SYMLINK="/usr/local/bin/mb"
readonly REAL RELATIVE
readonly DOT="$HOME/.monero-bash"
readonly CONFIG="$DOT/config"
readonly WALLETS="$DOT/wallets"
readonly PACKAGES="$DOT/packages"
readonly CONFIG_MONERO_BASH="$CONFIG/monero-bash.conf"
readonly CONFIG_MONEROD="$CONFIG/monerod.conf"
readonly CONFIG_WALLET="$CONFIG/monero-wallet-cli.conf"
readonly CONFIG_P2POOL="$CONFIG/p2pool.conf"
readonly CONFIG_XMRIG="$CONFIG/xmrig.json"
readonly PKG_MONERO_BASH="$PACKAGES/monero-bash"
readonly PKG_MONERO="$PACKAGES/monero"
readonly PKG_P2POOL="$PACKAGES/p2pool"
readonly PKG_XMRIG="$PACKAGES/xmrig"
readonly SRC="$PKG_MONERO_BASH/src"
readonly TXT="$PKG_MONERO_BASH/txt"
readonly HASHLIST="$TXT/hashlist"
readonly STATE="$TXT/state"
readonly MAIN="$PKG_MONERO_BASH/monero-bash"
readonly SRC_CONFIG="$PKG_MONERO_BASH/config"
readonly SYSTEMD="/etc/systemd/system"
rpc() {
	log::debug "starting ${FUNCNAME}()"
	if [[ "$1" == *:* ]]; then
	    RPC_IP="$1/json_rpc"
		shift
	elif [[ "$1" != *:* && -z "$RPC_IP" ]]; then
	    RPC_IP="http://localhost:18081/json_rpc"
	elif [[ "$1" != *:* && "$RPC_IP" ]]; then
		RPC_IP="${RPC_IP}/json_rpc"
	fi
	method="$1" ; shift
	payload="{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"$method\""
	if [ -n "$1" ]; then
	    if [[ "${1::1}" == "[" ]]; then
	        payload="$payload,\"params\":$(rpc::parse_arr $1)"
	    else
	        payload="$payload,\"params\":{"
	        while [ -n "$1" ]; do
	            payload="${payload}$(rpc::parse_nv $1)"
	            [ -n "$2" ] && payload="$payload,"
	            shift
	        done
	        payload="$payload}"
	    fi
	fi
	payload="$payload}"
	if [[ $CURL = true ]]; then
		curl -sd "$payload" "$RPC_IP"
	else
		wget \
		-qO- \
		"$RPC_IP" \
		--header='Content-Type:application/json' \
		--post-data="$payload"
	fi
	echo
	log::debug "--- RPC INFO ---"
	log::debug "RPC_IP  | $RPC_IP"
	log::debug "PAYLOAD | $payload"
	exit
}
rpc::quote() {
    [[ "$1" =~ ^[0-9]+$ ]] && echo -n "$1" && return
    [[ "$1" =~ ^true|false$ ]] && echo -n "$1" && return
    [[ "${1::1}" == "[" ]] && echo -n "$(rpc::parse_arr $1)" && return
    echo -n "\"$1\""
}
rpc::parse_arr() {
    let e=${#1}-2
    sz=${1:1:$e}
    a=(${sz//,/ })
    for i in "${!a[@]}"; do
        a[$i]=$(rpc::quote ${a[i]})
    done
    aj=$(printf ",%s" "${a[@]}")
    aj=${aj:1}
    echo -n "[${aj}]"
}
rpc::parse_nv() {
    nv=(${1//:/ })
    c=${#nv[@]}
    [[ $c == 2 ]] && echo -n "$(rpc::quote ${nv[0]}):$(rpc::quote ${nv[1]})"
}
safety::path() {
	log::debug "starting ${FUNCNAME}()"
	if [[ $REAL = "$MAIN" ]]; then
		log::debug "PATH OK: $MAIN"
		return 0
	else
		log::debug "PATH is not in: $MAIN"
		log::debug "REAL: $REAL"
		if [[ $REAL = */monero-bash/monero-bash ]]; then
			log::debug "PATH detected to be in [monero-bash] folder, checking FIRST_TIME"
			if [[ $FIRST_TIME = true ]]; then
				log::debug "FIRST_TIME = true | OK, continuing to install"
				return 0
			else
				print::error "FIRST_TIME = $FIRST_TIME | something is very wrong"
				print::error "monero-bash is in the [monero-bash] folder, yet FIRST_TIME is not true"
				print::error "The state file might be corrupted"
				print::exit  "Exiting for safety..."
			fi
		fi
	fi
	log::debug   "incorrect path detected: $REAL"
	print::error "[monero-bash] is in an unknown PATH"
	print::exit  "Exiting for safety..."
}
safety::pipe() {
	log::debug "starting ${FUNCNAME}()"
	if [[ -p /dev/stdin ]]; then
		print::error "Pipe detected. [monero-bash] does not support pipes!"
		print::exit  "Exiting for safety..."
	fi
	log::debug "no pipe detected"
}
safety::pkg() {
	log::debug "starting ${FUNCNAME}()"
	[[ $1 ]] || return 1
	struct::pkg "$1" || return 2
	if [[ ${PKG[current_version]} ]]; then
		log::debug "${PKG[pretty]} (${PKG[current_version]}) is installed"
	else
		print::exit "${PKG[pretty]} is not installed"
	fi
	case "${PKG[name]}" in
		*bash*)   [[ -e $PKG_MONERO_BASH/monero-bash ]] || print::exit "monero-bash not found, this error should be impossible!";;
		*monero*)
			[[ -e $PKG_MONERO/monerod ]]                || print::exit "monerod binary was not found!"
			[[ -e $PKG_MONERO/monero-wallet-cli ]]      || print::exit "monero-wallet-cli binary was not found!"
			;;
		*p2p*)    [[ -e $PKG_P2POOL/p2pool ]]           || print::exit "P2Pool binary was not found!";;
		*xmr*)    [[ -e $PKG_XMRIG/xmrig ]]             || print::exit "XMRig binary was not found!";;
	esac
	return 0
}
safety::root() {
	log::debug "starting ${FUNCNAME}()"
	log::debug "running as: $EUID"
	if [[ $EUID = 0 ]]; then
		print::error "Running as root is not recommended"
		print::exit  "Exiting for safety..."
	fi
}
safety::wget_curl() {
	log::debug "starting ${FUNCNAME}()"
	char DOWNLOAD_CMD WGET CURL
	if hash wget &>/dev/null; then
		WGET=true
		DOWNLOAD_CMD="wget --quiet --show-progress --content-disposition -P"
		DOWNLOAD_DIR="wget --quiet --content-disposition -P"
		DOWNLOAD_OUT="wget --quiet -O"
		log::debug "--- wget found ---"
		log::debug "DOWNLOAD_CMD | $DOWNLOAD_CMD"
		log::debug "DOWNLOAD_DIR | $DOWNLOAD_DIR"
		log::debug "DOWNLOAD_OUT | $DOWNLOAD_OUT"
	elif hash curl &>/dev/null; then
		CURL=true
		DOWNLOAD_CMD="curl --progress-bar -L -O --output-dir"
		DOWNLOAD_DIR="curl --silent -L -O --output-dir"
		DOWNLOAD_OUT="curl --silent -L --output"
		log::debug "--- curl found ---"
		log::debug "DOWNLOAD_CMD | $DOWNLOAD_CMD"
		log::debug "DOWNLOAD_DIR | $DOWNLOAD_DIR"
		log::debug "DOWNLOAD_OUT | $DOWNLOAD_OUT"
	fi
	const::char DOWNLOAD_CMD CURL WGET
	if [[ -z $WGET && -z $CURL ]]; then
		print::error "both [wget] and [curl] were not found!"
		print::error "monero-bash needs at least one to install packages"
		print::exit  "Exiting for safety..."
	else
		return 0
	fi
}
status::table() {
	log::debug "creating status table"
	printf "${OFF}%s\n" \
		"#-----------------------------------------------#" \
		"# monero-bash |   Monero   |  P2Pool  |  XMRig  #" \
		"#-----------------------------------------------#" \
		"# $MONERO_BASH_VER | $MONERO_VER | $P2POOL_VER | $XMRIG_VER #" \
		"#-----------------------------------------------#" \
		"#"
}
struct::pkg() {
	log::debug "defining struct::pkg() for: $1"
	declare -Ag PKG
	[[ $# != 1 ]] && return 1
	case "$1" in
	monero)
		PKG[name]="monero"
		PKG[short]="monero"
		PKG[pretty]="Monero"
		PKG[var]="MONERO"
		PKG[author]="monero-project"
		PKG[gpg_owner]="binaryFate"
		PKG[service]="monero-bash-monerod.service"
		PKG[process]="monerod"
		PKG[directory]="$PACKAGES/monero"
		PKG[regex]="monero-linux-x64.*"
		PKG[hash]="hashes.txt"
		PKG[sig]="${PKG[hash]}"
		PKG[gpg_pub_key]="https://raw.githubusercontent.com/monero-project/monero/master/utils/gpg_keys/binaryfate.asc"
		PKG[gpg_fingerprint]="81AC591FE9C4B65C5806AFC3F0AF4D462A0BDF92"
		PKG[current_version]="$MONERO_VER"
		PKG[old]="$MONERO_OLD"
		PKG[conf]="$CONFIG_MONEROD"
		PKG[conf_name]="monerod.conf"
		;;
	*bash*)
		PKG[name]="monero-bash"
		PKG[short]="bash"
		PKG[pretty]="monero-bash"
		PKG[var]="MONERO_BASH"
		PKG[author]="hinto-janaiyo"
		PKG[gpg_owner]="hinto-janaiyo"
		PKG[service]=
		PKG[process]=
		PKG[directory]="$PACKAGES/monero-bash"
		PKG[regex]="monero-bash-v.*"
		PKG[hash]="SHA256SUM"
		PKG[sig]="${PKG[hash]}"
		PKG[gpg_pub_key]="https://raw.githubusercontent.com/hinto-janaiyo/monero-bash/master/gpg/hinto-janaiyo.asc"
		PKG[gpg_fingerprint]="21958EE945980282FCB849C8D7483F6CA27D1B1D"
		PKG[current_version]="$MONERO_BASH_VER"
		PKG[old]="$MONERO_BASH_OLD"
		PKG[conf]="$CONFIG_MONERO_BASH"
		PKG[conf_name]="monero-bash.conf"
		;;
	*p2p*)
		PKG[name]="p2pool"
		PKG[short]="p2pool"
		PKG[pretty]="P2Pool"
		PKG[var]="P2POOL"
		PKG[author]="SChernykh"
		PKG[gpg_owner]="SChernykh"
		PKG[service]="monero-bash-p2pool.service"
		PKG[process]="p2pool"
		PKG[directory]="$PACKAGES/p2pool"
		PKG[regex]="p2pool.*linux-x64.*"
		PKG[hash]="sha256sums.txt.asc"
		PKG[sig]="${PKG[hash]}"
		PKG[gpg_pub_key]="https://raw.githubusercontent.com/monero-project/gitian.sigs/master/gitian-pubkeys/SChernykh.asc"
		PKG[gpg_fingerprint]="1FCAAB4D3DC3310D16CBD508C47F82B54DA87ADF"
		PKG[current_version]="$P2POOL_VER"
		PKG[old]="$P2POOL_OLD"
		PKG[conf]="$CONFIG_P2POOL"
		PKG[conf_name]="p2pool.conf"
		;;
	*xmr*)
		PKG[name]="xmrig"
		PKG[short]="xmrig"
		PKG[pretty]="XMRig"
		PKG[var]="XMRIG"
		PKG[author]="XMRig"
		PKG[gpg_owner]="XMRig"
		PKG[service]="monero-bash-xmrig.service"
		PKG[process]="xmrig"
		PKG[directory]="$PACKAGES/xmrig"
		PKG[regex]="xmrig.*linux-static-x64.*"
		PKG[hash]="SHA256SUMS"
		PKG[sig]="${PKG[hash]}.sig"
		PKG[gpg_pub_key]="https://raw.githubusercontent.com/xmrig/xmrig/master/doc/gpg_keys/xmrig.asc"
		PKG[gpg_fingerprint]="9AC4CEA8E66E35A5C7CDDC1B446A53638BE94409"
		PKG[current_version]="$XMRIG_VER"
		PKG[old]="$XMRIG_OLD"
		PKG[conf]="$CONFIG_XMRIG"
		PKG[conf_name]="xmrig.json"
		;;
	esac
	PKG[link_api]="https://api.github.com/repos/${PKG[author]}/${PKG[name]}/releases/latest"
	PKG[link_html]="https://github.com/${PKG[author]}/${PKG[name]}/releases/latest"
}
systemd::create() {
	log::debug "starting ${FUNCNAME}() for: ${PKG[pretty]}"
	local TMP_SERVICE SYSTEMD_USER SYSTEMD_EXEC SYSTEMD_DIRECTORY || return 2
	TMP_SERVICE=$(mktemp "/tmp/${PKG[service]}.XXXXXXXXXX")
	chmod 600 "$TMP_SERVICE"
	case "${PKG[name]}" in
		monero)
			SYSTEMD_USER=monero-bash
			SYSTEMD_ENV="$CONFIG_MONERO_BASH"
			SYSTEMD_EXEC="monerod --config-file $CONFIG_MONEROD --non-interactive"
			;;
		p2pool)
			SYSTEMD_USER=monero-bash
			SYSTEMD_ENV="$CONFIG_P2POOL"
			SYSTEMD_EXEC="$PKG_P2POOL/p2pool --wallet \$P2POOL_WALLET"
			;;
		xmrig)
			SYSTEMD_USER=root
			SYSTEMD_ENV=""
			SYSTEMD_EXEC="$PKG_XMRIG/xmrig --config $CONFIG_XMRIG --log-file=$PKG_XMRIG/xmrig.log"
			;;
	esac
cat << EOM >> "$TMP_SERVICE"
[Unit]
Description=${PKG[service]}
After=network-online.target
Wants=network-online.target
[Service]
User=$SYSTEMD_USER
Type=simple
EnvironmentFile="$SYSTEMD_ENV"
ExecStart=$SYSTEMD_EXEC
WorkingDirectory=${PKG[directory]}
Restart=always
RestartSec=5
[Install]
WantedBy=multi-user.target
EOM
	sudo mv "$TMP_SERVICE" "$SYSTEMD/${PKG[service]}" || return 3
	rm "$TMP_SERVICE"
}
systemd::reload() {
	log::debug "starting ${FUNCNAME}()"
	sudo systemctl daemon-reload || return 1
}
wallet::create() {
	log::debug "starting ${FUNCNAME}()"
	char WALLET_TYPE WALLET_NAME
	while :; do
		while :; do
			echo
			printf "${BPURPLE}%s${OFF}%s${BRED}%s${OFF}\n" \
				"--generate-new-wallet         " "| " "[new]" \
				"--generate-from-view-key      " "| " "[view]" \
				"--restore-from-seed           " "| " "[seed]" \
				"--generate-from-json          " "| " "[json]" \
				"--generate-from-spend-key     " "| " "[spend]" \
				"--generate-from-device        " "| " "[device]" \
				"--generate-from-keys          " "| " "[private]" \
				"--generate-from-multisig-keys " "| " "[multisig]" \
				""
			printf "${BYELLOW}%s${OFF}" "Select which method to use: "
			read -r WALLET_TYPE
			case "$WALLET_TYPE" in
				--generate-new-wallet|*new*)           WALLET_TYPE=new;break;;
				--generate-from-view-key|*view*)       WALLET_TYPE=view;break;;
				--restore-from-seed|*seed*)            WALLET_TYPE=seed;break;;
				--generate-from-json|*json*)           WALLET_TYPE=json;break;;
				--generate-from-spend-key|*spend*)     WALLET_TYPE=spend;break;;
				--generate-from-device|*device*)       WALLET_TYPE=device;break;;
				--generate-from-keys|*private*)        WALLET_TYPE=private;break;;
				--generate-from-multisig-keys|*multi*) WALLET_TYPE=multisig;break;;
				*) print::error "Invalid method!"
			esac
		done
		printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}" \
			"Create wallet type: " \
			"[${WALLET_TYPE}]" \
			"? (Y/n) "
		if ask::yes; then
			break
		fi
	done
	while :; do
		printf "${BWHITE}%s${OFF}" "Wallet name: "
		read -r WALLET_NAME
		case "$WALLET_NAME" in
			"") print::error "Empty input";;
			*)  break;;
		esac
	done
	log::debug "creating wallet [$WALLET_NAME] with type [$WALLET_TYPE]"
	cd "$DOT"
	safety::pkg monero
	case "$WALLET_TYPE" in
	new)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-new-wallet "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	view)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-view-key "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	seed)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-new-wallet "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD" \
			--restore-from-seed
			;;
	json)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-json "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	spend)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-spend-key "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	device)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-device "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	private)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-keys "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	multisig)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-multisig-keys "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	esac
	return 0
}
wallet::list() {
	log::debug "starting ${FUNCNAME}()"
	char WALLET_LIST_ALL
	local WALLET_COUNT WALLET_LIST i
	WALLET_LIST_ALL=("$(ls "$WALLETS" | grep -v ".keys")")
	WALLET_COUNT="$(echo "${WALLET_LIST_ALL[@]}" | wc -l)"
	for i in ${WALLET_LIST_ALL[@]}; do
		WALLET_LIST="[${i}]  $WALLET_LIST"
	done
	printf "${BWHITE}%s${OFF}" "$WALLET_COUNT "
	if [[ $WALLET_COUNT = 1 ]]; then
		printf "%s\n" "wallet found"
	else
		printf "%s\n" "wallets found"
	fi
	if [[ $WALLET_COUNT = 0 ]]; then
		echo
	else
		printf "${BWHITE}%s${OFF}\n\n" "$WALLET_LIST"
	fi
	return 0
}
wallet::password() {
	log::debug "starting ${FUNCNAME}()"
	trap 'crypto::key::remove' EXIT
	crypto::key::create
	printf "${BWHITE}%s${OFF}" "Password: "
	read -s -r WALLET_PASSWORD
	WALLET_PASSWORD="$(crypto::encrypt "$WALLET_PASSWORD" "$(cat $CRYPTO_KEY)")"
}
wallet::select() {
	log::debug "starting ${FUNCNAME}()"
	___BEGIN___ERROR___TRACE___
	char WALLET_SELECTION
	local i
	while :; do
	printf "${BYELLOW}%s${OFF}%s${BRED}%s${OFF}%s" \
		"Select a wallet " \
		"or " \
		"[new]" \
		": "
	read -r WALLET_SELECTION
	for i in ${WALLET_LIST_ALL[@]}; do
		[[ $WALLET_SELECTION = "$i" ]] && break
	done
	case "$WALLET_SELECTION" in
		"$i") break;;
		new|New|NEW) break;;
		"")   print::error "Empty input";;
		*)    print::error "Wallet not found";;
	esac
	done
	if [[ $i = new || $i = New || $i = NEW ]]; then
		while :; do
			printf "${BWHITE}%s\n${BYELLOW}%s${OFF}%s${BRED}%s${OFF}" \
				"Wallet name is similar to option..." \
				"SELECT " \
				"or " \
				"CREATE? "
			local SELECT_CREATE
			read -r SELECT_CREATE
			case $SELECT_CREATE in
			select|Select|SELECT)
				printf "${BWHITE}%s${BRED}%s${OFF}\n" \
				"Selecting " \
				"[$WALLET_SELECTION]"
				wallet::password
				wallet::start
				exit
				;;
			create|Create|CREATE)
				printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
				"Creating a " \
				"[new] " \
				"wallet"
				wallet::create
				exit
				;;
			*) print::error "Invalid option!" ;;
			esac
		done
	fi
	case "$WALLET_SELECTION" in
		new|New|NEW)
			printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
			"Creating a " \
			"[new] " \
			"wallet"
			wallet::create
			exit
			;;
	esac
	wallet::password
	wallet::start
	___ENDOF___ERROR___TRACE___
	exit 0
}
wallet::start() {
	log::debug "starting wallet: $WALLET_SELECTION"
	safety::pkg monero
	cd "$DOT"
	if [[ $AUTO_START_MONEROD = true ]]; then
		struct::pkg monero
		process::start
	fi
	"$PKG_MONERO/monero-wallet-cli" \
		--wallet-file "$WALLETS/$WALLET_SELECTION" \
		--config-file "$CONFIG_MONEROD" \
		--password "$(crypto::decrypt "$WALLET_PASSWORD" "$(cat $CRYPTO_KEY)")"
	if [[ $AUTO_STOP_MONEROD = true ]]; then
		struct::pkg monero
		process::stop
	fi
	return 0
}
declare -frg crypto::key::create
declare -frg crypto::key::remove
declare -frg DEBUG
declare -frg monero_bash::install:trap::user
declare -frg monero_bash::install::trap::clean
declare -frg monero_bash::install
declare -frg monero_bash::uninstall
declare -frg parse::config
declare -frg parse::options::pkg
declare -frg parse::options::process
declare -frg parse::options::systemd
declare -frg parse::options
declare -frg parse::p2pool
declare -frg parse::state
declare -frg pkg::copy
declare -frg pkg::copy::cp
declare -frg pkg::download
declare -frg pkg::download::multi
declare -frg pkg::extract
declare -frg pkg::extract::multi
declare -frg pkg::hook::pre
declare -frg pkg::hook::post
declare -frg pkg::hook::post::config
declare -frg pkg::hook::post:systemd
declare -frg pkg::hook::pre::bash
declare -frg pkg::hook::post::bash
declare -frg pkg::info
declare -frg pkg::info::down
declare -frg pkg::info::hash
declare -frg pkg::info::sig
declare -frg pkg::prompt
declare -frg pkg::remove::prompt
declare -frg pkg::remove
declare -frg pkg::tmp::download
declare -frg pkg::tmp::info
declare -frg pkg::tmp::remove
declare -frg pkg::trap::pkg_folders
declare -frg pkg::trap::state::old
declare -frg pkg::trap::remove
declare -frg pkg::update
declare -frg pkg::update::multi
declare -frg pkg::update::ver
declare -frg pkg::update::result
declare -frg pkg::upgrade
declare -frg pkg::verify
declare -frg pkg::verify::key
declare -frg pkg::verify::hash_calc
declare -frg pkg::verify::hash
declare -frg pkg::verify::pgp
declare -frg print::changelog::title
declare -frg print::changelog
declare -frg print::changelog::2.0.0
declare -frg print::changelog::1.6.0
declare -frg print::compromised::hash
declare -frg print::compromised::pgp
declare -frg print::error
declare -frg print::exit
declare -frg print::help
declare -frg print::help::command
declare -frg print::download
declare -frg print::update
declare -frg print::remove
declare -frg print::verify
declare -frg print::install
declare -frg print::upgrade
declare -frg print::hook::pre
declare -frg print::hook::post
declare -frg print::installed
declare -frg print::upgraded
declare -frg print::removed
declare -frg print::updated
declare -frg print::size
declare -frg print::title
declare -frg print::version
declare -frg process::reset_files
declare -frg rpc
declare -frg rpc::quote
declare -frg rpc::parse_arr
declare -frg rpc::parse_nv
declare -frg safety::path
declare -frg safety::pipe
declare -frg safety::pkg
declare -frg safety::root
declare -frg safety::wget_curl
declare -frg status::table
declare -frg struct::pkg
declare -frg systemd::create
declare -frg systemd::reload
declare -frg wallet::create
declare -frg wallet::list
declare -frg wallet::password
declare -frg wallet::select
declare -frg wallet::start
trap - ERR || exit 117
set +eo pipefail || exit 118

#-------------------------------------------------------------------------------- BEGIN MAIN
# This file is part of monero-bash - a wrapper for Monero, written in Bash
#
# Copyright (c) 2022 hinto.janaiyo <https://github.com/hinto-janaiyo>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


main() {
#----------------------------------------- main() START
log::debug "main() started"
# allow for job control
set -m

#----------------------------------------- DEBUG
[[ $1 = DEBUG ]] && DEBUG "$@"

#----------------------------------------- SAFETY
log::debug "starting safety checks"
# check for gnu/linux
safety::gnu_linux
# check for bash v5+
safety::bash
# check for root
safety::root
# check for pipe
safety::pipe
# check for wget/curl
safety::wget_curl

#----------------------------------------- PARSE USER CONFIG/STATE
___BEGIN___ERROR___TRACE___
parse::state
parse::config
___ENDOF___ERROR___TRACE___

#----------------------------------------- MORE SAFETY
# check for path
safety::path

#----------------------------------------- FIRST TIME INSTALLATION
if [[ $FIRST_TIME = true ]]; then
	___BEGIN___ERROR___TRACE___
	log::debug "FIRST_TIME = true | starting installation"
	monero_bash::install
	___ENDOF___ERROR___TRACE___
else
	log::debug "FIRST_TIME = false | skipping installation"
fi

#----------------------------------------- PARSE USER INPUT
[[ $# != 0 ]] && parse::options "$@"

#----------------------------------------- WALLET
# title
print::title

# auto update
[[ $AUTO_UPDATE = true ]] && update && echo

# print wallets
wallet::list

# select wallet
wallet::select

exit 0
}
main "$@"
#-------------------------------------------------------------------------------- ENDOF MAIN
