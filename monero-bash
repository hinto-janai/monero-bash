#!/usr/bin/env bash
#
# monero-bash - a wrapper for Monero, written in Bash
#
# Copyright (c) 2022 hinto.janaiyo <https://github.com/hinto-janaiyo>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

#git <monero-bash/f29487e>
#nix <1658543062>
#hbc <5fdfdff>
#lib <stdlib/ask.sh/1eaba1f>
#lib <stdlib/const.sh/1eaba1f>
#lib <stdlib/crypto.sh/1eaba1f>
#lib <stdlib/date.sh/1eaba1f>
#lib <stdlib/debug.sh/1eaba1f>
#lib <stdlib/is.sh/1eaba1f>
#lib <stdlib/lock.sh/1eaba1f>
#lib <stdlib/log.sh/1eaba1f>
#lib <stdlib/panic.sh/1eaba1f>
#lib <stdlib/readonly.sh/1eaba1f>
#lib <stdlib/safety.sh/1eaba1f>
#lib <stdlib/trace.sh/1eaba1f>
#lib <stdlib/type.sh/1eaba1f>
#src <func/crypto/key.sh>
#src <func/debug.sh>
#src <func/monero_bash/install.sh>
#src <func/monero_bash/uninstall.sh>
#src <func/package/download.sh>
#src <func/package/info.sh>
#src <func/package/install.sh>
#src <func/package/prompt.sh>
#src <func/package/remove.sh>
#src <func/package/tmp.sh>
#src <func/package/trap.sh>
#src <func/package/update.sh>
#src <func/package/upgrade.sh>
#src <func/parse/config.sh>
#src <func/parse/options.sh>
#src <func/parse/p2pool.sh>
#src <func/parse/state.sh>
#src <func/print/changelog.sh>
#src <func/print/compromised.sh>
#src <func/print/error.sh>
#src <func/print/help.sh>
#src <func/print/package.sh>
#src <func/print/size.sh>
#src <func/print/title.sh>
#src <func/print/version.sh>
#src <func/process/reset_files.sh>
#src <func/safety/path.sh>
#src <func/safety/pipe.sh>
#src <func/safety/pkg.sh>
#src <func/safety/root.sh>
#src <func/safety/wget_curl.sh>
#src <func/status/monerod.sh>
#src <func/status/p2pool.sh>
#src <func/status/table.sh>
#src <func/status/xmrig.sh>
#src <func/struct/pkg.sh>
#src <func/systemd/create.sh>
#src <func/systemd/reload.sh>
#src <func/wallet/create.sh>
#src <func/wallet/list.sh>
#src <func/wallet/password.sh>
#src <func/wallet/select.sh>
#src <func/wallet/start.sh>
#src <readonly.sh>

#-------------------------------------------------------------------------------- BEGIN SAFETY
POSIXLY_CORRECT= || exit 90
	# bash builtins
\unset -f . : [ alias bg bind break builtin caller cd command compgen complete compopt continue declare dirs disown echo enable eval exec exit export false fc fg getopts hash help history jobs kill let local logout mapfile popd printf pushd pwd read readarray readonly return set shift shopt source suspend test times trap true type typeset ulimit umask unalias unset wait || exit 91
	# gnu core-utils
\unset -f arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp csplit cut date dd df dir dircolors dirname du echo env expand expr factor false fmt fold groups head hostid hostname id install join kill link ln logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm rmdir runcon seq shred shuf sleep sort split stat stdbuf stty sum tac tail tee test timeout touch tr true truncate tsort tty uname unexpand uniq unlink uptime users vdir wc who whoami yes || exit 92
\unalias -a || exit 93
unset POSIXLY_CORRECT || exit 94
set -eo pipefail || exit 95

#-------------------------------------------------------------------------------- BEGIN LIB
trap 'printf "%s\n" "@@@@@@ LIB PANIC @@@@@@" "[line] ${LINENO}" "[file] $0" "[code] $?";set +eo pipefail;trap - ERR;while :;do read;done;exit 112' ERR || exit 112
ask::yes() {
	local STD_ASK_REPONSE || return 44
	read -r STD_ASK_REPONSE
	case $STD_ASK_REPONSE in
		""|y|Y|yes|Yes|YES) return 0 ;;
		*) return 2 ;;
	esac
}
ask::no() {
	local STD_ASK_RESPONSE || return 44
	read -r STD_ASK_RESPONSE
	case $STD_ASK_RESPONSE in
		y|Y|yes|Yes|YES) return 2 ;;
		*) return 0 ;;
	esac
}
ask::sudo() {
	sudo -v
}
const::char() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="char not found: $i"; return 33; }
		declare -r -g "$i" || return 44
	done
	return 0
}
const::array() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="array not found: $i"; return 33; }
		declare -r -g -a "$i" || return 44
	done
	return 0
}
const::map() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="map not found: $i"; return 33; }
		declare -r -g -A "$i" || return 44
	done
	return 0
}
const::int() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		case "$i" in
			''|*[!0-9]*) { STD_TRACE_RETURN="not integer: $i"; return 33; } ;;
		esac
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="integer not found: $i"; return 44; }
		declare -r -g -i "$i" || return 55
	done
	return 0
}
const::bool() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="bool not found: $i"; return 33; }
		declare -r -g "$i" || return 44
	done
}
const::ref() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="ref not found: $i"; return 33; }
		declare -r -g -n "$i" || return 44
	done
	return 0
}
crypto::bytes() {
	[[ $# = 0 ]] && return 1
	head -c $1 /dev/random
}
crypto::num() {
	case $# in
		1) shuf -i 0-$1 -n 1; return;;
		2) shuf -i $1-$2 -n 1; return;;
		*) return 1;;
	esac
}
crypto::uuid() {
	local STD_CRYPTO_UUID || return 1
	mapfile STD_CRYPTO_UUID < /proc/sys/kernel/random/uuid
	printf "%s" ${STD_CRYPTO_UUID//$'\n'}
}
crypto::encrypt() {
	[[ $# != 2 ]] && return 1
	printf "%s\n" "$1" | gpg --batch --symmetric --armor --quiet --cipher-algo AES256 --passphrase "$2"
}
crypto::decrypt() {
	printf "%s\n" "$1" | gpg --batch --decrypt --quiet --passphrase "$2"
}
date::unix_translate() {
	if [[ -p /dev/stdin ]]; then
		local i || return 11
		for i in $(</dev/stdin); do
			date -d @"$i" || return 22
		done
		return 0
	fi
	[[ $# = 0 ]] && return 33
	while [[ $# != 0 ]]; do
		date -d @"$1" || return 44
		shift
	done
	return 0
}
date::unix() { printf "%s\n" "$EPOCHSECONDS" ;}
date::time() { date +"%T" ;}
date::calendar() { date +"%Y-%m-%d" ;}
date::now() { date +"%Y-%m-%d %T" ;}
date::year() { date +"%Y" ;}
date::month() { date +"%m" ;}
date::day() { date +"%d" ;}
date::hour() { date +"%H" ;}
date::minute() { date +"%M" ;}
date::second() { date +"%S" ;}
debug() {
	[[ $STD_DEBUG != true ]] && return 0
	trap 'STD_DEBUG_CMD="$BASH_COMMAND" STD_DEBUG_FUNC=(${BASH_LINENO[@]}) STD_DEBUG_CMD_NUM="$LINENO" STD_DEBUG_PIPE=(${PIPESTATUS[@]});debug::trap' DEBUG
}
debug::trap() {
	if [[ -z $STD_DEBUG_INIT ]]; then
		declare -g STD_DEBUG_INIT
		STD_DEBUG_INIT=${EPOCHREALTIME//./}
		printf "\r\e[2K\033[1;90m%s\033[1;93m%s\033[0m%s\033[1;93m%s" \
			"[debug 0.000000] " "[ \$_ ] " "${STD_DEBUG_CMD_NUM}: $STD_DEBUG_CMD " "-> "
		local f
		local i=1
		for f in ${STD_DEBUG_FUNC[@]-1}; do
			[[ $f = 0 ]] && break
			printf "\033[1;91m%s\033[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
			((i++))
		done
		printf "\033[0m\n"
		return
	fi
	local STD_DEBUG_ADJUSTED STD_DEBUG_DOT
	STD_DEBUG_ADJUSTED=$((${EPOCHREALTIME//./}-STD_DEBUG_INIT))
	case ${#STD_DEBUG_ADJUSTED} in
		1) STD_DEBUG_ADJUSTED=00000${STD_DEBUG_ADJUSTED//$'\n'};;
		2) STD_DEBUG_ADJUSTED=0000${STD_DEBUG_ADJUSTED//$'\n'};;
		3) STD_DEBUG_ADJUSTED=000${STD_DEBUG_ADJUSTED//$'\n'};;
		4) STD_DEBUG_ADJUSTED=00${STD_DEBUG_ADJUSTED//$'\n'};;
		5) STD_DEBUG_ADJUSTED=0${STD_DEBUG_ADJUSTED//$'\n'};;
	esac
	STD_DEBUG_DOT=$((${#STD_DEBUG_ADJUSTED}-6))
	if [[ $STD_DEBUG_DOT -eq 0 ]]; then
		printf "\r\e[2K\033[1;90m%s\033[1;93m%s\033[0m%s\033[1;93m%s" \
			"[debug 0.${STD_DEBUG_ADJUSTED}] " "[ \$_ ] " "${STD_DEBUG_CMD_NUM}: $STD_DEBUG_CMD " "-> "
	else
		printf "\r\e[2K\033[1;90m%s\033[1;93m%s\033[0m%s\033[1;93m%s" \
			"[debug ${STD_DEBUG_ADJUSTED:0:${STD_DEBUG_DOT}}.${STD_DEBUG_ADJUSTED:${STD_DEBUG_DOT}}] " \
			"[ \$_ ] " "${STD_DEBUG_CMD_NUM}: $STD_DEBUG_CMD " "-> "
	fi
	local f
	local i=1
	for f in ${STD_DEBUG_FUNC[@]-1}; do
		[[ $f = 0 ]] && break
		printf "\033[1;91m%s\033[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
		((i++))
	done
	printf "\033[0m\n"
}
is::int() {
	if [[ -p /dev/stdin ]]; then
		local i || return 11
		for i in $(</dev/stdin); do
			[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not integer: $i"; return 22; }
		done
		return 0
	fi
	[[ $# = 0 ]] && return 33
	local i || return 44
	for i in "$@"; do
		[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not integer: $i"; return 55; }
	done
}
is::int_pos() {
	if [[ -p /dev/stdin ]]; then
		local i || return 11
		for i in $(</dev/stdin); do
			[ $i -gt -1 ] &>/dev/null || { STD_TRACE_RETURN="not pos int: $i"; return 22; }
			[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not pos int: $i"; return 33; }
		done
		return 0
	fi
	[[ $# = 0 ]] && return 44
	local i || return 55
	for i in "$@"; do
		[ $i -gt -1 ] &>/dev/null || { STD_TRACE_RETURN="not pos int: $i"; return 66; }
		[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not pos int: $i"; return 77; }
	done
}
is::int_neg() {
	if [[ -p /dev/stdin ]]; then
		local i || return 11
		for i in $(</dev/stdin); do
			[ $i -lt 0 ] &>/dev/null || { STD_TRACE_RETURN="not neg int: $i"; return 22; }
			[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not neg int: $i"; return 33; }
		done
		return 0
	fi
	[[ $# = 0 ]] && return 44
	local i || return 55
	for i in "$@"; do
		[ $i -lt 0 ] &>/dev/null || { STD_TRACE_RETURN="not neg int: $i"; return 66; }
		[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not neg int: $i"; return 77; }
	done
}
lock::alloc() {
	POSIXLY_CORRECT= || return 7
	\unset -f umask trap set return echo unset local return unalias mapfile command || return 8
	\unalias -a || return 9
	unset -v POSIXLY_CORRECT || return 10
	[[ $# = 0 ]] && return 11
	declare -g -A STD_LOCK_FILE || return 12
	set +f || return 13
	local i f || return 14
	for i in "$@"; do
		for f in /tmp/std_lock_"$i"_*; do
			[[ -e "$f" ]] && { STD_TRACE_RETURN="lock file found: $f"; return 15; }
		done
	done
	local STD_LOCK_UUID || return 22
	until [[ $# = 0 ]]; do
		mapfile STD_LOCK_UUID < /proc/sys/kernel/random/uuid || return 23
		STD_LOCK_UUID[0]=${STD_LOCK_UUID[0]//$'\n'/}
		STD_LOCK_UUID[0]=${STD_LOCK_UUID//-/}
		STD_LOCK_FILE[$1]="/tmp/std_lock_${1}_${STD_LOCK_UUID[0]}" || return 33
		local STD_DEFAULT_UMASK
		STD_DEFAULT_UMASK=$(umask)
		umask 177
		echo > "${STD_LOCK_FILE[$1]}" || return 44
		umask $STD_DEFAULT_UMASK
		shift || return 45
	done
}
lock::free() {
	POSIXLY_CORRECT= || return 7
	\unset -f : unset return rm command || return 8
	\unalias -a || return 9
	unset -v POSIXLY_CORRECT || return 10
	[[ $# = 0 ]] && return 11
	until [[ $# = 0 ]]; do
		if [[ $1 = '@' ]]; then
			command rm "${STD_LOCK_FILE[@]}" || :
			unset -v STD_LOCK_FILE || :
			return 0
		else
			command rm "${STD_LOCK_FILE[$1]}" || { STD_TRACE_RETURN="lock rm fail: ${STD_LOCK_FILE[$1]}"; return 22; }
			unset -v "STD_LOCK_FILE[$1]" || return 23
		fi
		shift
	done
}
log::ok() {
	printf "\r\e[2K"
	printf "\r\e[1;32m[  OK  ]\e[0m %s\n" "$@"
}
log::info() {
	printf "\r\e[2K"
	printf "\r\e[1;37m[ INFO ]\e[0m %s\n" "$@"
}
log::warn() {
	printf "\r\e[2K"
	printf "\r\e[1;33m[ WARN ]\e[0m %s\n" "$@"
}
log::fail() {
	printf "\r\e[2K"
	printf "\r\e[1;31m[ FAIL ]\e[0m %s\n" "$@"
}
log::danger() {
	printf "\r\e[2K"
	printf "\r\e[1;31m[DANGER]\e[0m %s\n" "$@"
}
log::tab() {
	printf "\r\e[2K"
	printf "\r\e[0m         %s\n" "$@"
}
log::prog() {
	printf "\r\e[2K"
	printf "\r\e[1;37m[ \e[0m....\e[1;37m ]\e[0m %s " "$@"
}
log::debug() {
	[[ $STD_LOG_DEBUG != true ]] && return 0
	if [[ -z $STD_LOG_DEBUG_INIT ]]; then
		declare -g STD_LOG_DEBUG_INIT
		STD_LOG_DEBUG_INIT=${EPOCHREALTIME//./}
		printf "\r\e[2K\e[1;90m%s\e[0m%s" "[log::debug 0.000000] " "$* "
		if [[ $STD_LOG_DEBUG_VERBOSE = true ]]; then
			printf "\e[1;93m%s" "-> "
			local f i
			i=1
			for f in ${BASH_LINENO[@]}; do
				[[ $f = 0 ]] && break
				printf "\e[1;91m%s\e[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
				((i++))
			done
		fi
		printf "\e[0m\n"
		return
	fi
	local STD_LOG_DEBUG_ADJUSTED STD_LOG_DEBUG_DOT
	STD_LOG_DEBUG_ADJUSTED=$((${EPOCHREALTIME//./}-STD_LOG_DEBUG_INIT))
	case ${#STD_LOG_DEBUG_ADJUSTED} in
		1) STD_LOG_DEBUG_ADJUSTED=00000${STD_LOG_DEBUG_ADJUSTED};;
		2) STD_LOG_DEBUG_ADJUSTED=0000${STD_LOG_DEBUG_ADJUSTED};;
		3) STD_LOG_DEBUG_ADJUSTED=000${STD_LOG_DEBUG_ADJUSTED};;
		4) STD_LOG_DEBUG_ADJUSTED=00${STD_LOG_DEBUG_ADJUSTED};;
		5) STD_LOG_DEBUG_ADJUSTED=0${STD_LOG_DEBUG_ADJUSTED};;
	esac
	STD_LOG_DEBUG_DOT=$((${#STD_LOG_DEBUG_ADJUSTED}-6))
	if [[ $STD_LOG_DEBUG_DOT -eq 0 ]]; then
		printf "\r\e[2K\e[1;90m%s\e[0m%s" "[log::debug 0.${STD_LOG_DEBUG_ADJUSTED}] " "$* "
	else
		printf "\r\e[2K\e[1;90m%s\e[0m%s" \
			"[log::debug ${STD_LOG_DEBUG_ADJUSTED:0:${STD_LOG_DEBUG_DOT}}.${STD_LOG_DEBUG_ADJUSTED:${STD_LOG_DEBUG_DOT}}] " "$* "
	fi
	if [[ $STD_LOG_DEBUG_VERBOSE = true ]]; then
		printf "\e[1;93m%s" "-> "
		local f i
		i=1
		for f in ${BASH_LINENO[@]}; do
			[[ $f = 0 ]] && break
			printf "\e[1;91m%s\e[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
			((i++))
		done
	fi
	printf "\e[0m\n"
}
panic() {
	local STD_PANIC_CODE="$?" STD_TRACE_FUNC=("${BASH_LINENO[@]}") STD_TRACE_CMD_NUM=${BASH_LINENO[0]}|| exit 98
	POSIXLY_CORRECT= || exit 11
	\unset -f trap set return exit printf echo local unalias unset builtin kill || exit 22
	\unalias -a || exit 33
	unset POSIXLY_CORRECT || exit 44
	printf "\e[7m\e[0;m%s\e[0m\n" "@@@@@@@@  panic  @@@@@@@@"
	local STD_PANIC_CMD
	mapfile -s $((STD_TRACE_CMD_NUM-1)) -n 1 STD_PANIC_CMD < $0
	printf "\e[1;95m%s\e[0m%s\n" "[bash] " "$BASH_VERSION"
	printf "\e[1;96m%s\e[0m%s\n" "[unix] " "$EPOCHSECONDS"
	printf "\e[1;97m%s\e[0m%s\n" "[file] " "${BASH_SOURCE[-1]}"
	printf "\e[1;91m%s\e[0m%s\n" "[code] " "$STD_PANIC_CODE"
	printf "\e[1;94m%s\e[0m%s\n" "[ wd ] " "$PWD"
	printf "\e[1;93m%s\e[0m%s" "[ \$_ ] " "$STD_TRACE_CMD_NUM: ${STD_PANIC_CMD//$'\t'/}"
	local f
	local i=1
	STD_TRACE_FUNC=("${STD_TRACE_FUNC[@]:1}")
	for f in ${STD_TRACE_FUNC[@]}; do
		[[ $f = 0 ]] && break
		printf "\e[1;92m%s\e[0m%s\n" "[func] " "${f}: ${FUNCNAME[${i}]}()"
		((i++))
	done
	local STD_TRACE_LINE_ARRAY
	local STD_ORIGINAL_LINE="$STD_TRACE_CMD_NUM"
	if [[ $STD_TRACE_CMD_NUM -lt 5 ]]; then
		local STD_TRACE_CMD_NUM=1
		mapfile -n 9 STD_TRACE_LINE_ARRAY < $0
	else
		local STD_TRACE_CMD_NUM=$((STD_TRACE_CMD_NUM-4))
		mapfile -s $((STD_TRACE_CMD_NUM-1)) -n 9 STD_TRACE_LINE_ARRAY < $0
	fi
	for i in {0..8}; do
		[[ ${STD_TRACE_LINE_ARRAY[$i]} ]] || break
		if [[ $STD_TRACE_CMD_NUM = "$STD_ORIGINAL_LINE" ]]; then
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;97m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				2) printf "\e[1;97m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				3) printf "\e[1;97m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				4) printf "\e[1;97m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				5) printf "\e[1;97m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				*) printf "\e[1;97m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
			esac
		else
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;90m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				2) printf "\e[1;90m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				3) printf "\e[1;90m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				4) printf "\e[1;90m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				5) printf "\e[1;90m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				*) printf "\e[1;90m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
			esac
		fi
		((STD_TRACE_CMD_NUM++))
	done
	printf "\e[0;m%s\n" "@@@@@@@@  panic  @@@@@@@@"
	while :; do read -s -r; done
	printf "\e[0;m%s\n" "@ loop fail, killing \$$ @"
	builtin kill -s KILL 0
	[[ $1 =~ ^[0-9]+$ ]] && exit $1 || exit 99
}
readonly BLACK="\e[0;30m"
readonly RED="\e[0;31m"
readonly GREEN="\e[0;32m"
readonly YELLOW="\e[0;33m"
readonly BLUE="\e[0;34m"
readonly PURPLE="\e[0;35m"
readonly CYAN="\e[0;36m"
readonly WHITE="\e[0;37m"
readonly BBLACK="\e[1;90m"
readonly BRED="\e[1;91m"
readonly BGREEN="\e[1;92m"
readonly BYELLOW="\e[1;93m"
readonly BBLUE="\e[1;94m"
readonly BPURPLE="\e[1;95m"
readonly BCYAN="\e[1;96m"
readonly BWHITE="\e[1;97m"
readonly UBLACK="\e[4;30m"
readonly URED="\e[4;31m"
readonly UGREEN="\e[4;32m"
readonly UYELLOW="\e[4;33m"
readonly UBLUE="\e[4;34m"
readonly UPURPLE="\e[4;35m"
readonly UCYAN="\e[4;36m"
readonly UWHITE="\e[4;37m"
readonly IBLACK="\e[0;90m"
readonly IRED="\e[0;91m"
readonly IGREEN="\e[0;92m"
readonly IYELLOW="\e[0;93m"
readonly IBLUE="\e[0;94m"
readonly IPURPLE="\e[0;95m"
readonly ICYAN="\e[0;96m"
readonly IWHITE="\e[0;97m"
readonly BOLD="\e[1m"
readonly ITALIC="\e[3m"
readonly OFF="\e[0m"
safety::builtin() {
	POSIXLY_CORRECT= || exit 11
	\unset -f "$@" || exit 22
	\unalias -a || exit 33
	unset POSIXLY_CORRECT || exit 44
}
safety::bash() {
	[[ ${BASH_VERSINFO[0]} -ge 5 ]] || { STD_TRACE_RETURN="bash not v5+: ${BASH_VERSINFO[0]}"; return 11; }
}
safety::gnu_linux() {
	[[ $OSTYPE = linux-gnu* ]] || { STD_TRACE_RETURN="os not gnu/linux: $OSTYPE"; return 11; }
}
___BEGIN___ERROR___TRACE___() {
	POSIXLY_CORRECT= || exit 8
	\unset -f : true false trap set return exit printf unset local return read unalias mapfile kill builtin wait || exit 9
	\unalias -a || exit 10
	unset -v POSIXLY_CORRECT || exit 11
	trap 'STD_TRACE_CMD="$BASH_COMMAND" STD_TRACE_FUNC=(${BASH_LINENO[@]}) STD_TRACE_CMD_NUM="$LINENO" STD_TRACE_PIPE=(${PIPESTATUS[@]}); ___ENDOF___ERROR___TRACE___ > /dev/tty || exit 100' ERR || exit 12
	unset -v STD_TRACE_CMD STD_TRACE_FUNC_NUM STD_TRACE_CMD_NUM STD_TRACE_PIPE || exit 13
	set -E -e -o pipefail || exit 14
	return 0
}
___ENDOF___ERROR___TRACE___() {
	POSIXLY_CORRECT= || exit 15
	\unset -f : true false trap set return exit printf unset local return read unalias mapfile kill builtin wait || exit 16
	\unalias -a || exit 17
	unset -v POSIXLY_CORRECT || exit 18
	if [[ -z $STD_TRACE_PIPE ]]; then
		POSIXLY_CORRECT= || exit 19
		\unset -f trap set return exit return || exit 20
		\unalias -a || exit 21
		unset POSIXLY_CORRECT || exit 22
		unset -v STD_TRACE_CMD STD_TRACE_FUNC_NUM STD_TRACE_CMD_NUM STD_TRACE_PIPE || exit 23
		set +E +eo pipefail || exit 24
		trap - ERR || exit 25
		return 0
	fi
	printf "\e[1;91m%s\n" "========  BEGIN ERROR TRACE  ========"
	printf "\e[1;95m%s\e[0m%s\n" "[bash] " "$BASH_VERSION"
	printf "\e[1;96m%s\e[0m%s\n" "[unix] " "$EPOCHSECONDS"
	printf "\e[1;91m%s" "[code] "
	for i in "${STD_TRACE_PIPE[@]}"; do
		printf "\e[0m%s" "$i"
	done
	printf "\n\e[1;97m%s\e[0m%s\n" "[file] " "${BASH_SOURCE[-1]}"
	printf "\e[1;94m%s\e[0m%s\n" "[ wd ] " "$PWD"
	printf "\e[1;93m%s\e[0m%s\n" "[ \$_ ] " "${STD_TRACE_CMD_NUM}: $STD_TRACE_CMD"
	local f
	local i=1
	for f in "${STD_TRACE_FUNC[@]}"; do
		[[ $f = 0 ]] && break
		printf "\e[1;92m%s\e[0m%s\n" "[func] " "${f}: ${FUNCNAME[${i}]}()"
		((i++))
	done
	local STD_TRACE_LINE_ARRAY
	local STD_ORIGINAL_LINE="$STD_TRACE_CMD_NUM"
	if [[ $STD_TRACE_CMD_NUM -lt 5 ]]; then
		local STD_TRACE_CMD_NUM=1
		mapfile -n 9 STD_TRACE_LINE_ARRAY < "$0"
	else
		local STD_TRACE_CMD_NUM=$((STD_TRACE_CMD_NUM-4))
		mapfile -s $((STD_TRACE_CMD_NUM-1)) -n 9 STD_TRACE_LINE_ARRAY < "$0"
	fi
	for i in {0..8}; do
		[[ ${STD_TRACE_LINE_ARRAY[$i]} ]] || break
	  local STD_TRACE_SPACING="    "
		if [[ $STD_TRACE_CMD_NUM = "$STD_ORIGINAL_LINE" ]]; then
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;97m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				2) printf "\e[1;97m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				3) printf "\e[1;97m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				4) printf "\e[1;97m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				5) printf "\e[1;97m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				*) printf "\e[1;97m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
			esac
		else
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;90m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				2) printf "\e[1;90m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				3) printf "\e[1;90m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				4) printf "\e[1;90m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				5) printf "\e[1;90m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				*) printf "\e[1;90m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
			esac
		fi
		((STD_TRACE_CMD_NUM++))
	done
	[[ $STD_TRACE_RETURN ]] && printf "\e[38;5;196m%s\e[0;1m%s\e[0m\n" "[STD_TRACE_RETURN]" " $STD_TRACE_RETURN"
	printf "\e[1;91m%s\e[0m\n" "========  ENDOF ERROR TRACE  ========"
	unset -v STD_TRACE_CMD STD_TRACE_FUNC_NUM STD_TRACE_CMD_NUM STD_TRACE_PIPE || exit 26
	set +E +eo pipefail || exit 27
	trap - ERR || exit 28
	if [[ $BASH_SUBSHELL != 0 ]]; then
		printf "\e[1;93m%s\e[0m\n" "======  SUB-SHELLS TERMINATED  ======"
	fi
	builtin kill -s TERM 0 "$(jobs -p)"
	exit 99
	printf "\e[1;97m%s\e[0m\n" "=KILL/EXIT FAIL, BEGIN INFINITE LOOP="
	while :; do read -s -r; done
	while true; do read -s -r; done
	while true; do false; done
	while :; do :; done
}
char() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p ${i%=*} &>/dev/null && { STD_TRACE_RETURN="char already found: $i"; return 33; }
		declare -g "$i" || return 44
	done
	return 0
}
array() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		{ declare -p ${i%=*} &>/dev/null || [[ -v ${i%=*} ]]; } && { STD_TRACE_RETURN="array already found: $i"; return 33; }
		declare -g -a "$i" || return 44
	done
	return 0
}
map() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		{ declare -p ${i%=*} &>/dev/null || [[ -v ${i%=*} ]]; } && { STD_TRACE_RETURN="map already found: $i"; return 33; }
		declare -g -A "$i" || return 44
	done
	return 0
}
int() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		if [[ $i = *=* ]]; then
			case ${i/*=} in
				''|*[!0-9]*) { STD_TRACE_RETURN="not integer: $i"; return 33; } ;;
			esac
		fi
		declare -p ${i%=*} &>/dev/null && { STD_TRACE_RETURN="integer already found: $i"; return 44; }
		declare -g -i "$i" || return 55
	done
	return 0
}
bool() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p ${i%=*} &>/dev/null && { STD_TRACE_RETURN="bool already found: $i"; return 33; }
		case $i in
			*=true) declare -g ${i%=*}=true || return 44 ;;
			*=false) declare -g ${i%=*}=false || return 55 ;;
			*) return 66 ;;
		esac
	done
}
ref() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p ${i%=*} &>/dev/null && { STD_TRACE_RETURN="ref already found: $i"; return 33; }
		declare -g -n "$i" || return 44
	done
	return 0
}
free() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		{ declare -p ${i%=*} &>/dev/null || [[ -v ${i%=*} ]]; } || { STD_TRACE_RETURN="no var found: $i"; return 33; }
		unset -v "$i" || { STD_TRACE_RETURN="could not free: $i"; return 44; }
	done
	return 0
}
free::func() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -F "$i" &>/dev/null || { STD_TRACE_RETURN="no func found: $i"; return 33; }
		unset -f "$i" || { STD_TRACE_RETURN="could not free: $i"; return 44; }
	done
	return 0
}
declare -frg ask::yes
declare -frg ask::no
declare -frg ask::sudo
declare -frg const::char
declare -frg const::array
declare -frg const::map
declare -frg const::int
declare -frg const::bool
declare -frg const::ref
declare -frg crypto::bytes
declare -frg crypto::num
declare -frg crypto::uuid
declare -frg crypto::encrypt
declare -frg crypto::decrypt
declare -frg date::unix_translate
declare -frg date::unix
declare -frg date::time
declare -frg date::calendar
declare -frg date::now
declare -frg date::year
declare -frg date::month
declare -frg date::day
declare -frg date::hour
declare -frg date::minute
declare -frg date::second
declare -frg debug
declare -frg debug::trap
declare -frg is::int
declare -frg is::int_pos
declare -frg is::int_neg
declare -frg lock::alloc
declare -frg lock::free
declare -frg log::ok
declare -frg log::info
declare -frg log::warn
declare -frg log::fail
declare -frg log::danger
declare -frg log::tab
declare -frg log::prog
declare -frg log::debug
declare -frg panic
declare -frg safety::builtin
declare -frg safety::bash
declare -frg safety::gnu_linux
declare -frg ___BEGIN___ERROR___TRACE___
declare -frg ___ENDOF___ERROR___TRACE___
declare -frg char
declare -frg array
declare -frg map
declare -frg int
declare -frg bool
declare -frg ref
declare -frg free
declare -frg free::func

#-------------------------------------------------------------------------------- BEGIN SRC
trap 'printf "%s\n" "@@@@@@ SRC PANIC @@@@@@" "[line] ${LINENO}" "[file] $0" "[code] $?";set +eo pipefail;trap - ERR;while :;do read;done;exit 115' ERR || exit 115
crypto::key::create() {
	log::debug "creating one-time key with 4096 bits of entropy"
	char CRYPTO_KEY
	CRYPTO_KEY=$(mktemp /tmp/monero-bash-crypto-key.XXXXXXXXXX)
	chmod 600 "$CRYPTO_KEY"
	crypto::bytes 512 | base64 > "$CRYPTO_KEY"
	log::debug "created one-time key: $CRYPTO_KEY"
	return 0
}
crypto::key::remove() {
	log::debug "deleting one-time key: $CRYPTO_KEY"
	[[ -e $CRYPTO_KEY ]]
	rm "$CRYPTO_KEY"
	free CRYPTO_KEY
}
DEBUG() {
	log::debug "starting ${FUNCNAME}()"
	log::debug "entering debug function mode"
	printf "${BRED}%s\n${BWHITE}%s\n${BWHITE}%s\n${BWHITE}%s\n${BWHITE}%s\n${BGREEN}%s${OFF}\n" \
		"====    MONERO-BASH DEBUG MODE   ===="
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		"@ you are executing a monero-bash   @" \
		"@ function directly, use carefully! @" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		"function(): "
	local DEBUG_FUNCTION || return 1
	read -r DEBUG_FUNCTION || return 2
	if ! declare -fp "$DEBUG_FUNCTION" &>/dev/null; then
		log::fail "$DEBUG_FUNCTION not found"
		exit 1
	fi
	log::debug "executing debug function: $DEBUG_FUNCTION"
	$DEBUG_FUNCTION
	exit
}
monero_bash::install() {
log::debug "starting ${FUNCNAME}()"
if [[ -d "$HOME"/.monero-bash ]]; then
	print::error "$HOME/.monero-bash already found!"
	print::exit  "Exiting for safety..."
fi
if [[ -e /usr/local/bin/monero-bash ]]; then
	print::error "/usr/local/bin/monero-bash already found!"
	print::exit  "Exiting for safety..."
fi
local INSTALL_PWD
INSTALL_PWD="$(realpath "$0")"
if [[ $INSTALL_PWD != */monero-bash/monero-bash ]]; then
	print::error "[monero-bash] is not in the monero-bash folder"
	print::exit  "Exiting for safety..."
else
	INSTALL_PWD="$(dirname "$INSTALL_PWD")"
fi
printf "${BRED}%s${OFF}%s\n" \
	"#-----------------------------------------------------------------#" \
	"#                    monero-bash installation                     #" \
	"#-----------------------------------------------------------------#"
while :; do
	local INSTALL_DATA_PATH
	if [[ -d "$HOME"/.bitmonero ]]; then
		printf "${OFF}%s\n${OFF}%s" \
			"Monero data folder already detected" \
			"Use $HOME/.bitmonero? (Y/n) "
		if ask::yes; then
			INSTALL_DATA_PATH="$HOME/.bitmonero"
		else
			printf "%s\n" "Skipping $HOME/.bitmonero"
		fi
	fi
	if [[ -z $INSTALL_DATA_PATH ]]; then
		printf "%s" "Monero data path [Enter for default]: "
		read -r INSTALL_DATA_PATH
	fi
	if [[ -z $INSTALL_DATA_PATH ]]; then
		INSTALL_DATA_PATH="$HOME/.bitmonero"
	fi
	printf "${BWHITE}%s${BYELLOW}%s\n${OFF}%s" \
		"DATA PATH: " \
		"$INSTALL_DATA_PATH" \
		"Is this okay? (Y/n) "
	if ask::yes; then
		break
	fi
done
if [[ ! -e /usr/local/bin/mb ]]; then
	printf "${OFF}%s${BRED}%s${OFF}%s${BRED}%s${OFF}\n" \
		"Symlink creation: " \
		"[monero-bash] " \
		"--> " \
		"[mb]"
	printf "${OFF}%s${BRED}%s${OFF}%s${BYELLOW}%s${OFF}\n" \
		"This allows you to use " \
		"[monero-bash] " \
		"like so: " \
		"mb update && mb upgrade"
	printf "${OFF}%s" "Create symlink? (Y/n) "
	if ask::yes; then
		local INSTALL_SYMLINK=true
	else
		printf "%s\n" "Skipping symlink..."
	fi
fi
echo
printf "${OFF}%s${BYELLOW}%s\n" \
	"[monero-bash] will install in | " "$HOME/.monero-bash" \
	"The path will be set in       | " "/usr/local/bin/monero-bash" \
	".bitmonero will be set in     | " "$INSTALL_DATA_PATH"
if [[ $INSTALL_SYMLINK = true ]]; then
	printf "${OFF}%s${BYELLOW}%s\n" \
	"A path symlink will be set in | " "/usr/local/bin/mb"
fi
echo
printf "${BWHITE}%s${OFF}\n" \
	"A no-login user called [monero-bash] will be created for process security" \
	"This will be the user Monero and P2Pool runs as"
echo
printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
	"Start " \
	"[monero-bash] " \
	"install? (Y/n) "
if ask::yes; then
	printf "${OFF}%s${BRED}%s${OFF}%s\n" \
	"Starting " \
	"[monero-bash] " \
	"install..."
else
	printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
		"Canceling " \
		"[monero-bash] " \
		"installation"
	exit 1
fi
if ! ask::sudo; then
	print::exit "sudo is required for installation"
fi
log::prog "verifying monero-bash file hashes"
if sha256sum --quiet --check "src/txt/hashlist"; then
	log::ok "monero-bash file hashes"
else
	log::fail "monero-bash file hashes"
	print::error "Hash verification has failed."
	print::exit "Have the files been moved for modified?"
fi
___BEGIN___ERROR___TRACE___
log::prog "creating monero-bash user"
local NOLOGIN_SHELL
NOLOGIN_SHELL="$(which nologin)"
if ! sudo useradd --shell "$NOLOGIN_SHELL" --no-create-home --system; then
	print::error "Could not create monero-bash user"
	print::exit "Exiting for safety..."
fi
log::ok "created monero-bash user"
log::prog "creating .monero-bash folders"
mkdir -p packages
mkdir -p packages/monero-bash
mkdir -p wallets
log::ok "created .monero-bash folders"
log::prog "copying monero-bash files"
cp -r monero-bash "$PKG_MONERO_BASH"
cp -r src "$PKG_MONERO_BASH"
cp -r gpg "$PKG_MONERO_BASH"
log::prog "copied monero-bash files"
log::prog "cleaning git files"
[[ -e docs ]]         && rm -rf doc
[[ -e lib ]]          && rm -rf lib
[[ -e tests ]]        && rm -rf tests
[[ -e CHANGELOG.md ]] && rm -rf CHANGELOG.md
[[ -e README.md ]]    && rm -rf README.md
[[ -e LICENSE ]]      && rm -rf LICENSE
[[ -e hbc.add ]]      && rm -f hbc.add
[[ -e hbc.conf ]]     && rm -f hbc.conf
[[ -e main.sh ]]      && rm -f main.sh
log::ok "cleaned git files"
log::prog "moving folder to $HOME/.monero-bash"
mkdir "$HOME/.monero-bash"
mv "$INSTALL_PWD" "$HOME/.monero-bash"
INSTALL_PWD="$HOME/.monero-bash"
cd "$INSTALL_PWD"
log::prog "moved folder to $HOME/.monero-bash"
log::prog "creating config folder"
mkdir -p configs
cp "$PKG_MONERO_BASH/configs/monero-bash.conf" "$CONFIG/"
log::ok "created config folder"
log::prog "adding [monero-bash] to PATH"
sudo ln -s "$INSTALL_PWD/packages/monero-bash/monero-bash" /usr/local/bin/monero-bash
log::ok "added [monero-bash] to PATH"
if [[ $INSTALL_SYMLINK = true ]]; then
	log::prog "creating [mb] PATH symlink"
	sudo ln -s "$INSTALL_PWD/packages/monero-bash/monero-bash" /usr/local/bin/mb
	log::ok "created [mb] PATH symlink"
fi
log::prog "setting Monero data path"
sed -i "s/.*data-dir.*/data-dir=$INSTALL_DATA_PATH/" "$CONFIG_MONEROD"
log::ok "set Monero data path"
sed -i "s/FIRST_TIME=.*/FIRST_TIME=\"false\"/" "$STATE"
log::prog "setting folder permissions"
sudo chown "$USER:$USER" "$INSTALL_PWD"
sudo chmod -R 755 "$INSTALL_PWD"
log::ok "set folder permissions"
___ENDOF___ERROR___TRACE___
printf "${BGREEN}%s${OFF}%s\n" \
	"#-----------------------------------------------------------------#" \
	"#                monero-bash installation complete                #" \
	"#-----------------------------------------------------------------#"
printf "${BWHITE}%s${BYELLOW}%s\n" \
	"monero-bash path    | " "$HOME/.monero-bash" \
	"Monero data path    | " "$INSTALL_DATA_PATH" \
	"Wallet files        | " "$WALLETS" \
	"Package folders     | " "$PACKAGES" \
	"Configuration files | " "$CONFIG"
echo
printf "${BWHITE}%s${BRED}%s${BWHITE}%s\n" \
	"Type: " \
	"[monero-bash help] " \
	"to get started"
exit 0
}
monero_bash::uninstall() {
log::debug "starting ${FUNCNAME}()"
printf "${BWHITE}%s\n${BWHITE}%s${BRED}%s${BWHITE}%s\n${BWHITE}%s${OFF}\n" \
	"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
	"@ " \
	"THIS WILL UNINSTALL [monero-bash], DELETE /.monero-bash/ AND EVERYTHING INSIDE IT " \
	"@" \
	"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
print::size
printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}" \
	"Uninstall " \
	"[monero-bash]" \
	"?"
if ! ask::yes; then
	print::exit "Canceling [monero-bash] uninstall"
fi
local WALLET_COUNT
WALLET_COUNT=$(ls "$WALLETS" | wc -l) || exit 1
if [[ $WALLET_COUNT != 0 ]]; then
	printf "${BWHITE}%s\n${BWHITE}%s${BRED}%s${BWHITE}%s\n${BWHITE}%s\n${BRED}%s" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		"@ " \
		"         WARNING: WALLETS FOUND          " \
		"@" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		"ARE YOU SURE YOU WANT TO UNINSTALL? (y/N) "
	if ask::no; then
		exit 1
	fi
fi
if ! ask::sudo; then
	print::exit "sudo is needed to uninstall"
fi
local i
for i in {10..0}; do
	printf "\r\e[2K${BYELLOW}%s" "Uninstalling in ${i}..."
	sleep 1
done
log::info "stopping all processes"
if [[ $MONERO_VER ]]; then
	if systemctl status monero-bash-monerod &>/dev/null; then
		process::systemd::stop monerod
	fi
fi
if [[ $P2POOL_VER ]]; then
	if systemctl status monero-bash-p2pool &>/dev/null; then
		process::systemd::stop p2pool
	fi
fi
if [[ $XMRIG_VER ]]; then
	if systemctl status monero-bash-xmrig &>/dev/null; then
		process::systemd::stop xmrig
	fi
fi
trap "" INT
___BEGIN___ERROR___TRACE___
log::prog "Removing $DOT"
rm -rf "$DOT"
log::ok "Removed $DOT"
log::prog "Removing from PATH"
sudo rm /usr/local/bin/monero-bash
[[ -e /usr/local/bin/mb ]] && sudo rm /usr/local/bin/monero-bash
log::ok "Removed from PATH"
log::prog "Removing systemd services"
[[ -e "$SYSTEMD/monero-bash-monerod.service" ]] && sudo rm "$SYSTEMD/monero-bash-monerod.service"
[[ -e "$SYSTEMD/monero-bash-p2pool.service" ]]  && sudo rm "$SYSTEMD/monero-bash-p2pool.service"
[[ -e "$SYSTEMD/monero-bash-xmrig.service" ]]   && sudo rm "$SYSTEMD/monero-bash-xmrig.service"
log::ok "Removed systemd services"
___ENDOF___ERROR___TRACE___
echo
log::ok "Successfully uninstalled [monero-bash]"
exit 0
}
download() {
true
}
info() {
	log::debug "starting ${FUNCNAME}()"
}
install::prompt() {
	log::debug "starting ${FUNCNAME}()"
	[[ $OPTION_VERBOSE = true ]] && printf "${BBLUE}%s${OFF}\n" "Installing verbosely...!"
	[[ $OPTION_FORCE = true ]]   && printf "${BBLUE}%s${OFF}\n" "Installing forcefully...!"
	char UPGRADE_LIST
	[[ $OPTION_INSTALL_BASH = true ]]   && UPGRADE_LIST="[monero-bash]"
	[[ $OPTION_INSTALL_MONERO = true ]] && UPGRADE_LIST="$UPGRADE_LIST [monero]"
	[[ $OPTION_INSTALL_P2POOL = true ]] && UPGRADE_LIST="$UPGRADE_LIST [p2pool]"
	[[ $OPTION_INSTALL_XMRIG = true ]]  && UPGRADE_LIST="$UPGRADE_LIST [xmrig]"
	if [[ $OPTION_INSTALL_BASH = true && $MONERO_BASH_VER ]]; then
		printf "${OFF}%s\n" "[monero-bash] ($MONERO_BASH_VER) is already installed"
		UPGRADE_LIST="${UPGRADE_LIST/\[monero-bash\]}"
	fi
	if [[ $OPTION_INSTALL_MONERO = true && $MONERO_VER ]]; then
		printf "${OFF}%s\n" "[monero] ($MONERO_VER) is already installed"
		UPGRADE_LIST="${UPGRADE_LIST/\[monero\]}"
	fi
	if [[ $OPTION_INSTALL_P2POOL = true && $P2POOL_VER ]]; then
		printf "${OFF}%s\n" "[p2pool] ($P2POOL_VER) is already installed"
		UPGRADE_LIST="${UPGRADE_LIST/\[p2pool\]}"
	fi
	if [[ $OPTION_INSTALL_XMRIG = true && $XMRIG_VER ]]; then
		printf "${OFF}%s\n" "[xmrig] ($XMRIG_VER) is already installed"
		UPGRADE_LIST="${UPGRADE_LIST/\[xmrig\]}"
	fi
	if [[ $UPGRADE_LIST = " " || -z $UPGRADE_LIST ]]; then
		log::debug "UPGRADE_LIST is empty, exiting"
		exit 1
	fi
	printf "${BWHITE}%s${OFF}%s\n\n${BWHITE}%s" \
		"Packages to install: " \
		"$UPGRADE_LIST" \
		"Continue with installation? (Y/n) "
	if ! ask::yes; then
		print::exit "Canceling installation"
	fi
	if ! ask::sudo; then
		print::exit "sudo is required"
	fi
	log::debug "starting install of packages: $UPGRADE_LIST"
	UPGRADE_LIST=("$UPGRADE_LIST")
	UPGRADE_LIST=("${UPGRADE_LIST[@]//[}")
	UPGRADE_LIST=("${UPGRADE_LIST[@]//]}")
	upgrade
}
upgrade::prompt() {
	log::debug "starting ${FUNCNAME}()"
	local PROMPT_VERB PROMPT_NOUN
	if [[ $1 = install ]]; then
		PROMPT_VERB="Installing"
		PROMPT_NOUN="install"
	else
		PROMPT_VERB="Upgrading"
		PROMPT_NOUN="upgrade"
	fi
	[[ $OPTION_VERBOSE = true ]] && printf "${BBLUE}%s${OFF}\n" "$PROMPT_VERB verbosely...!"
	[[ $OPTION_FORCE = true ]]   && printf "${BBLUE}%s${OFF}\n" "$PROMPT_VERB forcefully...!"
	local UPGRADE_LIST
	[[ $OPTION_BASH = true ]]   && UPGRADE_LIST="[monero-bash]"
	[[ $OPTION_MONERO = true ]] && UPGRADE_LIST="$UPGRADE_LIST [monero]"
	[[ $OPTION_P2POOL = true ]] && UPGRADE_LIST="$UPGRADE_LIST [p2pool]"
	[[ $OPTION_XMRIG = true ]]  && UPGRADE_LIST="$UPGRADE_LIST [xmrig]"
	if [[ $OPTION_FORCE != true ]]; then
		if [[ $OPTION_BASH = true && $MONERO_BASH_OLD != true ]]; then
			printf "${OFF}%s\n" "[monero-bash] ($MONERO_BASH_VER) is up to date"
			UPGRADE_LIST="${UPGRADE_LIST/\[monero-bash\]}"
		fi
		if [[ $OPTION_MONERO = true && $MONERO_OLD != true ]]; then
			printf "${OFF}%s\n" "[monero] ($MONERO_VER) is up to date"
			UPGRADE_LIST="${UPGRADE_LIST/\[monero\]}"
		fi
		if [[ $OPTION_P2POOL = true && $P2POOL_OLD != true ]]; then
			printf "${OFF}%s\n" "[p2pool] ($P2POOL_VER) is up to date"
			UPGRADE_LIST="${UPGRADE_LIST/\[p2pool\]}"
		fi
		if [[ $OPTION_XMRIG = true && $XMRIG_OLD != true ]]; then
			printf "${OFF}%s\n" "[xmrig] ($XMRIG_VER) is up to date"
			UPGRADE_LIST="${UPGRADE_LIST/\[xmrig\]}"
		fi
		if [[ $UPGRADE_LIST = " " || -z $UPGRADE_LIST ]]; then
			log::debug "UPGRADE_LIST is empty, exiting"
			exit 1
		fi
	fi
	printf "${BWHITE}%s${OFF}%s\n\n${BWHITE}%s" \
		"Packages to $PROMPT_NOUN: " \
		"$UPGRADE_LIST" \
		"Continue with ${PROMPT_NOUN}? (Y/n) "
	if ! ask::yes; then
		print::exit "Canceling $PROMPT_NOUN"
	fi
	if ! ask::sudo; then
		print::exit "sudo is required"
	fi
	log::debug "starting $PROMPT_NOUN of packages: $UPGRADE_LIST"
	UPGRADE_LIST=("$UPGRADE_LIST")
	UPGRADE_LIST=("${UPGRADE_LIST[@]//[}")
	UPGRADE_LIST=("${UPGRADE_LIST[@]//]}")
	upgrade
}
remove::prompt() {
	log::debug "starting ${FUNCNAME}()"
	local REMOVE_LIST || return 1
	if [[ $OPTION_REMOVE_BASH = true ]]; then
		printf "${OFF}%s\n%s${BYELLOW}%s${OFF}%s\n" \
			"[monero-bash] ($MONERO_BASH_VER) cannot be removed normally" \
			"type: " \
			"[monero-bash uninstall]" \
			"to cleanly uninstall monero-bash from your system"
		exit 1
	fi
	[[ $OPTION_REMOVE_MONERO = true ]] && REMOVE_LIST="$REMOVE_LIST [monero]"
	[[ $OPTION_REMOVE_P2POOL = true ]] && REMOVE_LIST="$REMOVE_LIST [p2pool]"
	[[ $OPTION_REMOVE_XMRIG = true ]]  && REMOVE_LIST="$REMOVE_LIST [xmrig]"
	if [[ $OPTION_REMOVE_MONERO = true && -z $MONERO_VER ]]; then
		printf "${OFF}%s\n" "[monero] is not installed"
		REMOVE_LIST="${REMOVE_LIST/\[monero\]}"
	fi
	if [[ $OPTION_REMOVE_P2POOL = true && -z $P2POOL_VER ]]; then
		printf "${OFF}%s\n" "[p2pool] is not installed"
		REMOVE_LIST="${REMOVE_LIST/\[p2pool\]}"
	fi
	if [[ $OPTION_REMOVE_XMRIG = true && -z $XMRIG_VER ]]; then
		printf "${OFF}%s\n" "[xmrig] is not installed"
		REMOVE_LIST="${REMOVE_LIST/\[xmrig\]}"
	fi
	[[ $REMOVE_LIST = " " ]] && exit 1
	printf "${BWHITE}%s${OFF}%s\n\n${BWHITE}%s" \
		"Packages to remove: " \
		"$REMOVE_LIST" \
		"Continue with removal? (y/N) "
	if ask::no; then
		print::exit "Canceling installation"
	fi
	if ! ask::sudo; then
		print::exit "sudo is required"
	fi
	[[ $OPTION_REMOVE_MONERO = true ]] && struct::pkg monero && remove
	[[ $OPTION_REMOVE_P2POOL = true ]] && struct::pkg p2pool && remove
	[[ $OPTION_REMOVE_XMRIG = true ]]  && struct::pkg xmrig  && remove
}
remove() {
	log::debug "starting ${FUNCNAME}() on package: ${PKG[name]}"
	___BEGIN___ERROR___TRACE___
	trap "" INT
	print::remove
	trap 'trap::remove &' EXIT
	log::prog "${PKG[directory]}..."
	rm "${PKG[directory]}"
	log::ok "${PKG[directory]} deleted"
	log::prog "${PKG[service]}..."
	sudo rm "$SYSTEMD/${PKG[service]}"
	log::ok "${PKG[service]} deleted"
	log::prog "Updating local state..."
	sudo sed \
		-i -e "s/${PKG[var]}_VER=./${PKG[var]}_VER=/" "$STATE" \
		-i -e "s/${PKG[var]}_OLD=./${PKG[var]}_OLD=\"true\"/" "$STATE"
	log::ok "Updated local state"
	trap - INT EXIT
	log::prog "Reloading systemd..."
	systemd::reload
	log::ok "Reloaded systemd"
	print::removed
	___ENDOF___ERROR___TRACE___
}
tmp::pkg() {
	log::debug "starting ${FUNCNAME}()"
	tmp::remove
	log::debug "creating tmp package files/folders"
	map TMP_PKG TMP_PKG[main] TMP_PKG[pkg] TMP_PKG[hash] TMP_PKG[gpg] TMP_PKG[sig]
	TMP_PKG[main]="$(mktemp -d /tmp/monero-bash.XXXXXXXXXX)"
	TMP_PKG[pkg]="$(mktemp -d ${TMP_PKG[main]}/monero-bash-pkg.XXXXXXXXXX)"
	TMP_PKG[gpg]="$(mktemp -d ${TMP_PKG[main]}/monero-bash-gpg.XXXXXXXXXX)"
	TMP_PKG[sig]="$(mktemp -d ${TMP_PKG[main]}/monero-bash-sig.XXXXXXXXXX)"
	TMP_PKG[hash]="$(mktemp -d ${TMP_PKG[main]}/monero-bash-hash.XXXXXXXXXX)"
	log::debug "--- tmp pkg folders ---"
	log::debug "TMP_PKG[main] | ${TMP_PKG[main]}"
	log::debug "TMP_PKG[pkg]  | ${TMP_PKG[pkg]}"
	log::debug "TMP_PKG[gpg]  | ${TMP_PKG[gpg]}"
	log::debug "TMP_PKG[sig]  | ${TMP_PKG[sig]}"
	log::debug "TMP_PKG[hash] | ${TMP_PKG[hash]}"
}
tmp::info() {
	log::debug "starting ${FUNCNAME}()"
	tmp::remove
	log::debug "creating tmp package info files"
	map TMP_INFO TMP_INFO[main] TMP_INFO[bash] TMP_INFO[monero] TMP_INFO[p2pool] TMP_INFO[xmrig]
	TMP_INFO[main]="$(mktemp -d /tmp/monero-bash-info.XXXXXXXXXX)"
	TMP_INFO[bash]="$(mktemp ${TMP_INFO[main]}/bash-info.XXXXXXXXXX)"
	[[ $MONERO_VER ]] && TMP_INFO[monero]="$(mktemp ${TMP_INFO[monero]}/monero-info.XXXXXXXXXX)"
	[[ $P2POOL_VER ]] && TMP_INFO[p2pool]="$(mktemp ${TMP_INFO[p2pool]}/p2pool-info.XXXXXXXXXX)"
	[[ $XMRIG_VER ]]  && TMP_INFO[xmrig]="$(mktemp ${TMP_INFO[xmrig]}/xmrig-info.XXXXXXXXXX)"
	log::debug "--- tmp info folders ---"
	log::debug "TMP_INFO[main]   | ${TMP_INFO[main]}"
	log::debug "TMP_INFO[bash]   | ${TMP_INFO[bash]}"
	[[ $MONERO_VER ]] && log::debug "TMP_INFO[monero] | ${TMP_INFO[monero]}"
	[[ $P2POOL_VER ]] && log::debug "TMP_INFO[p2pool] | ${TMP_INFO[p2pool]}"
	[[ $XMRIG_VER ]]  && log::debug "TMP_INFO[xmrig]  | ${TMP_INFO[xmrig]}"
	return 0
}
tmp::remove() {
	log::debug "starting ${FUNCNAME}()"
	if find /tmp/monero-bash* &>/dev/null; then
		log::debug "old tmp folders found, removing"
		rm -rf /tmp/monero-bash*
	else
		log::debug "no old tmp folders found, skipping"
	fi
}
trap::pkg_folders() {
	log::debug "starting ${FUNCNAME}()"
	printf "${BRED}%s${BYELLOW}%s${OFF}%s${BWHITE}%s${OFF}\n" \
	"[monero-bash] " \
	"exit signal caught " \
	"| " \
	"cleaning up temporary files"
	tmp::remove
}
trap::remove() {
	log::debug "starting ${FUNCNAME}()"
	printf "${BRED}%s${BYELLOW}%s${OFF}%s${BWHITE}%s${OFF}\n" \
	"[monero-bash] " \
	"exit signal caught " \
	"| " \
	"updating local state"
	sudo sed \
		-i -e "s/${PKG[var]}_VER=./${PKG[var]}_VER=/" "$STATE" \
		-i -e "s/${PKG[var]}_OLD=./${PKG[var]}_OLD=\"true\"/" "$STATE"
}
update() {
	log::debug "starting ${FUNCNAME}()"
	trap 'tmp::remove; lock::free monero_bash_update' EXIT
	lock::alloc "monero_bash_update"
	tmp::info
	local UPDATE_FOUND INFO HTML
	declare -a SCRATCH
	print::update
	struct::pkg bash
	log::debug "starting download thread for: ${PKG[pretty]}"
	if ! $DOWNLOAD_CMD "${TMP_INFO[bash]}" "${PKG[link_api]}"; then
		HTML_MODE=true
		printf "${BRED}%s${OFF}%s${BYELLOW}%s${OFF}\n" \
			"GitHub API failure " \
			"| " \
			"Switching to HTML filter mode..."
		if ! $DOWNLOAD_CMD "${TMP_INFO[bash]}" "${PKG[link_html]}"; then
			print::exit "Update failure - could not connect to GitHub"
		fi
	fi
	if [[ $HTML_MODE = true ]]; then
		SCRATCH=($(grep -o -m 1 "/${PKG[author]}/${PKG[name]}/releases/tag/.*\"" "${TMP_INFO[bash]}"))
		INFO="${SCRATCH[0]}"
		INFO="${INFO//*tag\/}"
		INFO="${INFO//\"}"
	else
		INFO="$(grep -m1 "tag_name" "${TMP_INFO[bash]}")"
		INFO="${INFO//*: }"
		INFO="${INFO//\"}"
		INFO="${INFO//,}"
	fi
	if [[ $MONERO_BASH_VER = "${INFO}" ]]; then
		printf "${BWHITE}%s${BGREEN}%s\n" \
			"monero-bash | " "$MONERO_BASH_VER"
	else
		sed -i "s/MONERO_BASH_OLD=.*/MONERO_BASH_OLD=true/" "$STATE"
		UPDATE_FOUND=true
		printf "${BWHITE}%s${BRED}%s${BWHITE}%s${BGREEN}%s\n" \
			"monero-bash | " "$MONERO_BASH_VER " "-> " "$INFO"
	fi
	if [[ $MONERO_VER ]]; then
		struct::pkg monero
		log::debug "starting download thread for: ${PKG[pretty]}"
		if [[ $HTML_MODE = true ]]; then
			$DOWNLOAD_CMD "${TMP_INFO[monero]}" "${PKG[link_html]}" &
		else
			$DOWNLOAD_CMD "${TMP_INFO[monero]}" "${PKG[link_api]}" &
		fi
	fi
	if [[ $P2POOL_VER ]]; then
		struct::pkg p2pool
		log::debug "starting download thread for: ${PKG[pretty]}"
		if [[ $HTML_MODE = true ]]; then
			$DOWNLOAD_CMD "${TMP_INFO[p2pool]}" "${PKG[link_html]}" &
		else
			$DOWNLOAD_CMD "${TMP_INFO[p2pool]}" "${PKG[link_api]}" &
		fi
	fi
	if [[ $XMRIG_VER ]]; then
		struct::pkg xmrig
		log::debug "starting download thread for: ${PKG[pretty]}"
		if [[ $HTML_MODE = true ]]; then
			$DOWNLOAD_CMD "${TMP_INFO[xmrig]}" "${PKG[link_html]}" &
		else
			$DOWNLOAD_CMD "${TMP_INFO[xmrig]}" "${PKG[link_api]}" &
		fi
	fi
	local JOB_LIST=$(jobs -p)
	if [[ $JOB_LIST ]]; then
		log::debug "waiting for download threads to complete"
		if ! wait -n; then
			print::exit "Update failure - could not connect to GitHub"
		fi
	fi
	if [[ $MONERO_VER ]]; then
		struct::pkg monero
		if [[ $HTML_MODE = true ]]; then
			SCRATCH=($(grep -o -m 1 "/${PKG[author]}/${PKG[name]}/releases/tag/.*\"" "${TMP_INFO[monero]}"))
			INFO="${SCRATCH[0]}"
			INFO="${INFO//*tag\/}"
			INFO="${INFO//\"}"
		else
			INFO="$(grep -m1 "tag_name" "${TMP_INFO[monero]}")"
			INFO="${INFO//*: }"
			INFO="${INFO//\"}"
			INFO="${INFO//,}"
		fi
		if [[ $MONERO_VER = "${INFO}" ]]; then
			printf "${BWHITE}%s${BGREEN}%s\n" \
				"Monero      | " "$MONERO_VER"
		else
			sed -i "s/MONERO_OLD=.*/MONERO_OLD=true/" "$STATE"
			UPDATE_FOUND=true
			printf "${BWHITE}%s${BRED}%s${BWHITE}%s${BGREEN}%s\n" \
				"Monero      | " "$MONERO_VER " "-> " "$INFO"
		fi
	fi
	if [[ $P2POOL_VER ]]; then
		struct::pkg p2pool
		if [[ $HTML_MODE = true ]]; then
			SCRATCH=($(grep -o -m 1 "/${PKG[author]}/${PKG[name]}/releases/tag/.*\"" "${TMP_INFO[p2pool]}"))
			INFO="${SCRATCH[0]}"
			INFO="${INFO//*tag\/}"
			INFO="${INFO//\"}"
		else
			INFO="$(grep -m1 "tag_name" "${TMP_INFO[p2pool]}")"
			INFO="${INFO//*: }"
			INFO="${INFO//\"}"
			INFO="${INFO//,}"
		fi
		if [[ $P2POOL_VER = "${INFO}" ]]; then
			printf "${BWHITE}%s${BGREEN}%s\n" \
				"P2Pool      | " "$P2POOL_VER"
		else
			sed -i "s/P2POOL_OLD=.*/P2POOL_OLD=true/" "$STATE"
			UPDATE_FOUND=true
			printf "${BWHITE}%s${BRED}%s${BWHITE}%s${BGREEN}%s\n" \
				"P2Pool      | " "$P2POOL_VER " "-> " "$INFO"
		fi
	fi
	if [[ $XMRIG_VER ]]; then
		struct::pkg xmrig
		if [[ $HTML_MODE = true ]]; then
			SCRATCH=($(grep -o -m 1 "/${PKG[author]}/${PKG[name]}/releases/tag/.*\"" "${TMP_INFO[xmrig]}"))
			INFO="${SCRATCH[0]}"
			INFO="${INFO//*tag\/}"
			INFO="${INFO//\"}"
		else
			INFO="$(grep -m1 "tag_name" "${TMP_INFO[xmrig]}")"
			INFO="${INFO//*: }"
			INFO="${INFO//\"}"
			INFO="${INFO//,}"
		fi
		if [[ $XMRIG_VER = "${INFO}" ]]; then
			printf "${BWHITE}%s${BGREEN}%s\n" \
				"XMRig       | " "$XMRIG_VER"
		else
			sed -i "s/XMRIG_OLD=.*/XMRIG_OLD=true/" "$STATE"
			UPDATE_FOUND=true
			printf "${BWHITE}%s${BRED}%s${BWHITE}%s${BGREEN}%s\n" \
				"XMRig       | " "$XMRIG_VER " "-> " "$INFO"
		fi
	fi
	if [[ $UPDATE_FOUND ]]; then
		echo
		printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
			"Updates found, type: " \
			"[monero-bash upgrade] " \
			"to upgrade all packages"
		printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
			"Or type: " \
			"[monero-bash <package>] " \
			"to upgrade a specific package"
	else
		print::updated
	fi
	log::debug "update() finished"
	return 0
}
upgrade() {
	[[ $OPTION_VERBOSE = true ]] && STD_LOG_DEBUG=true
	log::debug "starting ${FUNCNAME}()"
	if [[ $UPGRADE_LIST ]]; then
		log::debug "packages getting upgraded: $UPGRADE_LIST"
	elif [[ $INSTALL_LIST ]]; then
		log::debug "packages getting installed: $UPGRADE_LIST"
	fi
	trap 'trap::pkg_folders &' EXIT
	tmp::pkg_folders
	print::download
	download
}
parse::config() {
	log::debug "starting ${FUNCNAME}()"
	local i IFS=$'\n' CONFIG_ARRAY || return 1
	mapfile CONFIG_ARRAY < "$CONFIG_MONERO_BASH" || return 2
	for i in "${CONFIG_ARRAY[@]}"; do
		[[ $i =~ ^AUTO_START_MONEROD=true[[:space:]]+$ ]] && declare -g AUTO_START_MONEROD="true" || declare -g AUTO_START_MONEROD="false"
		[[ $i =~ ^AUTO_STOP_MONEROD=true[[:space:]]+$ ]]  && declare -g AUTO_STOP_MONEROD="true"  || declare -g AUTO_STOP_MONEROD="false"
		[[ $i =~ ^AUTO_UPDATE=true[[:space:]]+$ ]]        && declare -g AUTO_UPDATE="true"        || declare -g AUTO_UPDATE="false"
		[[ $i =~ ^RPC_IP=*$ ]]                            && declare -g RPC_IP="${i/*=/}"
		[[ $i =~ ^RPC_VERBOSE=true[[:space:]]+$ ]]        && declare -g RPC_VERBOSE="true" || declare -g RPC_VERBOSE="false"
		[[ $i =~ ^MONERO_BASH_DEBUG=true[[:space:]]+$ ]]  && declare -g STD_LOG_DEBUG="true"
		[[ $i =~ ^MONERO_BASH_DEBUG_VERBOSE=true[[:space:]]+$ ]] && declare -g STD_LOG_DEBUG_VERBOSE="true"
	done
	log::debug "--- monero-bash.conf settings ---"
	log::debug "AUTO_START_MONEROD        | $AUTO_START_MONEROD"
	log::debug "AUTO_STOP_MONEROD         | $AUTO_STOP_MONEROD"
	log::debug "AUTO_UPDATE               | $AUTO_UPDATE"
	log::debug "RPC_IP                    | $RPC_IP"
	log::debug "RPC_VERBOSE               | $RPC_VERBOSE"
	log::debug "MONERO_BASH_DEBUG         | $STD_LOG_DEBUG"
	log::debug "MONERO_BASH_DEBUG_VERBOSE | $STD_LOG_DEBUG_VERBOSE"
}
parse::options() {
log::debug "starting ${FUNCNAME}"
log::debug "user input: $*"
log::debug "unsetting OPTION variables"
unset -v OPTION_BASH OPTION_MONERO OPTION_P2POOL OPTION_XMRIG OPTION_VERBOSE OPTION_FORCE
until [[ $# = 0 ]]; do
case "$1" in
	new)       wallet::create  ;exit;;
	rpc)       rpc::daemon "$@";exit;;
	list)      wallet::list    ;exit;;
	help)      print::help     ;exit;;
	size)      print::size     ;exit;;
	config)    config          ;exit;;
	status)    status          ;exit;;
	version)   print::version  ;exit;;
	uninstall) monero_bash::uninstall; exit;;
	update)
		___BEGIN___ERROR___TRACE___
		update
		___ENDOF___ERROR___TRACE___
		exit
		;;
	install)
		shift
		if [[ $# = 0 ]]; then
			print::error "Pick one/multiple packages"
			print::version
			exit 1
		fi
		until [[ $# = 0 ]]; do
		case "$1" in
			*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
			monero|Monero|MONERO) OPTION_MONERO=true;;
			*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
			*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
			--verbose|-v)         OPTION_VERBOSE=true;;
			*)
				print::error "Invalid option: $1"
				print::error "Pick one/multiple packages"
				print::version
				exit 1
				;;
		esac
		shift
		done
		___BEGIN___ERROR___TRACE___
		install::prompt
		___ENDOF___ERROR___TRACE___
		exit
		;;
	remove)
		shift
		if [[ $# = 0 ]]; then
			print::error "Pick one/multiple packages"
			print::version
			exit 1
		fi
		until [[ $# = 0 ]]; do
		case "$1" in
			*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
			monero|Monero|MONERO) OPTION_MONERO=true;;
			*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
			*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
			*)
				print::error "Invalid option: $1"
				print::error "Pick one/multiple packages"
				print::version
				exit 1
				;;
		esac
		shift
		done
		___BEGIN___ERROR___TRACE___
		remove::prompt
		___ENDOF___ERROR___TRACE___
		exit
		;;
	upgrade)
		shift
		if [[ $# = 0 ]]; then
			print::error "Pick one/multiple packages"
			print::version
			exit 1
		fi
		until [[ $# = 0 ]]; do
		case "$1" in
			*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
			monero|Monero|MONERO) OPTION_MONERO=true;;
			*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
			*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
			--force|-f)           OPTION_FORCE=true;;
			--verbose|-v)         OPTION_VERBOSE=true;;
			*)
				print::error "Invalid option: $1"
				print::error "Pick one/multiple packages"
				print::version
				exit 1
				;;
		esac
		shift
		done
		___BEGIN___ERROR___TRACE___
		upgrade::prompt
		___ENDOF___ERROR___TRACE___
		exit
		;;
	start)
		shift
		until [[ $# = 0 ]]; do
		case "$1" in
			*bash*)       OPTION_BASH=true;;
			monero)       OPTION_MONERO=true;;
			*p2p*)        OPTION_P2POOL=true;;
			*xmr*)        OPTION_XMRIG=true;;
			"") print::error "Pick one/multiple processes: [monerod/p2pool/xmrig]"; exit 1;;
			*)            break;;
		esac
		shift
		done
		process::start
		exit
		;;
	stop)
		shift
		until [[ $# = 0 ]]; do
		case "$1" in
			*bash*)       OPTION_BASH=true;;
			monero)       OPTION_MONERO=true;;
			*p2p*)        OPTION_P2POOL=true;;
			*xmr*)        OPTION_XMRIG=true;;
			"") print::error "Pick one/multiple processes: [monerod/p2pool/xmrig]"; exit 1;;
			*)            break;;
		esac
		shift
		done
		process::stop
		exit
		;;
	kill)
		shift
		until [[ $# = 0 ]]; do
		case "$1" in
			*bash*)       OPTION_BASH=true;;
			monero)       OPTION_MONERO=true;;
			*p2p*)        OPTION_P2POOL=true;;
			*xmr*)        OPTION_XMRIG=true;;
			"") print::error "Pick one/multiple processes: [monerod/p2pool/xmrig]"; exit 1;;
			*)            break;;
		esac
		shift
		done
		process::kill
		exit
		;;
	restart)
		shift
		until [[ $# = 0 ]]; do
		case "$1" in
			*bash*)       OPTION_BASH=true;;
			monero)       OPTION_MONERO=true;;
			*p2p*)        OPTION_P2POOL=true;;
			*xmr*)        OPTION_XMRIG=true;;
			"") print::error "Pick one/multiple processes: [monerod/p2pool/xmrig]"; exit 1;;
			*)            break;;
		esac
		shift
		done
		process::restart
		exit
		;;
	full)
		shift
		[[ $# -gt 1 ]] && print::error "Pick one process: [monerod/p2pool/xmrig]"; exit 1
		case "$1" in
			*bash*)       OPTION_BASH=true;;
			monero)       OPTION_MONERO=true;;
			*p2p*)        OPTION_P2POOL=true;;
			*xmr*)        OPTION_XMRIG=true;;
			"") print::error "Pick one process: [monerod/p2pool/xmrig]"; exit 1;;
			*)            break;;
		esac
		process::full
		exit
		;;
	watch)
		shift
		until [[ $# = 0 ]]; do
		case "$1" in
			*bash*)       OPTION_BASH=true;;
			monero)       OPTION_MONERO=true;;
			*p2p*)        OPTION_P2POOL=true;;
			*xmr*)        OPTION_XMRIG=true;;
			"") print::error "Pick one/multiple processes: [monerod/p2pool/xmrig]"; exit 1;;
			*)            break;;
		esac
		shift
		done
		process::watch
		exit
		;;
	edit)
		shift
		until [[ $# = 0 ]]; do
		case "$1" in
			*bash*)       OPTION_BASH=true;;
			monero)       OPTION_MONERO=true;;
			*p2p*)        OPTION_P2POOL=true;;
			*xmr*)        OPTION_XMRIG=true;;
			"") print::error "Pick one/multiple to edit: [monerod/p2pool/xmrig]"; exit 1;;
			*)            break;;
		esac
		shift
		done
		process::edit
		exit
		;;
	reset)
		shift
		case "$1" in
			*bash*) struct::pkg bash;;
			monero) struct::pkg monero;;
			*p2p*)  struct::pkg p2pool;;
			*xmr*)  struct::pkg xmrig;;
			*) print::error "Pick one/multiple to reset: [monerod/p2pool/xmrig]"; exit 1;;
		esac
		process::reset_files
		exit
		;;
	changes)
		shift
		[[ $# = 0 ]] && print::changelog && exit
		until [[ $# = 0 ]]; do
			if declare -fp print::changelog::"${1/v}" &>/dev/null; then
				print::changelog::"${1/v}"
			else
				print::error "Version $1 does not exist/is not available"
			fi
			shift
		done
		exit
		;;
	*)
		log::debug "user input failed: $1"
		print::error "Invalid option!"
		print::exit "$(printf "${OFF}%s${BYELLOW}%s${OFF}\n" "For help, type: " "monero-bash help")"
		;;
esac
done
}
parse::p2pool() {
	log::debug "starting ${FUNCNAME}()"
	local i IFS=$'\n' CONFIG_ARRAY || return 1
	mapfile CONFIG_ARRAY < "$CONFIG_P2POOL" || return 2
	for i in "${CONFIG_ARRAY[@]}"; do
		[[ $i =~ ^P2POOL_WALLET=*$ ]]       && declare -g P2POOL_WALLET="${i/*=/}"
		[[ $i =~ ^P2POOL_HOST=*$ ]]         && declare -g P2POOL_HOST="${i/*=/}"
		[[ $i =~ ^P2POOL_RPC_PORT=*$ ]]     && declare -g P2POOL_RPC_PORT="${i/*=/}"
		[[ $i =~ ^P2POOL_ZMQ_PORT=*$ ]]     && declare -g P2POOL_ZMQ_PORT="${i/*=/}"
		[[ $i =~ ^P2POOL_STRATUM=*$ ]]      && declare -g P2POOL_STRATUM="${i/*=/}"
		[[ $i =~ ^P2POOL_P2P=*$ ]]          && declare -g P2POOL_P2P="${i/*=/}"
		[[ $i =~ ^P2POOL_ADD_PEERS=*$ ]]    && declare -g P2POOL_ADD_PEERS="${i/*=/}"
		[[ $i =~ ^P2POOL_LIGHT_MODE=*$ ]]   && declare -g P2POOL_LIGHT_MODE="${i/*=/}"
		[[ $i =~ ^P2POOL_CONFIG=*$ ]]       && declare -g P2POOL_CONFIG="${i/*=/}"
		[[ $i =~ ^P2POOL_LOG_LEVEL=*$ ]]    && declare -g P2POOL_LOG_LEVEL="${i/*=/}"
		[[ $i =~ ^P2POOL_DATA_API=*$ ]]     && declare -g P2POOL_DATA_API="${i/*=/}"
		[[ $i =~ ^P2POOL_LOCAL_API=*$ ]]    && declare -g P2POOL_LOCAL_API="${i/*=/}"
		[[ $i =~ ^P2POOL_NO_CACHE=*$ ]]     && declare -g P2POOL_NO_CACHE="${i/*=/}"
		[[ $i =~ ^P2POOL_NO_COLOR=*$ ]]     && declare -g P2POOL_NO_COLOR="${i/*=/}"
		[[ $i =~ ^P2POOL_NO_RANDOMX=*$ ]]   && declare -g P2POOL_NO_RANDOMX="${i/*=/}"
		[[ $i =~ ^P2POOL_OUT_PEERS=*$ ]]    && declare -g P2POOL_OUT_PEERS="${i/*=/}"
		[[ $i =~ ^P2POOL_IN_PEERS=*$ ]]     && declare -g P2POOL_IN_PEERS="${i/*=/}"
		[[ $i =~ ^P2POOL_START_MINING=*$ ]] && declare -g P2POOL_START_MINING="${i/*=/}"
		[[ $i =~ ^P2POOL_MINI=*$ ]]         && declare -g P2POOL_MINI="${i/*=/}"
		[[ $i =~ ^P2POOL_NO_AUTODIFF=*$ ]]  && declare -g P2POOL_NO_AUTODIFF="${i/*=/}"
		[[ $i =~ ^P2POOL_RPC_LOGIN=*$ ]]    && declare -g P2POOL_RPC_LOGIN="${i/*=/}"
	done
	[[ -z $P2POOL_HOST ]]             && declare -g P2POOL_HOST=127.0.0.1
	[[ -z $P2POOL_RPC_PORT ]]         && declare -g P2POOL_RPC_PORT=18081
	[[ -z $P2POOL_ZMQ_PORT ]]         && declare -g P2POOL_ZMQ_PORT=18083
	[[ $P2POOL_LIGHT_MODE != true ]]  && declare -g P2POOL_LIGHT_MODE=false
	[[ -z $P2POOL_LOG_LEVEL ]]        && declare -g P2POOL_LOG_LEVEL=2
	[[ $P2POOL_NO_CACHE != true ]]    && declare -g P2POOL_NO_CACHE=false
	[[ $P2POOL_NO_COLOR != true ]]    && declare -g P2POOL_NO_COLOR=false
	[[ $P2POOL_NO_RANDOMX != true ]]  && declare -g P2POOL_NO_RANDOMX=false
	[[ $P2POOL_MINI != true ]]        && declare -g P2POOL_MINI=false
	[[ $P2POOL_NO_AUTODIFF != true ]] && declare -g P2POOL_NO_AUTODIFF=false
	declare -g P2POOL_COMMAND || return 3
	P2POOL_COMMAND="--wallet $P2POOL_WALLET"
	P2POOL_COMMAND="$P2POOL_COMMAND --host $P2POOL_HOST"
	P2POOL_COMMAND="$P2POOL_COMMAND --rpc-port $P2POOL_RPC_PORT"
	P2POOL_COMMAND="$P2POOL_COMMAND --zmq-port $P2POOL_ZMQ_PORT"
	[[ $P2POOL_STRATUM ]]            && P2POOL_COMMAND="$P2POOL_COMMAND --stratum $P2POOL_STRATUM"
	[[ $P2POOL_P2P ]]                && P2POOL_COMMAND="$P2POOL_COMMAND --p2p $P2POOL_P2P"
	[[ $P2POOL_ADD_PEERS ]]          && P2POOL_COMMAND="$P2POOL_COMMAND --addpeers $P2POOL_ADD_PEERS"
	[[ $P2POOL_LIGHT_MODE = true ]]  && P2POOL_COMMAND="$P2POOL_COMMAND --light-mode"
	P2POOL_COMMAND="$P2POOL_COMMAND --loglevel $P2POOL_LOG_LEVEL"
	[[ $P2POOL_CONFIG ]]             && P2POOL_COMMAND="$P2POOL_COMMAND --config $P2POOL_CONFIG"
	[[ $P2POOL_DATA_API ]]           && P2POOL_COMMAND="$P2POOL_COMMAND --data-api $P2POOL_DATA_API"
	[[ $P2POOL_LOCAL_API ]]          && P2POOL_COMMAND="$P2POOL_COMMAND --local-api $P2POOL_LOCAL_API"
	[[ $P2POOL_NO_CACHE = true ]]    && P2POOL_COMMAND="$P2POOL_COMMAND --no-cache"
	[[ $P2POOL_NO_COLOR = true ]]    && P2POOL_COMMAND="$P2POOL_COMMAND --no-color"
	[[ $P2POOL_NO_RANDOMX = true ]]  && P2POOL_COMMAND="$P2POOL_COMMAND --no-randomx"
	[[ $P2POOL_OUT_PEERS ]]          && P2POOL_COMMAND="$P2POOL_COMMAND --out-peers $P2POOL_OUT_PEERS"
	[[ $P2POOL_IN_PEERS ]]           && P2POOL_COMMAND="$P2POOL_COMMAND --in-peers $P2POOL_IN_PEERS"
	[[ $P2POOL_START_MINING ]]       && P2POOL_COMMAND="$P2POOL_COMMAND --start-mining $P2POOL_START_MINING"
	[[ $P2POOL_MINI = true ]]        && P2POOL_COMMAND="$P2POOL_COMMAND --mini"
	[[ $P2POOL_NO_AUTODIFF = true ]] && P2POOL_COMMAND="$P2POOL_COMMAND --no-autodiff"
	[[ $P2POOL_RPC_LOGIN ]]          && P2POOL_COMMAND="$P2POOL_COMMAND --rpc-login $P2POOL_RPC_LOGIN"
	log::debug "--- p2pool.conf settings ---"
	log::debug "P2POOL_WALLET       | $P2POOL_WALLET"
	log::debug "P2POOL_HOST         | $P2POOL_HOST"
	log::debug "P2POOL_RPC_PORT     | $P2POOL_RPC_PORT"
	log::debug "P2POOL_ZMQ_PORT     | $P2POOL_ZMQ_PORT"
	log::debug "P2POOL_STRATUM      | $P2POOL_STRATUM"
	log::debug "P2POOL_P2P          | $P2POOL_P2P"
	log::debug "P2POOL_ADD_PEERS    | $P2POOL_ADD_PEERS"
	log::debug "P2POOL_LIGHT_MODE   | $P2POOL_LIGHT_MODE"
	log::debug "P2POOL_CONFIG       | $P2POOL_CONFIG"
	log::debug "P2POOL_LOG_LEVEL    | $P2POOL_LOG_LEVEL"
	log::debug "P2POOL_DATA_API     | $P2POOL_DATA_API"
	log::debug "P2POOL_LOCAL_API    | $P2POOL_LOCAL_API"
	log::debug "P2POOL_NO_CACHE     | $P2POOL_NO_CACHE"
	log::debug "P2POOL_NO_COLOR     | $P2POOL_NO_COLOR"
	log::debug "P2POOL_NO_RANDOMX   | $P2POOL_NO_RANDOMX"
	log::debug "P2POOL_OUT_PEERS    | $P2POOL_OUT_PEERS"
	log::debug "P2POOL_IN_PEERS     | $P2POOL_IN_PEERS"
	log::debug "P2POOL_START_MINING | $P2POOL_START_MINING"
	log::debug "P2POOL_MINI         | $P2POOL_MINI"
	log::debug "P2POOL_NO_AUTODIFF  | $P2POOL_NO_AUTODIFF"
	log::debug "P2POOL_RPC_LOGIN    | $P2POOL_RPC_LOGIN"
	log::debug "final p2pool command: $P2POOL_COMMAND"
	return 0
}
parse::state() {
	log::debug "starting ${FUNCNAME}()"
	local i IFS=$'\n' STATE_ARRAY || return 1
	mapfile STATE_ARRAY < "$STATE" || return 2
	for i in "${OPTIONS[@]}"; do
		[[ $i =~ ^FIRST_TIME=true[[:space:]]+$ ]]        && declare -g FIRST_TIME="true"
		[[ $i =~ ^MONERO_BASH_VER=*$ ]]                  && declare -g MONERO_BASH_VER="${i/*=/}"
		[[ $i =~ ^MONERO_VER=*$ ]]                       && declare -g MONERO_VER="${i/*=/}"
		[[ $i =~ ^P2POOL_VER=*$ ]]                       && declare -g P2POOL_VER="${i/*=/}"
		[[ $i =~ ^XMRIG_VER=*$ ]]                        && declare -g XMRIG_VER="${i/*=/}"
		[[ $i =~ ^MONERO_BASH_OLD=true[[:space:]]+$ ]]   && declare -g MONERO_BASH_OLD="true" || declare -g MONERO_BASH_OLD="false"
		[[ $i =~ ^MONERO_OLD=true[[:space:]]+$ ]]        && declare -g MONERO_OLD="true"      || declare -g MONERO_OLD="false"
		[[ $i =~ ^P2POOL_OLD=true[[:space:]]+$ ]]        && declare -g P2POOL_OLD="true"      || declare -g P2POOL_OLD="false"
		[[ $i =~ ^XMRIG_OLD=true[[:space:]]+$ ]]         && declare -g XMRIG_OLD="true"       || declare -g XMRIG_OLD="false"
	done
	[[ $FIRST_TIME != true ]]        && declare -g FIRST_TIME=false
	[[ $MONERO_BASH_OLD != true ]]   && declare -g MONERO_BASH_OLD=false
	[[ $MONERO_OLD != true ]]        && declare -g MONERO_OLD=false
	[[ $P2POOL_OLD != true ]]        && declare -g P2POOL_OLD=false
	[[ $XMRIG_OLD != true ]]         && declare -g XMRIG_OLD=false
	log::debug "--- state file ---"
	log::debug "FIRST_TIME        | $FIRST_TIME"
	log::debug "MINE_UNCONFIGURED | $MINE_UNCONFIGURED"
	log::debug "MONERO_BASH_VER   | $MONERO_BASH_VER"
	log::debug "MONERO_VER        | $MONERO_VER"
	log::debug "P2POOL_VER        | $P2POOL_VER"
	log::debug "XMRIG_VER         | $XMRIG_VER"
	log::debug "MONERO_BASH_OLD   | $MONERO_BASH_OLD"
	log::debug "MONERO_OLD        | $MONERO_OLD"
	log::debug "P2POOL_OLD        | $P2POOL_OLD"
	log::debug "XMRIG_OLD         | $XMRIG_OLD"
}
print::changelog::title() {
	log::debug "starting ${FUNCNAME}()"
	local CHANGELOG_TITLE CHANGELOG_RELEASE_DATE || return 1
	CHANGELOG_VERSION="$1"
	CHANGELOG_RELEASE_DATE="$2"
	printf "${BCYAN}%s\n" \
		"#==============================#" \
		"# monero-bash $CHANGELOG_VERSION changelog #" \
		"#==============================#" \
		"# RELEASE DATE | $CHANGELOG_RELEASE_DATE" \
		""
}
print::changelog() {
	print::changelog::2.0.0
}
print::changelog::2.0.0() {
	print::changelog::title "v2.0.0"
}
print::changelog::1.6.0() {
	print::changelog::title "v1.6.0" "July 2, 2022"
	printf "${BCYAN}%s\n" \
		"# Updates"
	printf "  ${BOLD}${BWHITE}%s\n" \
		"v1 END OF LIFE"
	printf "    ${OFF}%s\n" \
		"- monero-bash v2.0.0 in progress, a rewrite to make the code safer, faster, and easier to debug" \
		"- Major version upgrades (v1.X.X > v2.X.X) will include changes that break backwards compatability" \
		"- v1.X.X versions will still function, but you will not be able to upgrade monero-bash past v1.9.9" \
		""
	printf "${BCYAN}%s\n" \
		"# Fixes"
	printf "  ${BOLD}${BWHITE}%s\n    ${OFF}%s\n" \
		"systemd" "- Service file permission fix (700 > 600)" \
		"P2Pool"  "- Fetch PGP key from GitHub" \
		"Misc"    "- Fix text coloring issues"
}
print::compromised::hash() {
	log::debug "package hash error has occurred for: ${PKG[name]}"
	printf "${BWHITE}%s\n${BRED}%s\n${BRED}%s\n${BRED}%s\n${BRED}%s\n${BWHITE}%s\n" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		" WARNING: HASH ERROR!                       " \
		" [${PKG[pretty]}] hash did not match!       " \
		" [${PKG[author]}] might be compromised!     " \
		" (or more likely, there was an error)       " \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	printf "${BWHITE}%s${BBLUE}%s\n${BWHITE}%s${BRED}%s${OFF}\n" \
		"ONLINE HASH: " \
		"$HASH" \
		"LOCAL HASH: " \
		"$LOCAL_HASH"
	[[ $OPTION_VERBOSE = true ]] && print::verbose
	exit 1
}
print::compromised::gpg() {
	log::debug "package gpg error has occurred for: ${PKG[name]}"
	printf "${BWHITE}%s\n${BBLUE}%s\n${BBLUE}%s\n${BBLUE}%s\n${BBLUE}%s\n${BWHITE}%s\n" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		" WARNING: GPG ERROR!                       " \
		" [${PKG[pretty]}] GPG signature failed!     " \
		" [${PKG[gpg_owner]}] might be compromised!  " \
		" (or more likely, there was an error)       " \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	printf "${BWHITE}%s${BBLUE}%s\n${BWHITE}%s${BRED}%s\n${BWHITE}%s${BYELLOW}%s\n${OFF}%s\n" \
		"ONLINE HASH: " \
		"$HASH" \
		"LOCAL HASH: " \
		"$LOCAL_HASH" \
		"GPG SIGNATURE: " \
		"$GPG_SIG"
	[[ $OPTION_VERBOSE = true ]] && print::verbose
	exit 1
}
print::error() {
	until [[ $# = 0 ]]; do
		printf "${BRED}%s${OFF}%s\n" "[monero-bash error] " "$1"
		shift
	done
}
print::exit() {
	until [[ $# = 0 ]]; do
		printf "${BRED}%s${OFF}%s\n" "[monero-bash error] " "$1"
		shift
	done
	exit 1
}
print::help() {
	log::debug "starting ${FUNCNAME}()"
	printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s${BPURPLE}%s\n\n" \
		"USAGE: " "monero-bash " "[command] " "<argument> " "[--option]"
	printf "${BWHITE}%s${OFF}\n" "WALLET"
	printf "    ${OFF}%s\n" \
		"monero-bash                              Open interactive wallet menu" \
		"list                                     List wallets" \
		"new                                      Enter wallet creation mode"
	printf "\n${BWHITE}%s${OFF}\n" "PACKAGE"
	printf "    ${OFF}%s${BYELLOW}%s${BPURPLE}%s${OFF}%s\n" \
		"install " "<packages> " "[--verbose]           " "Install one/multiple packages"
	printf "    ${OFF}%s${BYELLOW}%s${OFF}%s\n" \
		"remove  " "<packages>                       " "Remove one/multiple packages"
	printf "    ${OFF}%s\n" \
		"update                                   Check for package updates"
	printf "    ${OFF}%s${BYELLOW}%s${BPURPLE}%s${OFF}%s\n" \
		"upgrade " "<packages> " "[--verbose|--force]   " "Upgrade pkgs, if none specified, upgrade all out-of-date pkgs"
	printf "\n${BWHITE}%s${OFF}\n" "PROCESS"
	printf "    ${OFF}%s${BYELLOW}%s${OFF}%s\n" \
		"full    " "<monerod/p2pool/xmrig>           " "Start process fully attached in foreground" \
		"start   " "<monerod/p2pool/xmrig>           " "Start process as systemd background process" \
		"stop    " "<monerod/p2pool/xmrig>           " "Gracefully stop systemd background process" \
		"kill    " "<monerod/p2pool/xmrig>           " "Forcefully kill systemd background process" \
		"restart " "<monerod/p2pool/xmrig>           " "Restart systemd background process" \
		"watch   " "<monerod/p2pool/xmrig>           " "Watch live output of systemd background process" \
		"edit    " "<monerod/p2pool/xmrig>           " "Edit systemd service file" \
		"reset   " "<bash/monerod/p2pool/xmrig>      " "Reset your config/systemd service file to default"
	printf "\n${BWHITE}%s${OFF}\n"    "STATS"
	printf "    %s\n" \
		"status                                   Print status of all running processes" \
		"size                                     Print size of all packages and folders" \
		"version                                  Print current package versions"
	printf "    ${OFF}%s${BYELLOW}%s${OFF}%s\n" \
		"changes " "<monero-bash version>            " "Print current/specified monero-bash changelog"
	printf "\n${BWHITE}%s${OFF}\n"    "RPC"
	printf "    ${OFF}%s${BYELLOW}%s${OFF}%s\n" \
		"rpc     " "<JSON-RPC method>                " "Send a JSON-RPC call to monerod"
	printf "\n${BWHITE}%s${OFF}\n"    "HELP"
	printf "    %s\n" \
		"help                                     Print this help message"
}
print::download() {
	printf "${BGREEN}%s${OFF}\n" "#---------# Downloading #---------#"
}
print::update() {
	printf "${BYELLOW}%s${OFF}\n" "#---------# Updating #---------#"
}
print::remove() {
	printf "${BRED}%s${OFF}\n" "#---------# Removing [${PKG[pretty]}] #---------#"
}
print::verify() {
	printf "${BYELLOW}%s${OFF}\n" "#---# Verifying #---#"
}
print::extract() {
	printf "${BRED}%s${OFF}\n" "#---# Extracting #---#"
}
print::state() {
	printf "${BBLUE}%s${OFF}\n" "#---# Updating local state #---#"
}
print::installed() {
	printf "${BGREEN}%s${OFF}\n" "#---------# Install done #---------#"
}
print::upgraded() {
	printf "${BGREEN}%s${OFF}\n" "#---------# Upgrade done #---------#"
}
print::removed() {
	printf "${BRED}%s${OFF}\n" "#---------# Removed [${PKG[pretty]}] #---------#"
}
print::updated() {
	printf "${BYELLOW}%s${OFF}\n" "#---------# All packages up-to-date #---------#"
}
print::size() {
	log::debug "starting ${FUNCNAME}()"
	log::debug "getting folder sizes"
	local SIZE_MONERO_BASH SIZE_MONERO SIZE_P2POOL SIZE_XMRIG SIZE_BITMONERO SIZE_DOT || return 1
	SIZE_MONERO_BASH=$(du -h "$PKG_MONERO_BASH")
	SIZE_MONERO=$(du -h "$PKG_MONERO")
	SIZE_P2POOL=$(du -h "$PKG_P2POOL")
	SIZE_XMRIG=$(du -h "$PKG_XMRIG")
	SIZE_DOT=$(du -h "$DOT")
	if [[ -d "$HOME/.bitmonero" ]]; then
		SIZE_BITMONERO=$(du -h "$HOME/.bitmonero")
	else
		SIZE_BITMONERO="not found"
	fi
	log::debug "printing folder sizes"
	printf "${BWHITE}%s${BYELLOW}%s\n" \
		"monero-bash    | " "${SIZE_MONERO_BASH/$'\t'*}" \
		"Monero         | " "${SIZE_MONERO/$'\t'*}" \
		"P2Pool         | " "${SIZE_P2POOL/$'\t'*}" \
		"XMRig          | " "${SIZE_XMRIG/$'\t'*}" \
		"/.bitmonero/   | " "${SIZE_BITMONERO/$'\t'*}" \
		"/.monero-bash/ | " "${SIZE_DOT/$'\t'*}"
	return 0
}
print::title() {
	log::debug "starting ${FUNCNAME}()"
	log::debug "seeding title rng"
	local TITLE_RANDOM
	TITLE_RANDOM=$RANDOM
	if [[ $TITLE_RANDOM -le 19660 ]]; then
			printf "${BRED}%s${OFF}\n" \
				"###################" \
				"#   monero-bash   #" \
				"###################"
		log::debug "title luck: common 60%"
	elif [[ $TITLE_RANDOM -le 29490 ]]; then
			printf "${BBLUE}%s${OFF}\n" \
				"xxxxxxxxxxxxxxxxxxx" \
				"x   monero-bash   x" \
				"xxxxxxxxxxxxxxxxxxx"
		log::debug "title luck: rare 30%"
	elif [[ $TITLE_RANDOM -le 32439 ]]; then
			printf "${BPURPLE}%s${OFF}\n" \
				":::::::::::::::::::" \
				":   monero-bash   :" \
				":::::::::::::::::::"
		log::debug "title luck: ultra 9%"
	elif [[ $TITLE_RANDOM -le 32766 ]]; then
			printf "${BYELLOW}%s${OFF}\n" \
				"///////////////////" \
				"/   monero-bash   /" \
				"///////////////////"
		log::debug "title luck: legendary 0.99%"
	else
		printf "${BGREEN}%s${OFF}\n" \
			"###################" \
			"#   monero-bash   #" \
			"###################"
		log::debug "title luck: lottery 0.0030519%"
	fi
}
print::version() {
	log::debug "starting ${FUNCNAME}()"
	printf "${BWHITE}%s" \
		"monero-bash | "
	if [[ $MONERO_BASH_OLD = true ]]; then
		printf "${BRED}%s\n" "$MONERO_BASH_VER"
	else
		printf "${BGREEN}%s\n" "$MONERO_BASH_VER"
	fi
	printf "${BWHITE}%s" \
		"Monero      | "
	if [[ $MONERO_OLD = true ]]; then
		printf "${BRED}%s\n" "$MONERO_VER"
	else
		printf "${BGREEN}%s\n" "$MONERO_VER"
	fi
	printf "${BWHITE}%s" \
		"P2Pool      | "
	if [[ $P2POOL_OLD = true ]]; then
		printf "${BRED}%s\n" "$P2POOL_VER"
	else
		printf "${BGREEN}%s\n" "$P2POOL_VER"
	fi
	printf "${BWHITE}%s" \
		"XMRig       | "
	if [[ $XMRIG_OLD = true ]]; then
		printf "${BRED}%s\n" "$XMRIG_VER"
	else
		printf "${BGREEN}%s\n" "$XMRIG_VER"
	fi
	printf "${OFF}%s"
}
process::reset_files() {
	log::debug "starting ${FUNCNAME}()"
	if [[ -z ${PKG[version]} ]]; then
		print::exit "${PKG[pretty]} is not installed"
	fi
	case "${PKG[name]}" in
		*bash*)
			printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
				"This will overwrite your current " \
				"[${PKG[pretty]}] " \
				"config with a new default version"
			;;
		*)
			printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
				"This will overwrite your current " \
				"[${PKG[pretty]}] " \
				"config & systemd service files with new default versions"
			;;
	esac
	printf "${BWHITE}%s${OFF}" "Continue? (y/N) "
	if ask::no; then
		print::exit "Canceling reset"
	fi
	if ! ask::sudo; then
		print::exit "sudo is required"
	fi
	case "${PKG[name]}" in
		*bash*)
			cp -f "$PKG_MONERO_BASH/config/monero-bash.conf" "$CONFIG"
			;;
		monero)
			cp -f "$PKG_MONERO_BASH/config/monerod.conf" "$CONFIG"
			cp -f "$PKG_MONERO_BASH/config/monero-wallet-cli.conf" "$CONFIG"
			systemd::create
			systemd::reload
			;;
		p2pool)
			cp -f "$PKG_MONERO_BASH/config/p2pool.conf" "$CONFIG"
			systemd::create
			systemd::reload
			;;
		xmrig)
			cp -f "$PKG_MONERO_BASH/config/xmrig.json" "$CONFIG"
			systemd::create
			systemd::reload
			;;
	esac
	return 0
}
safety::path() {
	log::debug "starting ${FUNCNAME}()"
	local SAFETY_PATH
	SAFETY_PATH="$(realpath $0)"
	log::debug "realpath: $SAFETY_PATH"
	if [[ $SAFETY_PATH = "$MAIN" ]]; then
		log::debug "current path = $MAIN"
	else
		log::debug "incorrect path detected: $SAFETY_PATH"
		print::error "[monero-bash] is outside of $DOT!"
		print::exit  "Exiting for safety..."
	fi
}
safety::pipe() {
	log::debug "starting ${FUNCNAME}()"
	if [[ -p /dev/stdin ]]; then
		print::error "Pipe detected. [monero-bash] does not support pipes!"
		print::exit  "Exiting for safety..."
	fi
}
safety::pkg() {
	log::debug "starting ${FUNCNAME}()"
	[[ $1 ]] || return 1
	struct::pkg "$1" || return 2
	if [[ ${PKG[current_version]} ]]; then
		log::debug "${PKG[pretty]} (${PKG[current_version]}) is installed"
	else
		print::exit "${PKG[pretty]} is not installed"
	fi
	case "${PKG[name]}" in
		*bash*)   [[ -e $PKG_MONERO_BASH/monero-bash ]] || print::exit "monero-bash not found, this error should be impossible!";;
		*monero*)
			[[ -e $PKG_MONERO/monerod ]]                || print::exit "monerod binary was not found!"
			[[ -e $PKG_MONERO/monero-wallet-cli ]]      || print::exit "monero-wallet-cli binary was not found!"
			;;
		*p2p*)    [[ -e $PKG_P2POOL/p2pool ]]           || print::exit "P2Pool binary was not found!";;
		*xmr*)    [[ -e $PKG_XMRIG/xmrig ]]             || print::exit "XMRig binary was not found!";;
	esac
	return 0
}
safety::root() {
	log::debug "starting ${FUNCNAME}()"
	log::debug "running as: $EUID"
	if [[ $EUID = 0 ]]; then
		print::error "Running as root is not recommended"
		print::exit  "Exiting for safety..."
	fi
}
safety::wget_curl() {
	log::debug "starting ${FUNCNAME}()"
	char DOWNLOAD_CMD
	if hash curl &>/dev/null; then
		DOWNLOAD_CMD="curl --silent -o"
		log::debug "curl found, DOWNLOAD_CMD: $DOWNLOAD_CMD"
	elif hash wget &>/dev/null; then
		DOWNLOAD_CMD="wget --quiet -o"
		log::debug "wget found, DOWNLOAD_CMD: $DOWNLOAD_CMD"
	fi
	const::char DOWNLOAD_CMD
	if [[ -z $DOWNLOAD_CMD ]]; then
		print::error "both [wget] and [curl] were not found!"
		print::error "monero-bash needs at least one to be installed"
		print::exit  "Exiting for safety..."
	else
		return 0
	fi
}
status::table() {
	log::debug "creating status table"
	printf "${OFF}%s\n" \
		"#-----------------------------------------------#" \
		"# monero-bash |   Monero   |  P2Pool  |  XMRig  #" \
		"#-----------------------------------------------#" \
		"# $MONERO_BASH_VER | $MONERO_VER | $P2POOL_VER | $XMRIG_VER #" \
		"#-----------------------------------------------#" \
		"#"
}
struct::pkg() {
	log::debug "creating struct::pkg() for: $1"
	declare -Ag PKG
	[[ $# != 1 ]] && return 1
	case "$1" in
	monero)
		PKG[name]="monero"
		PKG[pretty]="Monero"
		PKG[var]="MONERO"
		PKG[author]="monero-project"
		PKG[gpg_owner]="binaryFate"
		PKG[service]="monero-bash-monerod.service"
		PKG[process]="monerod"
		PKG[directory]="$PACKAGES/monero"
		PKG[regex]="monero-linux-x64.*"
		PKG[hash]="hashes.txt"
		PKG[signature]="${PKG[hash]}"
		PKG[gpg_pub_key]="https://raw.githubusercontent.com/monero-project/monero/master/utils/gpg_keys/binaryfate.asc"
		PKG[gpg_fingerprint]="81AC591FE9C4B65C5806AFC3F0AF4D462A0BDF92"
		PKG[current_version]="$MONERO_VER"
		PKG[old]="$MONERO_OLD"
		;;
	*bash*)
		PKG[name]="monero-bash"
		PKG[pretty]="monero-bash"
		PKG[var]="MONERO_BASH"
		PKG[author]="hinto-janaiyo"
		PKG[gpg_owner]="hinto-janaiyo"
		PKG[service]=
		PKG[process]=
		PKG[directory]="$PACKAGES/monero-bash"
		PKG[regex]="monero-bash-v.*"
		PKG[hash]="SHA256SUM"
		PKG[signature]="${PKG[hash]}"
		PKG[gpg_pub_key]="https://raw.githubusercontent.com/hinto-janaiyo/monero-bash/master/gpg/hinto-janaiyo.asc"
		PKG[gpg_fingerprint]="21958EE945980282FCB849C8D7483F6CA27D1B1D"
		PKG[current_version]="$MONERO_BASH_VER"
		PKG[old]="$MONERO_BASH_OLD"
		;;
	*p2p*)
		PKG[name]="p2pool"
		PKG[pretty]="P2Pool"
		PKG[var]="P2POOL"
		PKG[author]="SChernykh"
		PKG[gpg_owner]="SChernykh"
		PKG[service]="monero-bash-p2pool.service"
		PKG[process]="p2pool"
		PKG[directory]="$PACKAGES/p2pool"
		PKG[regex]="p2pool.*linux-x64.*"
		PKG[hash]="sha256sums.txt.asc"
		PKG[signature]="${PKG[hash]}"
		PKG[gpg_pub_key]="https://raw.githubusercontent.com/monero-project/gitian.sigs/master/gitian-pubkeys/SChernykh.asc"
		PKG[gpg_fingerprint]="1FCAAB4D3DC3310D16CBD508C47F82B54DA87ADF"
		PKG[current_version]="$P2POOL_VER"
		PKG[old]="$P2POOL_OLD"
		;;
	*xmr*)
		PKG[name]="xmrig"
		PKG[pretty]="XMRig"
		PKG[var]="XMRIG"
		PKG[author]="XMRig"
		PKG[gpg_owner]="XMRig"
		PKG[service]="monero-bash-xmrig.service"
		PKG[process]="xmrig"
		PKG[directory]="$PACKAGES/xmrig"
		PKG[regex]="xmrig.*linux-static-x64.*"
		PKG[hash]="SHA256SUMS"
		PKG[signature]="${PKG[hash]}.sig"
		PKG[gpg_pub_key]="https://raw.githubusercontent.com/xmrig/xmrig/master/doc/gpg_keys/xmrig.asc"
		PKG[gpg_fingerprint]="9AC4CEA8E66E35A5C7CDDC1B446A53638BE94409"
		PKG[current_version]="$XMRIG_VER"
		PKG[old]="$XMRIG_OLD"
		;;
	esac
	PKG[link_api]="https://api.github.com/repos/${PKG[author]}/${PKG[name]}/releases/latest"
	PKG[link_html]="https://github.com/${PKG[author]}/${PKG[name]}/releases/latest"
}
systemd::create() {
	log::debug "starting ${FUNCNAME}()"
	umask 133 || return 1
	local TMP_SERVICE SYSTEMD_USER SYSTEMD_EXEC SYSTEMD_DIRECTORY || return 2
	TMP_SERVICE=$(mktemp "/tmp/${PKG[service]}.XXXXXXXXXX")
	case "${PKG[name]}" in
		monero)
			SYSTEMD_USER=monero-bash
			SYSTEMD_ENV="$CONFIG_MONERO_BASH"
			SYSTEMD_EXEC="monerod --config-file $CONFIG_MONEROD --non-interactive"
			;;
		p2pool)
			SYSTEMD_USER=monero-bash
			SYSTEMD_ENV="$CONFIG_P2POOL"
			SYSTEMD_EXEC="$PKG_P2POOL/p2pool --wallet \$P2POOL_WALLET"
			;;
		xmrig)
			SYSTEMD_USER=root
			SYSTEMD_ENV=""
			SYSTEMD_EXEC="$PKG_XMRIG/xmrig --config $CONFIG_XMRIG --log-file=$PKG_XMRIG/xmrig.log"
			;;
	esac
cat << EOM >> "$TMP_SERVICE"
[Unit]
Description=${PKG[service]}
After=network-online.target
Wants=network-online.target
[Service]
User=$SYSTEMD_USER
Type=simple
EnvironmentFile="$SYSTEMD_ENV"
ExecStart=$SYSTEMD_EXEC
WorkingDirectory=${PKG[directory]}
Restart=always
RestartSec=5
[Install]
WantedBy=multi-user.target
EOM
	sudo mv "$TMP_SERVICE" "$SYSTEMD/${PKG[service]}" || return 3
	rm "$TMP_SERVICE"
	umask 0022
}
systemd::reload() {
	log::debug "starting ${FUNCNAME}()"
	sudo systemctl daemon-reload || return 1
}
wallet::create() {
	log::debug "starting ${FUNCNAME}()"
	char WALLET_TYPE WALLET_NAME
	while :; do
		while :; do
			echo
			printf "${BPURPLE}%s${OFF}%s${BRED}%s${OFF}\n" \
				"--generate-new-wallet         " "| " "[new]" \
				"--generate-from-view-key      " "| " "[view]" \
				"--restore-from-seed           " "| " "[seed]" \
				"--generate-from-json          " "| " "[json]" \
				"--generate-from-spend-key     " "| " "[spend]" \
				"--generate-from-device        " "| " "[device]" \
				"--generate-from-keys          " "| " "[private]" \
				"--generate-from-multisig-keys " "| " "[multisig]" \
				""
			printf "${BYELLOW}%s${OFF}" "Select which method to use: "
			read -r WALLET_TYPE
			case "$WALLET_TYPE" in
				--generate-new-wallet|*new*)           WALLET_TYPE=new;break;;
				--generate-from-view-key|*view*)       WALLET_TYPE=view;break;;
				--restore-from-seed|*seed*)            WALLET_TYPE=seed;break;;
				--generate-from-json|*json*)           WALLET_TYPE=json;break;;
				--generate-from-spend-key|*spend*)     WALLET_TYPE=spend;break;;
				--generate-from-device|*device*)       WALLET_TYPE=device;break;;
				--generate-from-keys|*private*)        WALLET_TYPE=private;break;;
				--generate-from-multisig-keys|*multi*) WALLET_TYPE=multisig;break;;
				*) print::error "Invalid method!"
			esac
		done
		printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}" \
			"Create wallet type: " \
			"[${WALLET_TYPE}]" \
			"? (Y/n) "
		if ask::yes; then
			break
		fi
	done
	while :; do
		printf "${BWHITE}%s${OFF}" "Wallet name: "
		read -r WALLET_NAME
		case "$WALLET_NAME" in
			"") print::error "Empty input";;
			*)  break;;
		esac
	done
	log::debug "creating wallet [$WALLET_NAME] with type [$WALLET_TYPE]"
	cd "$DOT"
	safety::package monero
	case "$WALLET_TYPE" in
	new)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-new-wallet "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	view)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-view-key "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	seed)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-new-wallet "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD" \
			--restore-from-seed
			;;
	json)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-json "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	spend)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-spend-key "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	device)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-device "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	private)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-keys "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	multisig)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-multisig-keys "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_MONEROD"
			;;
	esac
	return 0
}
wallet::list() {
	log::debug "starting ${FUNCNAME}()"
	char WALLET_LIST_ALL
	local WALLET_COUNT WALLET_LIST i
	WALLET_LIST_ALL=("$(ls "$WALLETS" | grep -v ".keys")")
	WALLET_COUNT="$(echo "${WALLET_LIST_ALL[@]}" | wc -l)"
	for i in ${WALLET_LIST_ALL[@]}; do
		WALLET_LIST="[${i}]  $WALLET_LIST"
	done
	printf "${BWHITE}%s${OFF}" "$WALLET_COUNT "
	if [[ $WALLET_COUNT = 1 ]]; then
		printf "%s\n" "wallet found"
	else
		printf "%s\n" "wallets found"
	fi
	if [[ $WALLET_COUNT = 0 ]]; then
		echo
	else
		printf "${BWHITE}%s${OFF}\n\n" "$WALLET_LIST"
	fi
	return 0
}
wallet::password() {
	log::debug "starting ${FUNCNAME}()"
	trap 'crypto::key::remove' EXIT
	crypto::key::create
	printf "${BWHITE}%s${OFF}" "Password: "
	read -s -r WALLET_PASSWORD
	WALLET_PASSWORD="$(crypto::encrypt "$WALLET_PASSWORD" "$(cat $CRYPTO_KEY)")"
}
wallet::select() {
	log::debug "starting ${FUNCNAME}()"
	___BEGIN___ERROR___TRACE___
	char WALLET_SELECTION
	local i
	while :; do
	printf "${BYELLOW}%s${OFF}%s${BRED}%s${OFF}%s" \
		"Select a wallet " \
		"or " \
		"[new]" \
		": "
	read -r WALLET_SELECTION
	for i in ${WALLET_LIST_ALL[@]}; do
		[[ $WALLET_SELECTION = "$i" ]] && break
	done
	case "$WALLET_SELECTION" in
		"$i") break;;
		new|New|NEW) break;;
		"")   print::error "Empty input";;
		*)    print::error "Wallet not found";;
	esac
	done
	if [[ $i = new || $i = New || $i = NEW ]]; then
		while :; do
			printf "${BWHITE}%s\n${BYELLOW}%s${OFF}%s${BRED}%s${OFF}" \
				"Wallet name is similar to option..." \
				"SELECT " \
				"or " \
				"CREATE? "
			local SELECT_CREATE
			read -r SELECT_CREATE
			case $SELECT_CREATE in
			select|Select|SELECT)
				printf "${BWHITE}%s${BRED}%s${OFF}\n" \
				"Selecting " \
				"[$WALLET_SELECTION]"
				wallet::password
				wallet::start
				exit
				;;
			create|Create|CREATE)
				printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
				"Creating a " \
				"[new] " \
				"wallet"
				wallet::create
				exit
				;;
			*) print::error "Invalid option!" ;;
			esac
		done
	fi
	case "$WALLET_SELECTION" in
		new|New|NEW)
			printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
			"Creating a " \
			"[new] " \
			"wallet"
			wallet::create
			exit
			;;
	esac
	wallet::password
	wallet::start
	___ENDOF___ERROR___TRACE___
	exit 0
}
wallet::start() {
	log::debug "starting wallet: $WALLET_SELECTION"
	safety::pkg monero
	cd "$DOT"
	if [[ $AUTO_START_MONEROD = true ]]; then
		struct::pkg monero
		process::start
	fi
	"$PKG_MONERO/monero-wallet-cli" \
		--wallet-file "$WALLETS/$WALLET_SELECTION" \
		--config-file "$CONFIG_MONEROD" \
		--password "$(crypto::decrypt "$WALLET_PASSWORD" "$(cat $CRYPTO_KEY)")"
	if [[ $AUTO_STOP_MONEROD = true ]]; then
		struct::pkg monero
		process::stop
	fi
	return 0
}
readonly DOT="$HOME/.monero-bash"
readonly CONFIG="$DOT/config"
readonly WALLETS="$DOT/wallets"
readonly PACKAGES="$DOT/packages"
readonly CONFIG_MONERO_BASH="$CONFIG/monero-bash.conf"
readonly CONFIG_MONEROD="$CONFIG/monerod.conf"
readonly CONFIG_WALLET="$CONFIG/monero-wallet-cli.conf"
readonly CONFIG_P2POOL="$CONFIG/p2pool.conf"
readonly CONFIG_XMRIG="$CONFIG/xmrig.json"
readonly PKG_MONERO_BASH="$PACKAGES/monero-bash"
readonly PKG_MONERO="$PACKAGES/monero"
readonly PKG_P2POOL="$PACKAGES/p2pool"
readonly PKG_XMRIG="$PACKAGES/xmrig"
readonly SRC="$PKG_MONERO_BASH/src"
readonly TXT="$SRC/txt"
readonly HASHLIST="$TXT/hashlist"
readonly STATE="$TXT/state"
readonly MAIN="$PKG_MONERO_BASH/monero-bash"
readonly SYSTEMD="/etc/systemd/system"
declare -frg crypto::key::create
declare -frg crypto::key::remove
declare -frg DEBUG
declare -frg monero_bash::install
declare -frg monero_bash::uninstall
declare -frg download
declare -frg info
declare -frg install::prompt
declare -frg upgrade::prompt
declare -frg remove::prompt
declare -frg remove
declare -frg tmp::pkg
declare -frg tmp::info
declare -frg tmp::remove
declare -frg trap::pkg_folders
declare -frg trap::remove
declare -frg update
declare -frg upgrade
declare -frg parse::config
declare -frg parse::options
declare -frg parse::p2pool
declare -frg parse::state
declare -frg print::changelog::title
declare -frg print::changelog
declare -frg print::changelog::2.0.0
declare -frg print::changelog::1.6.0
declare -frg print::compromised::hash
declare -frg print::compromised::gpg
declare -frg print::error
declare -frg print::exit
declare -frg print::help
declare -frg print::download
declare -frg print::update
declare -frg print::remove
declare -frg print::verify
declare -frg print::extract
declare -frg print::state
declare -frg print::installed
declare -frg print::upgraded
declare -frg print::removed
declare -frg print::updated
declare -frg print::size
declare -frg print::title
declare -frg print::version
declare -frg process::reset_files
declare -frg safety::path
declare -frg safety::pipe
declare -frg safety::pkg
declare -frg safety::root
declare -frg safety::wget_curl
declare -frg status::table
declare -frg struct::pkg
declare -frg systemd::create
declare -frg systemd::reload
declare -frg wallet::create
declare -frg wallet::list
declare -frg wallet::password
declare -frg wallet::select
declare -frg wallet::start
trap - ERR || exit 117
set +eo pipefail || exit 118

#-------------------------------------------------------------------------------- BEGIN MAIN
# This file is part of monero-bash - a wrapper for Monero, written in Bash
#
# Copyright (c) 2022 hinto.janaiyo <https://github.com/hinto-janaiyo>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


main() {
#----------------------------------------- main() START
#log::debug "main() started, log::debug initialization"
# allow for job control
set -m

##----------------------------------------- DEBUG
#[[ $1 = DEBUG ]] && DEBUG "$@"
#
##----------------------------------------- SAFETY
#log::debug "starting safety checks"
## check for gnu/linux
#safety::gnu_linux
## check for bash v5+
#safety::bash
## check for root
#safety::root
## check for pipe
#safety::pipe
## check for wget/curl
safety::wget_curl
#
##----------------------------------------- FIRST TIME INSTALLATION
#if [[ $FIRST_TIME = true ]]; then
#	log::debug "first time detected, starting installation"
#	monero_bash::install
#else
#	log::debug "first time = false, skipping installation"
#fi
#
##----------------------------------------- MORE SAFETY
## check for path
#safety::path
#
##----------------------------------------- PARSE USER CONFIG/STATE
#___BEGIN___ERROR___TRACE___
#parse::state
#parse::config
#___ENDOF___ERROR___TRACE___

#----------------------------------------- PARSE USER INPUT
[[ $# != 0 ]] && parse::options "$@"

#----------------------------------------- WALLET
# title
print::title

# auto update
[[ $AUTO_UPDATE = true ]] && update && echo

# print wallets
wallet::list

# select wallet
wallet::select

exit 0
}
main "$@"
#-------------------------------------------------------------------------------- ENDOF MAIN
