#!/usr/bin/env bash
#
# monero-bash - a wrapper for Monero, written in Bash
#
# Copyright (c) 2022 hinto.janaiyo | https://github.com/hinto-janaiyo
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Parts of this project are originally from:
# Copyright (c) 2019-2022, jtgrassie          | https://github.com/jtgrassie
# Copyright (c) 2014-2022, The Monero Project | https://github.com/monero-project/monero

#git <monero-bash/0cad9a9>
#nix <1659552642>
#hbc <e35ca7a>
#lib <stdlib/ask.sh/8038e38>
#lib <stdlib/const.sh/8038e38>
#lib <stdlib/crypto.sh/8038e38>
#lib <stdlib/date.sh/8038e38>
#lib <stdlib/debug.sh/8038e38>
#lib <stdlib/is.sh/8038e38>
#lib <stdlib/lock.sh/8038e38>
#lib <stdlib/log.sh/8038e38>
#lib <stdlib/math.sh/8038e38>
#lib <stdlib/panic.sh/8038e38>
#lib <stdlib/readonly.sh/8038e38>
#lib <stdlib/safety.sh/8038e38>
#lib <stdlib/trace.sh/8038e38>
#lib <stdlib/type.sh/8038e38>
#src <crypto/key.sh>
#src <debug.sh>
#src <monero_bash/install.sh>
#src <monero_bash/uninstall.sh>
#src <parse/config.sh>
#src <parse/options.sh>
#src <parse/p2pool.sh>
#src <parse/state.sh>
#src <pkg/download.sh>
#src <pkg/extract.sh>
#src <pkg/hook.sh>
#src <pkg/info.sh>
#src <pkg/prompt.sh>
#src <pkg/remove.sh>
#src <pkg/tmp.sh>
#src <pkg/trap.sh>
#src <pkg/update.sh>
#src <pkg/upgrade.sh>
#src <pkg/verify.sh>
#src <print/changes.sh>
#src <print/compromised.sh>
#src <print/eol.sh>
#src <print/error.sh>
#src <print/help.sh>
#src <print/pkg.sh>
#src <print/size.sh>
#src <print/title.sh>
#src <print/version.sh>
#src <process/reset_files.sh>
#src <readonly.sh>
#src <rpc.sh>
#src <safety/path.sh>
#src <safety/pipe.sh>
#src <safety/pkg.sh>
#src <safety/root.sh>
#src <safety/wget_curl.sh>
#src <status/monerod.sh>
#src <status/p2pool.sh>
#src <status/table.sh>
#src <status/xmrig.sh>
#src <struct/pkg.sh>
#src <systemd/create.sh>
#src <systemd/reload.sh>
#src <wallet/create.sh>
#src <wallet/list.sh>
#src <wallet/open.sh>
#src <wallet/password.sh>
#src <wallet/select.sh>
#src <wallet/start.sh>

#-------------------------------------------------------------------------------- BEGIN SAFETY
POSIXLY_CORRECT= || exit 90
\unset -f alias bg bind break builtin caller cd command compgen complete compopt continue declare dirs disown echo enable eval exec exit export false fc fg getopts hash help history jobs kill let local logout mapfile popd printf pushd pwd read readarray readonly return set shift shopt source suspend test times trap true type typeset ulimit umask unalias unset wait || exit 91
\unset -f arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp csplit cut date dd df dir dircolors dirname du echo env expand expr factor false fmt fold groups head hostid hostname id install join kill link ln logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm rmdir runcon seq shred shuf sleep sort split stat stdbuf stty sum tac tail tee test timeout touch tr true truncate tsort tty uname unexpand uniq unlink uptime users vdir wc who whoami yes || exit 92
\unalias -a || exit 93
unset POSIXLY_CORRECT || exit 94
unset -f . : [ || exit 95
set -eo pipefail || exit 96

#-------------------------------------------------------------------------------- BEGIN LIB
trap 'printf "%s\n" "@@@@@@ LIB PANIC @@@@@@" "[line] ${LINENO}" "[file] $0" "[code] $?";set +eo pipefail;trap - ERR;while :;do read;done;exit 112' ERR || exit 112
ask::yes() {
	local STD_ASK_REPONSE || return 44
	read -r STD_ASK_REPONSE
	case $STD_ASK_REPONSE in
		""|y|Y|yes|Yes|YES) return 0 ;;
		*) return 2 ;;
	esac
}
ask::no() {
	local STD_ASK_RESPONSE || return 44
	read -r STD_ASK_RESPONSE
	case $STD_ASK_RESPONSE in
		y|Y|yes|Yes|YES) return 2 ;;
		*) return 0 ;;
	esac
}
ask::sudo() {
	sudo -v
}
const::char() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="char not found: $i"; return 33; }
		declare -r -g "$i" || return 44
	done
	return 0
}
const::array() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="array not found: $i"; return 33; }
		declare -r -g -a "$i" || return 44
	done
	return 0
}
const::map() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="map not found: $i"; return 33; }
		declare -r -g -A "$i" || return 44
	done
	return 0
}
const::int() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		case "$i" in
			''|*[!0-9]*) { STD_TRACE_RETURN="not integer: $i"; return 33; } ;;
		esac
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="integer not found: $i"; return 44; }
		declare -r -g -i "$i" || return 55
	done
	return 0
}
const::bool() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="bool not found: $i"; return 33; }
		declare -r -g "$i" || return 44
	done
}
const::ref() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p "$i" &>/dev/null || { STD_TRACE_RETURN="ref not found: $i"; return 33; }
		declare -r -g -n "$i" || return 44
	done
	return 0
}
crypto::bytes() {
	[[ $# = 0 ]] && return 1
	head -c $1 /dev/random
}
crypto::num() {
	case $# in
		1) shuf -i 0-$1 -n 1; return;;
		2) shuf -i $1-$2 -n 1; return;;
		*) return 1;;
	esac
}
crypto::uuid() {
	local STD_CRYPTO_UUID || return 1
	mapfile STD_CRYPTO_UUID < /proc/sys/kernel/random/uuid
	printf "%s" ${STD_CRYPTO_UUID//$'\n'}
}
crypto::encrypt() {
	[[ $# != 2 ]] && return 1
	printf "%s\n" "$1" | gpg --batch --symmetric --armor --quiet --cipher-algo AES256 --passphrase "$2"
}
crypto::decrypt() {
	printf "%s\n" "$1" | gpg --batch --decrypt --quiet --passphrase "$2"
}
date::unix_translate() {
	if [[ -p /dev/stdin ]]; then
		local i || return 11
		for i in $(</dev/stdin); do
			date -d @"$i" || return 22
		done
		return 0
	fi
	[[ $# = 0 ]] && return 33
	while [[ $# != 0 ]]; do
		date -d @"$1" || return 44
		shift
	done
	return 0
}
date::unix() { printf "%s\n" "$EPOCHSECONDS" ;}
date::time() { date +"%T" ;}
date::calendar() { date +"%Y-%m-%d" ;}
date::now() { date +"%Y-%m-%d %T" ;}
date::year() { date +"%Y" ;}
date::month() { date +"%m" ;}
date::day() { date +"%d" ;}
date::hour() { date +"%H" ;}
date::minute() { date +"%M" ;}
date::second() { date +"%S" ;}
debug() {
	[[ $STD_DEBUG != true ]] && return 0
	trap 'STD_DEBUG_CMD="$BASH_COMMAND" STD_DEBUG_FUNC=(${BASH_LINENO[@]}) STD_DEBUG_CMD_NUM="$LINENO" STD_DEBUG_PIPE=(${PIPESTATUS[@]});debug::trap' DEBUG
}
debug::trap() {
	if [[ -z $STD_DEBUG_INIT ]]; then
		declare -g STD_DEBUG_INIT
		STD_DEBUG_INIT=${EPOCHREALTIME//./}
		printf "\r\e[2K\033[1;90m%s\033[1;93m%s\033[0m%s\033[1;93m%s" \
			"[debug 0.000000] " "[ \$_ ] " "${STD_DEBUG_CMD_NUM}: $STD_DEBUG_CMD " "-> "
		local f
		local i=1
		for f in ${STD_DEBUG_FUNC[@]-1}; do
			[[ $f = 0 ]] && break
			printf "\033[1;91m%s\033[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
			((i++))
		done
		printf "\033[0m\n"
		return
	fi
	local STD_DEBUG_ADJUSTED STD_DEBUG_DOT
	STD_DEBUG_ADJUSTED=$((${EPOCHREALTIME//./}-STD_DEBUG_INIT))
	case ${#STD_DEBUG_ADJUSTED} in
		1) STD_DEBUG_ADJUSTED=00000${STD_DEBUG_ADJUSTED//$'\n'};;
		2) STD_DEBUG_ADJUSTED=0000${STD_DEBUG_ADJUSTED//$'\n'};;
		3) STD_DEBUG_ADJUSTED=000${STD_DEBUG_ADJUSTED//$'\n'};;
		4) STD_DEBUG_ADJUSTED=00${STD_DEBUG_ADJUSTED//$'\n'};;
		5) STD_DEBUG_ADJUSTED=0${STD_DEBUG_ADJUSTED//$'\n'};;
	esac
	STD_DEBUG_DOT=$((${#STD_DEBUG_ADJUSTED}-6))
	if [[ $STD_DEBUG_DOT -eq 0 ]]; then
		printf "\r\e[2K\033[1;90m%s\033[1;93m%s\033[0m%s\033[1;93m%s" \
			"[debug 0.${STD_DEBUG_ADJUSTED}] " "[ \$_ ] " "${STD_DEBUG_CMD_NUM}: $STD_DEBUG_CMD " "-> "
	else
		printf "\r\e[2K\033[1;90m%s\033[1;93m%s\033[0m%s\033[1;93m%s" \
			"[debug ${STD_DEBUG_ADJUSTED:0:${STD_DEBUG_DOT}}.${STD_DEBUG_ADJUSTED:${STD_DEBUG_DOT}}] " \
			"[ \$_ ] " "${STD_DEBUG_CMD_NUM}: $STD_DEBUG_CMD " "-> "
	fi
	local f
	local i=1
	for f in ${STD_DEBUG_FUNC[@]-1}; do
		[[ $f = 0 ]] && break
		printf "\033[1;91m%s\033[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
		((i++))
	done
	printf "\033[0m\n"
}
is::int() {
	if [[ -p /dev/stdin ]]; then
		local i || return 11
		for i in $(</dev/stdin); do
			[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not integer: $i"; return 22; }
		done
		return 0
	fi
	[[ $# = 0 ]] && return 33
	local i || return 44
	for i in "$@"; do
		[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not integer: $i"; return 55; }
	done
}
is::int_pos() {
	if [[ -p /dev/stdin ]]; then
		local i || return 11
		for i in $(</dev/stdin); do
			[ $i -gt -1 ] &>/dev/null || { STD_TRACE_RETURN="not pos int: $i"; return 22; }
			[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not pos int: $i"; return 33; }
		done
		return 0
	fi
	[[ $# = 0 ]] && return 44
	local i || return 55
	for i in "$@"; do
		[ $i -gt -1 ] &>/dev/null || { STD_TRACE_RETURN="not pos int: $i"; return 66; }
		[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not pos int: $i"; return 77; }
	done
}
is::int_neg() {
	if [[ -p /dev/stdin ]]; then
		local i || return 11
		for i in $(</dev/stdin); do
			[ $i -lt 0 ] &>/dev/null || { STD_TRACE_RETURN="not neg int: $i"; return 22; }
			[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not neg int: $i"; return 33; }
		done
		return 0
	fi
	[[ $# = 0 ]] && return 44
	local i || return 55
	for i in "$@"; do
		[ $i -lt 0 ] &>/dev/null || { STD_TRACE_RETURN="not neg int: $i"; return 66; }
		[ $i -eq $i ] &>/dev/null || { STD_TRACE_RETURN="not neg int: $i"; return 77; }
	done
}
lock::alloc() {
	POSIXLY_CORRECT= || return 7
	\unset -f umask trap set return echo unset local return unalias mapfile command || return 8
	\unalias -a || return 9
	unset -v POSIXLY_CORRECT || return 10
	[[ $# = 0 ]] && return 11
	declare -g -A STD_LOCK_FILE || return 12
	set +f || return 13
	local i f || return 14
	for i in "$@"; do
		for f in /tmp/std_lock_"$i"_*; do
			[[ -e "$f" ]] && { STD_TRACE_RETURN="lock file found: $f"; return 15; }
		done
	done
	local STD_LOCK_UUID || return 22
	until [[ $# = 0 ]]; do
		mapfile STD_LOCK_UUID < /proc/sys/kernel/random/uuid || return 23
		STD_LOCK_UUID[0]=${STD_LOCK_UUID[0]//$'\n'/}
		STD_LOCK_UUID[0]=${STD_LOCK_UUID//-/}
		STD_LOCK_FILE[$1]="/tmp/std_lock_${1}_${STD_LOCK_UUID[0]}" || return 33
		local STD_DEFAULT_UMASK
		STD_DEFAULT_UMASK=$(umask)
		umask 177
		echo > "${STD_LOCK_FILE[$1]}" || return 44
		umask $STD_DEFAULT_UMASK
		shift || return 45
	done
}
lock::free() {
	POSIXLY_CORRECT= || return 7
	\unset -f true unset return rm command || return 8
	\unalias -a || return 9
	unset -v POSIXLY_CORRECT || return 10
	[[ $# = 0 ]] && return 11
	until [[ $# = 0 ]]; do
		if [[ $1 = '@' ]]; then
			command rm "${STD_LOCK_FILE[@]}" || true
			unset -v STD_LOCK_FILE || true
			return 0
		else
			command rm "${STD_LOCK_FILE[$1]}" || { STD_TRACE_RETURN="lock rm fail: ${STD_LOCK_FILE[$1]}"; return 22; }
			unset -v "STD_LOCK_FILE[$1]" || return 23
		fi
		shift
	done
}
log::ok() { printf "\r\e[2K\e[1;32m[  OK  ]\e[0m %s\n" "$@"; }
log::info() { printf "\r\e[2K\e[1;37m[ INFO ]\e[0m %s\n" "$@"; }
log::warn() { printf "\r\e[2K\e[1;33m[ WARN ]\e[0m %s\n" "$@"; }
log::fail() { printf "\r\e[2K\e[1;31m[ FAIL ]\e[0m %s\n" "$@"; }
log::danger() { printf "\r\e[2K\e[1;31m[DANGER]\e[0m %s\n" "$@"; }
log::tab() { printf "\r\e[2K\e[0m         %s\n" "$@"; }
log::prog() { printf "\r\e[2K\e[1;37m[ \e[0m....\e[1;37m ]\e[0m %s " "$@"; }
log::debug() {
	[[ $STD_LOG_DEBUG != true ]] && return 0
	if [[ $STD_LOG_DEBUG_LAST_FUNC != "${FUNCNAME[1]}" ]]; then
		declare -g STD_LOG_DEBUG_LAST_FUNC="${FUNCNAME[1]}"
		case "$STD_LOG_DEBUG_FUNC_COLOR" in
			"\e[1;91m") STD_LOG_DEBUG_FUNC_COLOR="\e[1;92m";;
			"\e[1;92m") STD_LOG_DEBUG_FUNC_COLOR="\e[1;93m";;
			"\e[1;93m") STD_LOG_DEBUG_FUNC_COLOR="\e[1;94m";;
			"\e[1;94m") STD_LOG_DEBUG_FUNC_COLOR="\e[1;95m";;
			"\e[1;95m") STD_LOG_DEBUG_FUNC_COLOR="\e[1;96m";;
			"\e[1;96m") STD_LOG_DEBUG_FUNC_COLOR="\e[1;97m";;
			*) STD_LOG_DEBUG_FUNC_COLOR="\e[1;91m";;
		esac
	fi
	if [[ -z $STD_LOG_DEBUG_INIT ]]; then
		declare -g STD_LOG_DEBUG_INIT
		STD_LOG_DEBUG_INIT=${EPOCHREALTIME//[!0-9]/}
		printf "\r\e[2K\e[1;90m%s${STD_LOG_DEBUG_FUNC_COLOR}%s\e[0m%s" "[log::debug 0.000000] " "${FUNCNAME[1]}() " "$* "
		if [[ $STD_LOG_DEBUG_VERBOSE = true ]]; then
			printf "\e[1;93m%s" "-> "
			local f i
			i=1
			for f in ${BASH_LINENO[@]}; do
				[[ $f = 0 ]] && break
				printf "\e[1;91m%s\e[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
				((i++))
			done
		fi
		printf "\e[0m\n"
		return
	fi
	local STD_LOG_DEBUG_ADJUSTED STD_LOG_DEBUG_DOT
	STD_LOG_DEBUG_ADJUSTED=$((${EPOCHREALTIME//[!0-9]/}-STD_LOG_DEBUG_INIT))
	case ${#STD_LOG_DEBUG_ADJUSTED} in
		1) STD_LOG_DEBUG_ADJUSTED=00000${STD_LOG_DEBUG_ADJUSTED};;
		2) STD_LOG_DEBUG_ADJUSTED=0000${STD_LOG_DEBUG_ADJUSTED};;
		3) STD_LOG_DEBUG_ADJUSTED=000${STD_LOG_DEBUG_ADJUSTED};;
		4) STD_LOG_DEBUG_ADJUSTED=00${STD_LOG_DEBUG_ADJUSTED};;
		5) STD_LOG_DEBUG_ADJUSTED=0${STD_LOG_DEBUG_ADJUSTED};;
	esac
	STD_LOG_DEBUG_DOT=$((${#STD_LOG_DEBUG_ADJUSTED}-6))
	if [[ $STD_LOG_DEBUG_DOT -eq 0 ]]; then
		printf "\r\e[2K\e[1;90m%s${STD_LOG_DEBUG_FUNC_COLOR}%s\e[0m%s" "[log::debug 0.${STD_LOG_DEBUG_ADJUSTED}] " "${FUNCNAME[1]}() " "$* "
	else
		printf "\r\e[2K\e[1;90m%s${STD_LOG_DEBUG_FUNC_COLOR}%s\e[0m%s" \
			"[log::debug ${STD_LOG_DEBUG_ADJUSTED:0:${STD_LOG_DEBUG_DOT}}.${STD_LOG_DEBUG_ADJUSTED:${STD_LOG_DEBUG_DOT}}] " "${FUNCNAME[1]}() " "$* "
	fi
	if [[ $STD_LOG_DEBUG_VERBOSE = true ]]; then
		printf "\e[1;93m%s" "-> "
		local f i
		i=1
		for f in ${BASH_LINENO[@]}; do
			[[ $f = 0 ]] && break
			printf "\e[1;91m%s\e[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
			((i++))
		done
	fi
	printf "\e[0m\n"
}
short::sum() { builtin echo "$1" | awk -M -v PREC=200 '{SUM+=$1}END{printf "%.3f\n", SUM }'; }
float::sum() { builtin echo "$1" | awk -M -v PREC=200 '{SUM+=$1}END{printf "%.7f\n", SUM }'; }
double::sum() { builtin echo "$1" | awk -M -v PREC=200 '{SUM+=$1}END{printf "%.15f\n", SUM }'; }
short::add() { builtin echo "$1" "$2" | awk -M -v PREC=200 '{printf "%.3f\n", $1 + $2 }'; }
float::add() { builtin echo "$1" "$2" | awk -M -v PREC=200 '{printf "%.7f\n", $1 + $2 }'; }
double::add() { builtin echo "$1" "$2" | awk -M -v PREC=200 '{printf "%.15f\n", $1 + $2 }'; }
short::sub() { builtin echo "$1" "$2" | awk -M -v PREC=200 '{printf "%.3f\n", $1 - $2 }'; }
float::sub() { builtin echo "$1" "$2" | awk -M -v PREC=200 '{printf "%.7f\n", $1 - $2 }'; }
double::sub() { builtin echo "$1" "$2" | awk -M -v PREC=200 '{printf "%.15f\n", $1 - $2 }'; }
short::mul() { builtin echo "$1" "$2" | awk -M -v PREC=200 '{printf "%.3f\n", $1 * $2 }'; }
float::mul() { builtin echo "$1" "$2" | awk -M -v PREC=200 '{printf "%.7f\n", $1 * $2 }'; }
double::mul() { builtin echo "$1" "$2" | awk -M -v PREC=200 '{printf "%.15f\n", $1 * $2 }'; }
short::div() { builtin echo "$1" "$2" | awk -M -v PREC=200 '{printf "%.3f\n", $1 / $2 }'; }
float::div() { builtin echo "$1" "$2" | awk -M -v PREC=200 '{printf "%.7f\n", $1 / $2 }'; }
double::div() { builtin echo "$1" "$2" | awk -M -v PREC=200 '{printf "%.15f\n", $1 / $2 }'; }
panic() {
	local STD_PANIC_CODE="$?" STD_TRACE_FUNC=("${BASH_LINENO[@]}") STD_TRACE_CMD_NUM=${BASH_LINENO[0]}|| exit 98
	POSIXLY_CORRECT= || exit 11
	\unset -f trap set return exit printf echo local unalias unset builtin kill || exit 22
	\unalias -a || exit 33
	unset POSIXLY_CORRECT || exit 44
	unset : || exit 55
	printf "\e[7m\e[0;m%s\e[0m\n" "@@@@@@@@  panic  @@@@@@@@"
	local STD_PANIC_CMD
	mapfile -s $((STD_TRACE_CMD_NUM-1)) -n 1 STD_PANIC_CMD < $0
	printf "\e[1;95m%s\e[0m%s\n" "[bash] " "$BASH_VERSION"
	printf "\e[1;96m%s\e[0m%s\n" "[unix] " "$EPOCHSECONDS"
	printf "\e[1;97m%s\e[0m%s\n" "[file] " "${BASH_SOURCE[-1]}"
	printf "\e[1;91m%s\e[0m%s\n" "[code] " "$STD_PANIC_CODE"
	printf "\e[1;94m%s\e[0m%s\n" "[ wd ] " "$PWD"
	printf "\e[1;93m%s\e[0m%s" "[ \$_ ] " "$STD_TRACE_CMD_NUM: ${STD_PANIC_CMD//$'\t'/}"
	local f
	local i=1
	STD_TRACE_FUNC=("${STD_TRACE_FUNC[@]:1}")
	for f in ${STD_TRACE_FUNC[@]}; do
		[[ $f = 0 ]] && break
		printf "\e[1;92m%s\e[0m%s\n" "[func] " "${f}: ${FUNCNAME[${i}]}()"
		((i++))
	done
	local STD_TRACE_LINE_ARRAY
	local STD_ORIGINAL_LINE="$STD_TRACE_CMD_NUM"
	if [[ $STD_TRACE_CMD_NUM -lt 5 ]]; then
		local STD_TRACE_CMD_NUM=1
		mapfile -n 9 STD_TRACE_LINE_ARRAY < $0
	else
		local STD_TRACE_CMD_NUM=$((STD_TRACE_CMD_NUM-4))
		mapfile -s $((STD_TRACE_CMD_NUM-1)) -n 9 STD_TRACE_LINE_ARRAY < $0
	fi
	for i in {0..8}; do
		[[ ${STD_TRACE_LINE_ARRAY[$i]} ]] || break
		if [[ $STD_TRACE_CMD_NUM = "$STD_ORIGINAL_LINE" ]]; then
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;97m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				2) printf "\e[1;97m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				3) printf "\e[1;97m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				4) printf "\e[1;97m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				5) printf "\e[1;97m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				*) printf "\e[1;97m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
			esac
		else
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;90m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				2) printf "\e[1;90m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				3) printf "\e[1;90m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				4) printf "\e[1;90m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				5) printf "\e[1;90m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
				*) printf "\e[1;90m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]}" ;;
			esac
		fi
		((STD_TRACE_CMD_NUM++))
	done
	printf "\e[0;m%s\n" "@@@@@@@@  panic  @@@@@@@@"
	while :; do read -s -r; done
	printf "\e[0;m%s\n" "@ loop fail, killing \$$ @"
	builtin kill -s KILL 0
	[[ $1 =~ ^[0-9]+$ ]] && exit $1 || exit 99
}
readonly BLACK="\e[0;30m"
readonly RED="\e[0;31m"
readonly GREEN="\e[0;32m"
readonly YELLOW="\e[0;33m"
readonly BLUE="\e[0;34m"
readonly PURPLE="\e[0;35m"
readonly CYAN="\e[0;36m"
readonly WHITE="\e[0;37m"
readonly BBLACK="\e[1;90m"
readonly BRED="\e[1;91m"
readonly BGREEN="\e[1;92m"
readonly BYELLOW="\e[1;93m"
readonly BBLUE="\e[1;94m"
readonly BPURPLE="\e[1;95m"
readonly BCYAN="\e[1;96m"
readonly BWHITE="\e[1;97m"
readonly UBLACK="\e[4;30m"
readonly URED="\e[4;31m"
readonly UGREEN="\e[4;32m"
readonly UYELLOW="\e[4;33m"
readonly UBLUE="\e[4;34m"
readonly UPURPLE="\e[4;35m"
readonly UCYAN="\e[4;36m"
readonly UWHITE="\e[4;37m"
readonly IBLACK="\e[0;90m"
readonly IRED="\e[0;91m"
readonly IGREEN="\e[0;92m"
readonly IYELLOW="\e[0;93m"
readonly IBLUE="\e[0;94m"
readonly IPURPLE="\e[0;95m"
readonly ICYAN="\e[0;96m"
readonly IWHITE="\e[0;97m"
readonly BOLD="\e[1m"
readonly ITALIC="\e[3m"
readonly OFF="\e[0m"
safety::builtin() {
	POSIXLY_CORRECT= || exit 11
	\unset -f "$@" || exit 22
	\unalias -a || exit 33
	unset POSIXLY_CORRECT || exit 44
}
safety::bash() {
	[[ ${BASH_VERSINFO[0]} -ge 5 ]] || { STD_TRACE_RETURN="bash not v5+: ${BASH_VERSINFO[0]}"; return 11; }
}
safety::gnu_linux() {
	[[ $OSTYPE = linux-gnu* ]] || { STD_TRACE_RETURN="os not gnu/linux: $OSTYPE"; return 11; }
}
___BEGIN___ERROR___TRACE___() {
	POSIXLY_CORRECT= || exit 8
	\unset -f true false trap set return exit printf unset local return read unalias mapfile kill builtin wait || exit 9
	\unalias -a || exit 10
	unset -v POSIXLY_CORRECT || exit 11
	unset -f : || exit 1
	trap 'STD_TRACE_CMD="$BASH_COMMAND" STD_TRACE_FUNC=(${BASH_LINENO[@]}) STD_TRACE_CMD_NUM="$LINENO" STD_TRACE_PIPE=(${PIPESTATUS[@]}); ___ENDOF___ERROR___TRACE___ > /dev/tty || exit 100' ERR || exit 12
	unset -v STD_TRACE_CMD STD_TRACE_FUNC_NUM STD_TRACE_CMD_NUM STD_TRACE_PIPE || exit 13
	set -E -e -o pipefail || exit 14
	return 0
}
___ENDOF___ERROR___TRACE___() {
	POSIXLY_CORRECT= || exit 15
	\unset -f true false trap set return exit printf unset local return read unalias mapfile kill builtin wait || exit 16
	\unalias -a || exit 17
	unset -v POSIXLY_CORRECT || exit 18
	unset -f : || exit 1
	if [[ -z $STD_TRACE_PIPE ]]; then
		unset -v STD_TRACE_CMD STD_TRACE_FUNC_NUM STD_TRACE_CMD_NUM STD_TRACE_PIPE || exit 23
		set +E +eo pipefail || exit 24
		trap - ERR || exit 25
		return 0
	fi
	printf "\e[1;91m%s\n" "========  BEGIN ERROR TRACE  ========"
	printf "\e[1;95m%s\e[0m%s\n" "[bash] " "$BASH_VERSION"
	printf "\e[1;96m%s\e[0m%s\n" "[unix] " "$EPOCHSECONDS"
	printf "\e[1;91m%s" "[code] "
	for i in "${STD_TRACE_PIPE[@]}"; do
		printf "\e[0m%s" "$i"
	done
	printf "\n\e[1;97m%s\e[0m%s\n" "[file] " "${BASH_SOURCE[-1]}"
	printf "\e[1;94m%s\e[0m%s\n" "[ wd ] " "$PWD"
	printf "\e[1;93m%s\e[0m%s\n" "[ \$_ ] " "${STD_TRACE_CMD_NUM}: $STD_TRACE_CMD"
	local f
	local i=1
	for f in "${STD_TRACE_FUNC[@]}"; do
		[[ $f = 0 ]] && break
		printf "\e[1;92m%s\e[0m%s\n" "[func] " "${f}: ${FUNCNAME[${i}]}()"
		((i++))
	done
	local STD_TRACE_LINE_ARRAY
	local STD_ORIGINAL_LINE="$STD_TRACE_CMD_NUM"
	if [[ $STD_TRACE_CMD_NUM -lt 5 ]]; then
		local STD_TRACE_CMD_NUM=1
		mapfile -n 9 STD_TRACE_LINE_ARRAY < "$0"
	else
		local STD_TRACE_CMD_NUM=$((STD_TRACE_CMD_NUM-4))
		mapfile -s $((STD_TRACE_CMD_NUM-1)) -n 9 STD_TRACE_LINE_ARRAY < "$0"
	fi
	for i in {0..8}; do
		[[ ${STD_TRACE_LINE_ARRAY[$i]} ]] || break
	  local STD_TRACE_SPACING="    "
		if [[ $STD_TRACE_CMD_NUM = "$STD_ORIGINAL_LINE" ]]; then
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;97m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				2) printf "\e[1;97m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				3) printf "\e[1;97m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				4) printf "\e[1;97m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				5) printf "\e[1;97m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				*) printf "\e[1;97m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
			esac
		else
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;90m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				2) printf "\e[1;90m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				3) printf "\e[1;90m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				4) printf "\e[1;90m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				5) printf "\e[1;90m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				*) printf "\e[1;90m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
			esac
		fi
		((STD_TRACE_CMD_NUM++))
	done
	[[ $STD_TRACE_RETURN ]] && printf "\e[38;5;196m%s\e[0;1m%s\e[0m\n" "[STD_TRACE_RETURN]" " $STD_TRACE_RETURN"
	printf "\e[1;91m%s\e[0m\n" "========  ENDOF ERROR TRACE  ========"
	unset -v STD_TRACE_CMD STD_TRACE_FUNC_NUM STD_TRACE_CMD_NUM STD_TRACE_PIPE || exit 26
	set +E +eo pipefail || exit 27
	trap - ERR || exit 28
	if [[ $BASH_SUBSHELL != 0 ]]; then
		printf "\e[1;93m%s\e[0m\n" "======  SUB-SHELLS TERMINATED  ======"
	fi
	builtin kill -s TERM 0
	exit 99
	printf "\e[1;97m%s\e[0m\n" "=KILL/EXIT FAIL, BEGIN INFINITE LOOP="
	while :; do read -s -r; done
	while true; do read -s -r; done
	while true; do false; done
	while :; do :; done
}
char() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p ${i%=*} &>/dev/null && { STD_TRACE_RETURN="char already found: $i"; return 33; }
		declare -g "$i" || return 44
	done
	return 0
}
array() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		{ declare -p ${i%=*} &>/dev/null || [[ -v ${i%=*} ]]; } && { STD_TRACE_RETURN="array already found: $i"; return 33; }
		declare -g -a "$i" || return 44
	done
	return 0
}
map() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		{ declare -p ${i%=*} &>/dev/null || [[ -v ${i%=*} ]]; } && { STD_TRACE_RETURN="map already found: $i"; return 33; }
		declare -g -A "$i" || return 44
	done
	return 0
}
int() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		if [[ $i = *=* ]]; then
			case ${i/*=} in
				''|*[!0-9]*) { STD_TRACE_RETURN="not integer: $i"; return 33; } ;;
			esac
		fi
		declare -p ${i%=*} &>/dev/null && { STD_TRACE_RETURN="integer already found: $i"; return 44; }
		declare -g -i "$i" || return 55
	done
	return 0
}
bool() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p ${i%=*} &>/dev/null && { STD_TRACE_RETURN="bool already found: $i"; return 33; }
		case $i in
			*=true) declare -g ${i%=*}=true || return 44 ;;
			*=false) declare -g ${i%=*}=false || return 55 ;;
			*) return 66 ;;
		esac
	done
}
ref() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -p ${i%=*} &>/dev/null && { STD_TRACE_RETURN="ref already found: $i"; return 33; }
		declare -g -n "$i" || return 44
	done
	return 0
}
free() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		{ declare -p ${i%=*} &>/dev/null || [[ -v ${i%=*} ]]; } || { STD_TRACE_RETURN="no var found: $i"; return 33; }
		unset -v "$i" || { STD_TRACE_RETURN="could not free: $i"; return 44; }
	done
	return 0
}
free::func() {
	[[ $# = 0 ]] && return 11
	local i || return 22
	for i in "$@"; do
		declare -F "$i" &>/dev/null || { STD_TRACE_RETURN="no func found: $i"; return 33; }
		unset -f "$i" || { STD_TRACE_RETURN="could not free: $i"; return 44; }
	done
	return 0
}
declare -frg ask::yes
declare -frg ask::no
declare -frg ask::sudo
declare -frg const::char
declare -frg const::array
declare -frg const::map
declare -frg const::int
declare -frg const::bool
declare -frg const::ref
declare -frg crypto::bytes
declare -frg crypto::num
declare -frg crypto::uuid
declare -frg crypto::encrypt
declare -frg crypto::decrypt
declare -frg date::unix_translate
declare -frg date::unix
declare -frg date::time
declare -frg date::calendar
declare -frg date::now
declare -frg date::year
declare -frg date::month
declare -frg date::day
declare -frg date::hour
declare -frg date::minute
declare -frg date::second
declare -frg debug
declare -frg debug::trap
declare -frg is::int
declare -frg is::int_pos
declare -frg is::int_neg
declare -frg lock::alloc
declare -frg lock::free
declare -frg log::ok
declare -frg log::info
declare -frg log::warn
declare -frg log::fail
declare -frg log::danger
declare -frg log::tab
declare -frg log::prog
declare -frg log::debug
declare -frg short::sum
declare -frg float::sum
declare -frg double::sum
declare -frg short::add
declare -frg float::add
declare -frg double::add
declare -frg short::sub
declare -frg float::sub
declare -frg double::sub
declare -frg short::mul
declare -frg float::mul
declare -frg double::mul
declare -frg short::div
declare -frg float::div
declare -frg double::div
declare -frg panic
declare -frg safety::builtin
declare -frg safety::bash
declare -frg safety::gnu_linux
declare -frg ___BEGIN___ERROR___TRACE___
declare -frg ___ENDOF___ERROR___TRACE___
declare -frg char
declare -frg array
declare -frg map
declare -frg int
declare -frg bool
declare -frg ref
declare -frg free
declare -frg free::func

#-------------------------------------------------------------------------------- BEGIN SRC
trap 'printf "%s\n" "@@@@@@ SRC PANIC @@@@@@" "[line] ${LINENO}" "[file] $0" "[code] $?";set +eo pipefail;trap - ERR;while :;do read;done;exit 115' ERR || exit 115
crypto::key::create() {
	log::debug "starting"
	local ENTROPY=512
	char CRYPTO_KEY
	CRYPTO_KEY=$(mktemp /tmp/monero-bash-crypto-key.XXXXXXXXXX)
	chmod 600 "$CRYPTO_KEY"
	crypto::bytes $ENTROPY | base64 > "$CRYPTO_KEY"
	log::debug "created key with $((ENTROPY*8)) bits of entropy: $CRYPTO_KEY"
	return 0
}
crypto::key::remove() {
	log::debug "deleting key: $CRYPTO_KEY"
	[[ -e $CRYPTO_KEY ]]
	rm "$CRYPTO_KEY"
	free CRYPTO_KEY
}
DEBUG() {
	log::debug "STARTING DEBUG MODE"
	local DEBUG_FUNCTION || return 1
	printf "${BRED}%s\n${BWHITE}%s\n${BWHITE}%s\n${BWHITE}%s\n${BWHITE}%s\n" \
		"   ===> MONERO-BASH DEBUG MODE <===   " \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		"@ you are executing a monero-bash    @" \
		"@ function directly, use carefully!  @" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	if [[ $2 ]]; then
		printf "${BGREEN}%s${BWHITE}%s\n${OFF}%s" \
			"function(): " \
			"$2" \
			"Execute this function? (y/N) "
		if ask::no; then
			printf "%s\n" "Exiting..."
			exit 1
		fi
		DEBUG_FUNCTION="$2" || return 2
	else
		printf "${BGREEN}%s${OFF}" "function(): "
		read -r DEBUG_FUNCTION || return 3
	fi
	if ! declare -fp "$DEBUG_FUNCTION" &>/dev/null; then
		log::fail "$DEBUG_FUNCTION not found"
		exit 1
	fi
	printf "%s\n" "EXECUTING FUNCTION: $DEBUG_FUNCTION"
	$DEBUG_FUNCTION
	exit
}
monero_bash::install:trap::user() {
	trap "" INT
	log::prog "Deleting user [monero-bash]"
	if sudo userdel monero-bash; then
		log::ok "Deleted user [monero-bash]"
	else
		log::fail "Could not delete user [monero-bash]"
	fi
}
monero_bash::install::trap::clean() {
	print::error "Install failed, starting cleanup"
	trap "" INT
	if [[ -d "$DOT" ]]; then
		log::debug "DOT found: $DOT"
		log::prog "Deleting: $DOT"
		if rm -rf "$DOT" &>/dev/null; then
			log::ok "Deleted: $DOT"
		else
			log::fail "Could not delete: $DOT"
		fi
	else
		log::debug "no DOT found at: $DOT"
	fi
	if [[ -e "$BINARY" || -h "$BINARY" ]]; then
		log::debug "BINARY found: $BINARY"
		log::prog "Deleting: $BINARY"
		if sudo rm -rf "$BINARY" &>/dev/null; then
			log::ok "Deleted: $BINARY"
		else
			log::fail "Could not delete: $BINARY"
		fi
	else
		log::debug "no BINARY found at: $BINARY"
	fi
	if [[ -e "$SYMLINK" || -h "$SYMLINK" ]]; then
		local SYMLINK_OUTPUT="$(ls "$SYMLINK")"
		if [[ $SYMLINK_OUTPUT = *${BINARY}* ]]; then
			log::prog "SYMLINK found: $SYMLINK"
			log::prog "Deleting: $SYMLINK"
			if sudo rm -rf "$SYMLINK" &>/dev/null; then
				log::ok "Deleted: $SYMLINK"
			else
				log::fail "Could not delete: $SYMLINK"
			fi
		else
			log::debug "no SYMLINK found at: $SYMLINK"
		fi
	fi
	exit 0
}
monero_bash::install() {
log::debug "starting ${FUNCNAME}()"
if [[ -d "$HOME"/.monero-bash ]]; then
	print::error "[monero-bash] install folder already found: $HOME/.monero-bash"
	print::exit  "Exiting for safety..."
fi
if [[ -e "$BINARY" || -h "$BINARY" ]]; then
	print::error "/usr/local/bin/monero-bash already found!"
	print::exit  "Exiting for safety..."
fi
printf "${BRED}%s${OFF}\n" \
	"#-----------------------------------------------------------------#" \
	"#                    monero-bash installation                     #" \
	"#-----------------------------------------------------------------#"
local INSTALL_DATA_PATH
if [[ -d "$HOME"/.bitmonero ]]; then
	printf "${OFF}%s\n%s${BYELLOW}%s${OFF}%s" \
		"Monero data folder already detected" \
		"Use " \
		"$HOME/.bitmonero? " \
		"(Y/n) "
	if ask::yes; then
		INSTALL_DATA_PATH="$HOME/.bitmonero"
	else
		printf "%s\n\n" "Skipping: $HOME/.bitmonero"
	fi
fi
while :; do
	if [[ -z $INSTALL_DATA_PATH ]]; then
		printf "%s" "Monero data path [Enter for default]: "
		read -r INSTALL_DATA_PATH
	fi
	if [[ -z $INSTALL_DATA_PATH ]]; then
		INSTALL_DATA_PATH="$HOME/.bitmonero"
	fi
	printf "\n${BWHITE}%s${BYELLOW}%s\n${OFF}%s" \
		"DATA PATH: " \
		"$INSTALL_DATA_PATH" \
		"Is this okay? (Y/n) "
	if ask::yes; then
		echo
		break
	else
		unset -v INSTALL_DATA_PATH
	fi
	echo
done
if [[ ! -e $SYMLINK && ! -h $SYMLINK ]]; then
	printf "${OFF}%s${BRED}%s${OFF}%s${BRED}%s${OFF}\n" \
		"Symlink creation: " \
		"[monero-bash] " \
		"-> " \
		"[mb]"
	printf "${OFF}%s${BRED}%s${OFF}%s${BCYAN}%s${OFF}\n" \
		"This allows you to use " \
		"[monero-bash] " \
		"like so: " \
		"mb update && mb upgrade"
	printf "${OFF}%s" "Create symlink? (Y/n) "
	if ask::yes; then
		local INSTALL_SYMLINK=true
		printf "%s\n" "Will create [mb] symlink"
	else
		printf "%s\n" "Skipping [mb] symlink..."
	fi
fi
local i
printf "\n${BRED}%s" "#"
for ((i=0; i < 65; i++)); do
	read -r -t 0.01 || true
	printf "%s" "-"
done
printf "${BRED}%s${OFF}\n\n" "#"
printf "${OFF}%s${BYELLOW}%s\n" \
	"[monero-bash] will install in | " "$HOME/.monero-bash" \
	"The PATH will be set in       | " "/usr/local/bin/monero-bash" \
	"[.bitmonero] will be set in   | " "$INSTALL_DATA_PATH"
if [[ $INSTALL_SYMLINK = true ]]; then
	printf "${OFF}%s${BYELLOW}%s\n" \
	"A PATH symlink will be set in | " "/usr/local/bin/mb"
fi
echo
printf "${BWHITE}%s${OFF}\n" \
	"A no-login user called [monero-bash] will be created for process security." \
	"[Monero] and [P2Pool] will run as this user. [XMRig] by default, runs as ROOT." \
	"This can be changed in [monero-bash.conf]: XMRIG_ROOT=false"
echo
printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}" \
	"Start " \
	"[monero-bash] " \
	"install? (Y/n) "
if ! ask::yes; then
	printf "${OFF}%s\n" "Canceling [monero-bash] installation..."
	exit 1
fi
if ! ask::sudo; then
	print::exit "sudo is required for installation"
fi
log::prog "verifying [monero-bash] file hashes"
if sha256sum --check "txt/hashlist" &>/dev/null; then
	log::ok "[monero-bash] file hashes"
else
	log::fail "[monero-bash] file hashes"
	print::error "Hash verification has failed."
	print::exit "Have the files been moved or modified?"
fi
log::prog "creating [monero-bash] user"
local NOLOGIN_SHELL
NOLOGIN_SHELL="$(which nologin)"
log::debug "[nologin] shell found: $NOLOGIN_SHELL"
trap 'monero_bash::install::trap::clean' EXIT
if ! sudo useradd --no-create-home --system --shell "$NOLOGIN_SHELL" monero-bash; then
	print::error "Could not create [monero-bash] user"
	print::exit "Exiting for safety..."
else
	trap 'monero::install::trap::user; monero_bash::install::trap::clean' EXIT
	log::ok "created [monero-bash] user"
fi
log::prog "creating [.monero-bash] folders"
mkdir "$DOT"
mkdir "$WALLETS"
mkdir "$PACKAGES"
mkdir "$CHANGES"
mkdir "$EXPORT_IMPORT"
mkdir "$PKG_MONERO_BASH"
log::ok "created [.monero-bash] folders"
log::prog "cleaning git files"
[[ -e docs ]]         && rm -rf doc
[[ -e lib ]]          && rm -rf lib
[[ -e tests ]]        && rm -rf tests
[[ -e utils ]]        && rm -rf utils
[[ -e src ]]          && rm -rf src
[[ -e external ]]     && rm -rf external
[[ -e pgp ]]          && rm -rf pgp
[[ -e CHANGELOG.md ]] && rm -f CHANGELOG.md
[[ -e README.md ]]    && rm -f README.md
[[ -e LICENSE ]]      && rm -f LICENSE
[[ -e hbc.add ]]      && rm -f hbc.add
[[ -e hbc.conf ]]     && rm -f hbc.conf
[[ -e main.sh ]]      && rm -f main.sh
[[ -e .git ]]         && rm -rf .git
[[ -e .gitignore ]]   && rm -f .gitignore
[[ -e .gitmodules ]]  && rm -f .gitmodules
log::ok "cleaned git files"
log::prog "moving folder to: [$HOME/.monero-bash]"
mv -f "$RELATIVE" "$PACKAGES"
log::ok "moved folder to: [$HOME/.monero-bash]"
log::prog "creating config folder"
mkdir -p "$CONFIG"
cp "$SRC_CONFIG/monero-bash.conf" "$CONFIG/"
cp "$SRC_CONFIG/monerod.conf" "$CONFIG/"
cp "$SRC_CONFIG/monero-wallet-cli.conf" "$CONFIG/"
log::ok "created config folder"
log::prog "creating changelog"
cp "$TXT/changes" "$CHANGES/monero-bash"
log::ok "created changelog"
log::prog "adding [monero-bash] to PATH"
sudo ln -s "$MAIN" /usr/local/bin/monero-bash
log::ok "added [monero-bash] to PATH"
if [[ $INSTALL_SYMLINK = true ]]; then
	log::prog "creating [mb] PATH symlink"
	sudo ln -s "$MAIN" /usr/local/bin/mb
	log::ok "created [mb] PATH symlink"
fi
log::prog "setting Monero data path"
sed -i "s@data-dir.*@data-dir=$INSTALL_DATA_PATH@g" "$CONFIG_MONEROD"
log::ok "set Monero data path"
log::debug "setting FIRST_TIME = false"
sed -i "s/FIRST_TIME=.*/FIRST_TIME=false/g" "$STATE"
log::debug "set FIRST_TIME = false"
log::prog "setting folder permissions"
sudo chown "$USER:$USER" "$DOT"
sudo chmod -R 770 "$DOT"
log::ok "set folder permissions"
trap - EXIT
printf "${BGREEN}%s${OFF}\n" \
	"" \
	"#-----------------------------------------------------------------#" \
	"#                monero-bash installation complete                #" \
	"#-----------------------------------------------------------------#"
printf "${BWHITE}%s${BYELLOW}%s\n" \
	"monero-bash path    | " "$HOME/.monero-bash" \
	"Monero data path    | " "$INSTALL_DATA_PATH" \
	"Wallet files        | " "$WALLETS" \
	"Package folders     | " "$PACKAGES" \
	"Configuration files | " "$CONFIG"
echo
if [[ $INSTALL_SYMLINK = true ]]; then
	printf "${BWHITE}%s${BRED}%s${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
		"Type: " \
		"[monero-bash help] " \
		"OR " \
		"[mb help] " \
		"to get started"
else
	printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
		"Type: " \
		"[monero-bash help] " \
		"to get started"
fi
exit 0
}
monero_bash::uninstall() {
log::debug "starting ${FUNCNAME}()"
printf "${BWHITE}%s\n${BWHITE}%s${BRED}%s${BWHITE}%s\n${BWHITE}%s${OFF}\n" \
	"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
	"@ " \
	"THIS WILL UNINSTALL [monero-bash], DELETE /.monero-bash/ AND EVERYTHING INSIDE IT " \
	"@" \
	"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
print::size
echo
printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}" \
	"Uninstall " \
	"[monero-bash]" \
	"? (y/N) "
if ask::no; then
	printf "%s\n" "Canceling [monero-bash] uninstall"
	exit 1
fi
local WALLET_COUNT WALLET_LIST i
WALLET_COUNT=$(ls "$WALLETS" | wc -l) || exit 1
WALLET_LIST=$(ls "$WALLETS" | grep -v ".keys" | sort)
if [[ $WALLET_COUNT != 0 ]]; then
	printf "${BWHITE}%s\n${BWHITE}%s${BRED}%s${BWHITE}%s\n${BWHITE}%s\n" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		"@ " \
		"         WARNING: WALLETS FOUND          " \
		"@" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	for i in $WALLET_LIST; do
		printf "${BWHITE}[%s]  " "$i"
	done
	printf "\n\n${BRED}%s${IWHITE}%s" "ARE YOU SURE YOU WANT TO UNINSTALL? (y/N) "
	if ask::no; then
		printf "${OFF}%s\n" "Canceling [monero-bash] uninstall"
		exit 1
	else
		printf "${OFF}"
	fi
fi
if ! ask::sudo; then
	print::exit "sudo is needed to uninstall"
fi
local i
for i in {10..0}; do
	printf "\r\e[2K${BYELLOW}%s" "Uninstalling in ${i}..."
	sleep 1
done
log::info "stopping all processes"
if [[ $MONERO_VER ]]; then
	if systemctl status monero-bash-monerod &>/dev/null; then
		process::systemd::stop monerod
	fi
fi
if [[ $P2POOL_VER ]]; then
	if systemctl status monero-bash-p2pool &>/dev/null; then
		process::systemd::stop p2pool
	fi
fi
if [[ $XMRIG_VER ]]; then
	if systemctl status monero-bash-xmrig &>/dev/null; then
		process::systemd::stop xmrig
	fi
fi
trap "" INT
___BEGIN___ERROR___TRACE___
log::prog "Removing ${DOT}..."
rm -rf "$DOT"
log::ok "Removed $DOT"
log::prog "Removing from PATH..."
sudo rm /usr/local/bin/monero-bash
[[ -e /usr/local/bin/mb ]] && sudo rm /usr/local/bin/monero-bash
log::ok "Removed from PATH"
log::prog "Removing systemd services..."
[[ -e "$SYSTEMD/monero-bash-monerod.service" ]] && sudo rm "$SYSTEMD/monero-bash-monerod.service"
[[ -e "$SYSTEMD/monero-bash-p2pool.service" ]]  && sudo rm "$SYSTEMD/monero-bash-p2pool.service"
[[ -e "$SYSTEMD/monero-bash-xmrig.service" ]]   && sudo rm "$SYSTEMD/monero-bash-xmrig.service"
log::ok "Removed systemd services"
___ENDOF___ERROR___TRACE___
log::prog "Removing [monero-bash] user..."
sudo userdel monero-bash
log::ok "Removed [monero-bash] user"
echo
printf "${BGREEN}%s${OFF}\n" \
	"#----------------------------------------#" \
	"# Successfully uninstalled [monero-bash] #" \
	"#----------------------------------------#"
exit 0
}
parse::config() {
	log::debug "starting"
	local i IFS=$'\n' CONFIG_ARRAY CONFIG_PATH || return 1
	if [[ -e $CONFIG_MONERO_BASH ]]; then
		log::debug "config found, using: $CONFIG_MONERO_BASH"
		mapfile CONFIG_ARRAY < "$CONFIG_MONERO_BASH" || return 2
	elif [[ $FIRST_TIME = true && -e "${RELATIVE}/config/monero-bash.conf" ]]; then
		log::debug "config found, using: ${RELATIVE}/config/monero-bash.conf"
		mapfile CONFIG_ARRAY < "${RELATIVE}/config/monero-bash.conf" || return 3
	else
		print::exit "[monero-bash.conf] not found"
	fi
	for i in ${CONFIG_ARRAY[@]}; do
		[[ $i = "AUTO_START_MONEROD=true" ]] && declare -g AUTO_START_MONEROD=true
		[[ $i = "AUTO_STOP_MONEROD=true" ]]  && declare -g AUTO_STOP_MONEROD=true
		[[ $i = "XMRIG_ROOT=true" ]]         && declare -g XMRIG_ROOT=true
		[[ $i = "AUTO_UPDATE=true" ]]        && declare -g AUTO_UPDATE=true
		[[ $i = RPC_IP=* ]]                && declare -g RPC_IP="${i/*=/}"
	done
	[[ $AUTO_START_MONEROD != true ]] && declare -g AUTO_START_MONEROD=false
	[[ $AUTO_STOP_MONEROD != true ]]  && declare -g AUTO_STOP_MONEROD=false
	[[ $AUTO_UPDATE != true ]]        && declare -g AUTO_UPDATE=false
	[[ $XMRIG_ROOT != true ]]         && declare -g XMRIG_ROOT=false
	[[ -z $RPC_IP ]]                  && declare -g RPC_IP="localhost:18081"
	log::debug "--- monero-bash.conf settings ---"
	log::debug "AUTO_START_MONEROD | $AUTO_START_MONEROD"
	log::debug "AUTO_STOP_MONEROD  | $AUTO_STOP_MONEROD"
	log::debug "AUTO_UPDATE        | $AUTO_UPDATE"
	log::debug "XMRIG_ROOT         | $XMRIG_ROOT"
	log::debug "RPC_IP             | $RPC_IP"
}
parse::options::process() {
	[[ $# = 1 ]] && print::help::command "$1" && exit 1
	shift
	case "$1" in
		*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
		monero|Monero|MONERO) OPTION_MONERO=true;;
		*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
		*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
		*)
			print::error "Invalid option: $1"
			print::exit  "Pick one/multiple processes: [bash|monero|p2pool|xmrig]"
			;;
	esac
	until [[ $# = 0 ]]; do
	shift
	case "$1" in
		*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
		monero|Monero|MONERO) OPTION_MONERO=true;;
		*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
		*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
		"")                   return 0;;
		*)
			print::error "Invalid option: $1"
			print::exit  "Pick one/multiple processes: [bash|monero|p2pool|xmrig]"
			;;
	esac
	done
}
parse::options::systemd() {
	[[ $# = 1 ]] && print::help::command "$1" && exit 1
	until [[ $# = 0 ]]; do
	shift
	case "$1" in
		monero|Monero|MONERO) OPTION_MONERO=true;;
		*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
		*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
		"")                   return 0;;
		*)
			print::error "Invalid option: $1"
			print::exit  "Pick one/multiple processes: [monero|p2pool|xmrig]"
			;;
	esac
	done
}
parse::options() {
log::debug "starting ${FUNCNAME}"
log::debug "unsetting OPTION variables"
unset -v OPTION_BASH OPTION_MONERO OPTION_P2POOL OPTION_XMRIG OPTION_VERBOSE OPTION_FORCE
log::debug "user input: $*"
case "$1" in
	list) print::title; wallet::list;;
	size) print::size;;
	new)  shift; print::title; wallet::create "$@";;
	open)
		[[ $# = 1 ]] && print::help::command $1 && exit 1
		shift
		if [[ $2 ]]; then
			case "$2" in
				-p | --password) :;;
				*)
					print::error "Invalid option: $1"
					print::exit  "Did you mean: [-p|--password <pass>]?"
					;;
			esac
		fi
		wallet::open "$@"
		;;
	update)
		shift
		until [[ $# = 0 ]]; do
			case "$1" in
				-v | --verbose) OPTION_VERBOSE=true;;
				"")             :;;
				*)              print::help::command update;exit 1;;
			esac
			shift
		done
		___BEGIN___ERROR___TRACE___
		pkg::update
		___ENDOF___ERROR___TRACE___
		;;
	install)
		[[ $# = 1 ]] && print::help::command "$1" && exit 1
		shift
		until [[ $# = 0 ]]; do
			case "$1" in
				*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
				monero|Monero|MONERO) OPTION_MONERO=true;;
				*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
				*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
				--verbose|-v)         OPTION_VERBOSE=true;;
				--force|-f)           OPTION_FORCE=true;;
				--yes|-y)             OPTION_YES=true;;
				*)
					print::error "Invalid option: $1"
					print::exit  "Pick one/multiple packages: [bash|monero|p2pool|xmrig]"
					;;
			esac
			shift
		done
		___BEGIN___ERROR___TRACE___
		pkg::prompt install
		___ENDOF___ERROR___TRACE___
		;;
	remove)
		[[ $# = 1 ]] && print::help::command "$1" && exit 1
		shift
		until [[ $# = 0 ]]; do
			case "$1" in
				*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
				monero|Monero|MONERO) OPTION_MONERO=true;;
				*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
				*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
				--verbose|-v)         OPTION_VERBOSE=true;;
				--yes|-y)             OPTION_YES=true;;
				*)
					print::error "Invalid option: $1"
					print::exit  "Pick one/multiple packages: [bash|monero|p2pool|xmrig]"
					;;
			esac
			shift
		done
		___BEGIN___ERROR___TRACE___
		pkg::remove::prompt
		___ENDOF___ERROR___TRACE___
		;;
	upgrade)
		shift
		until [[ $# = 0 ]]; do
			case "$1" in
				--verbose|-v)         OPTION_VERBOSE=true;;
				--force|-f)           OPTION_FORCE=true;;
				--yes|-y)             OPTION_YES=true;;
				"")                   break;;
				*)
					print::exit "Invalid option: $1"
					;;
			esac
			shift
		done
		___BEGIN___ERROR___TRACE___
		pkg::prompt upgrade
		___ENDOF___ERROR___TRACE___
		;;
	full)
		[[ $# = 1 ]] && print::help::command "$1" && exit 1
		shift
		[[ $# -gt 1 ]] && print::exit "Pick one process: [monero|p2pool|xmrig]"
		case "$1" in
			*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
			monero|Monero|MONERO) OPTION_MONERO=true;;
			*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
			*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
			*)
				print::error "Invalid process: $1"
				print::exit  "Pick one process: [monero|p2pool|xmrig]"
				;;
		esac
		process::full
		;;
	config)
		parse::options::process "$@"
		process::config
		;;
	default)
		[[ $# = 1 ]] && print::help::command "$1" && exit 1
		shift
		case "$1" in
			*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
			monero|Monero|MONERO) OPTION_MONERO=true;;
			*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
			*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
			*)
				print::error "Invalid option: $1"
				print::error  "Pick one/multiple processes: [bash|monero|p2pool|xmrig]"
				;;
		esac
		until [[ $# = 0 ]]; do
		shift
		case "$1" in
			*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
			monero|Monero|MONERO) OPTION_MONERO=true;;
			*p2p*|*P2p*|*P2P*)    OPTION_P2POOL=true;;
			*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
			--config|-c)          OPTION_CONFIG=true;;
			--systemd|-s)         OPTION_SYSTEMD=true;;
			*)
				print::error "Invalid process: $1"
				print::exit  "Pick one process: [bash|monero|p2pool|xmrig]"
				;;
		esac
		done
		process::default
		;;
	start)
		parse::options::systemd "$@"
		systemd::start
		;;
	stop)
		parse::options::systemd "$@"
		systemd::stop
		;;
	kill)
		parse::options::systemd "$@"
		systemd::kill
		;;
	restart)
		parse::options::systemd "$@"
		systemd::restart
		;;
	watch)
		parse::options::systemd "$@"
		systemd::watch
		;;
	edit)
		parse::options::systemd "$@"
		systemd::edit
		;;
	refresh)
		parse::options::systemd "$@"
		systemd::refresh
		;;
	enable)
		parse::options::systemd "$@"
		systemd::enable
		;;
	disable)
		parse::options::systemd "$@"
		systemd::disable
		;;
	status)  status;;
	version) print::version;;
	uninstall) monero_bash::uninstall;;
	rpc)
		[[ $# = 1 ]] && print::help::command "$1" && exit 1
		shift
		local i RPC_LIST
		for i in $@; do
			case "$i" in
				-v | --verbose) OPTION_VERBOSE=true;;
			esac
		done
		RPC_LIST=(${@//\-v})
		RPC_LIST=(${@//\-\-verbose})
		rpc "${RPC_LIST[@]}"
		;;
	changes)
		[[ $# = 1 ]] && print::help::command "$1" && exit 1
		shift
		until [[ $# = 0 ]]; do
		case "$1" in
			*bash*|*Bash*|*BASH*) OPTION_BASH=true;;
			monero|Monero|MONERO) OPTION_MONERO=true;;
			*p2p*|*P2P*|*P2p*)    OPTION_P2POOL=true;;
			*xmr*|*Xmr*|*XMR*)    OPTION_XMRIG=true;;
			-p | --print)         OPTION_PRINT=true;;
			*)
				print::error "Invalid option: $1"
				print::exit  "Pick one package: [bash|monero|p2pool|xmrig]"
				;;
		esac
		shift
		done
		print::changes::list
		exit
		;;
	help)
		shift
		___BEGIN___ERROR___TRACE___
		if [[ $1 ]]; then
			print::help::command "$@" && exit || exit 1
		else
			print::help && exit || exit 1
		fi
		___ENDOF___ERROR___TRACE___
		;;
	*)
		log::debug "user input failed: $*"
		print::error "Invalid option: $*"
		print::exit "$(printf "${OFF}%s${BYELLOW}%s${OFF}\n" "For help, type: " "monero-bash help")"
		;;
esac
exit
}
parse::p2pool() {
	log::debug "starting"
	local i IFS=$'\n' CONFIG_ARRAY || return 1
	mapfile CONFIG_ARRAY < "$CONFIG_P2POOL" || return 2
	for i in "${CONFIG_ARRAY[@]}"; do
		[[ $i =~ ^P2POOL_WALLET=*$ ]]       && declare -g P2POOL_WALLET="${i/*=/}"
		[[ $i =~ ^P2POOL_HOST=*$ ]]         && declare -g P2POOL_HOST="${i/*=/}"
		[[ $i =~ ^P2POOL_RPC_PORT=*$ ]]     && declare -g P2POOL_RPC_PORT="${i/*=/}"
		[[ $i =~ ^P2POOL_ZMQ_PORT=*$ ]]     && declare -g P2POOL_ZMQ_PORT="${i/*=/}"
		[[ $i =~ ^P2POOL_STRATUM=*$ ]]      && declare -g P2POOL_STRATUM="${i/*=/}"
		[[ $i =~ ^P2POOL_P2P=*$ ]]          && declare -g P2POOL_P2P="${i/*=/}"
		[[ $i =~ ^P2POOL_ADD_PEERS=*$ ]]    && declare -g P2POOL_ADD_PEERS="${i/*=/}"
		[[ $i =~ ^P2POOL_LIGHT_MODE=*$ ]]   && declare -g P2POOL_LIGHT_MODE="${i/*=/}"
		[[ $i =~ ^P2POOL_CONFIG=*$ ]]       && declare -g P2POOL_CONFIG="${i/*=/}"
		[[ $i =~ ^P2POOL_LOG_LEVEL=*$ ]]    && declare -g P2POOL_LOG_LEVEL="${i/*=/}"
		[[ $i =~ ^P2POOL_DATA_API=*$ ]]     && declare -g P2POOL_DATA_API="${i/*=/}"
		[[ $i =~ ^P2POOL_LOCAL_API=*$ ]]    && declare -g P2POOL_LOCAL_API="${i/*=/}"
		[[ $i =~ ^P2POOL_NO_CACHE=*$ ]]     && declare -g P2POOL_NO_CACHE="${i/*=/}"
		[[ $i =~ ^P2POOL_NO_COLOR=*$ ]]     && declare -g P2POOL_NO_COLOR="${i/*=/}"
		[[ $i =~ ^P2POOL_NO_RANDOMX=*$ ]]   && declare -g P2POOL_NO_RANDOMX="${i/*=/}"
		[[ $i =~ ^P2POOL_OUT_PEERS=*$ ]]    && declare -g P2POOL_OUT_PEERS="${i/*=/}"
		[[ $i =~ ^P2POOL_IN_PEERS=*$ ]]     && declare -g P2POOL_IN_PEERS="${i/*=/}"
		[[ $i =~ ^P2POOL_START_MINING=*$ ]] && declare -g P2POOL_START_MINING="${i/*=/}"
		[[ $i =~ ^P2POOL_MINI=*$ ]]         && declare -g P2POOL_MINI="${i/*=/}"
		[[ $i =~ ^P2POOL_NO_AUTODIFF=*$ ]]  && declare -g P2POOL_NO_AUTODIFF="${i/*=/}"
		[[ $i =~ ^P2POOL_RPC_LOGIN=*$ ]]    && declare -g P2POOL_RPC_LOGIN="${i/*=/}"
	done
	[[ -z $P2POOL_HOST ]]             && declare -g P2POOL_HOST=127.0.0.1
	[[ -z $P2POOL_RPC_PORT ]]         && declare -g P2POOL_RPC_PORT=18081
	[[ -z $P2POOL_ZMQ_PORT ]]         && declare -g P2POOL_ZMQ_PORT=18083
	[[ $P2POOL_LIGHT_MODE != true ]]  && declare -g P2POOL_LIGHT_MODE=false
	[[ -z $P2POOL_LOG_LEVEL ]]        && declare -g P2POOL_LOG_LEVEL=2
	[[ $P2POOL_NO_CACHE != true ]]    && declare -g P2POOL_NO_CACHE=false
	[[ $P2POOL_NO_COLOR != true ]]    && declare -g P2POOL_NO_COLOR=false
	[[ $P2POOL_NO_RANDOMX != true ]]  && declare -g P2POOL_NO_RANDOMX=false
	[[ $P2POOL_MINI != true ]]        && declare -g P2POOL_MINI=false
	[[ $P2POOL_NO_AUTODIFF != true ]] && declare -g P2POOL_NO_AUTODIFF=false
	declare -g P2POOL_COMMAND || return 3
	P2POOL_COMMAND="--wallet $P2POOL_WALLET"
	P2POOL_COMMAND="$P2POOL_COMMAND --host $P2POOL_HOST"
	P2POOL_COMMAND="$P2POOL_COMMAND --rpc-port $P2POOL_RPC_PORT"
	P2POOL_COMMAND="$P2POOL_COMMAND --zmq-port $P2POOL_ZMQ_PORT"
	[[ $P2POOL_STRATUM ]]            && P2POOL_COMMAND="$P2POOL_COMMAND --stratum $P2POOL_STRATUM"
	[[ $P2POOL_P2P ]]                && P2POOL_COMMAND="$P2POOL_COMMAND --p2p $P2POOL_P2P"
	[[ $P2POOL_ADD_PEERS ]]          && P2POOL_COMMAND="$P2POOL_COMMAND --addpeers $P2POOL_ADD_PEERS"
	[[ $P2POOL_LIGHT_MODE = true ]]  && P2POOL_COMMAND="$P2POOL_COMMAND --light-mode"
	P2POOL_COMMAND="$P2POOL_COMMAND --loglevel $P2POOL_LOG_LEVEL"
	[[ $P2POOL_CONFIG ]]             && P2POOL_COMMAND="$P2POOL_COMMAND --config $P2POOL_CONFIG"
	[[ $P2POOL_DATA_API ]]           && P2POOL_COMMAND="$P2POOL_COMMAND --data-api $P2POOL_DATA_API"
	[[ $P2POOL_LOCAL_API ]]          && P2POOL_COMMAND="$P2POOL_COMMAND --local-api $P2POOL_LOCAL_API"
	[[ $P2POOL_NO_CACHE = true ]]    && P2POOL_COMMAND="$P2POOL_COMMAND --no-cache"
	[[ $P2POOL_NO_COLOR = true ]]    && P2POOL_COMMAND="$P2POOL_COMMAND --no-color"
	[[ $P2POOL_NO_RANDOMX = true ]]  && P2POOL_COMMAND="$P2POOL_COMMAND --no-randomx"
	[[ $P2POOL_OUT_PEERS ]]          && P2POOL_COMMAND="$P2POOL_COMMAND --out-peers $P2POOL_OUT_PEERS"
	[[ $P2POOL_IN_PEERS ]]           && P2POOL_COMMAND="$P2POOL_COMMAND --in-peers $P2POOL_IN_PEERS"
	[[ $P2POOL_START_MINING ]]       && P2POOL_COMMAND="$P2POOL_COMMAND --start-mining $P2POOL_START_MINING"
	[[ $P2POOL_MINI = true ]]        && P2POOL_COMMAND="$P2POOL_COMMAND --mini"
	[[ $P2POOL_NO_AUTODIFF = true ]] && P2POOL_COMMAND="$P2POOL_COMMAND --no-autodiff"
	[[ $P2POOL_RPC_LOGIN ]]          && P2POOL_COMMAND="$P2POOL_COMMAND --rpc-login $P2POOL_RPC_LOGIN"
	log::debug "--- p2pool.conf settings ---"
	log::debug "P2POOL_WALLET       | $P2POOL_WALLET"
	log::debug "P2POOL_HOST         | $P2POOL_HOST"
	log::debug "P2POOL_RPC_PORT     | $P2POOL_RPC_PORT"
	log::debug "P2POOL_ZMQ_PORT     | $P2POOL_ZMQ_PORT"
	log::debug "P2POOL_STRATUM      | $P2POOL_STRATUM"
	log::debug "P2POOL_P2P          | $P2POOL_P2P"
	log::debug "P2POOL_ADD_PEERS    | $P2POOL_ADD_PEERS"
	log::debug "P2POOL_LIGHT_MODE   | $P2POOL_LIGHT_MODE"
	log::debug "P2POOL_CONFIG       | $P2POOL_CONFIG"
	log::debug "P2POOL_LOG_LEVEL    | $P2POOL_LOG_LEVEL"
	log::debug "P2POOL_DATA_API     | $P2POOL_DATA_API"
	log::debug "P2POOL_LOCAL_API    | $P2POOL_LOCAL_API"
	log::debug "P2POOL_NO_CACHE     | $P2POOL_NO_CACHE"
	log::debug "P2POOL_NO_COLOR     | $P2POOL_NO_COLOR"
	log::debug "P2POOL_NO_RANDOMX   | $P2POOL_NO_RANDOMX"
	log::debug "P2POOL_OUT_PEERS    | $P2POOL_OUT_PEERS"
	log::debug "P2POOL_IN_PEERS     | $P2POOL_IN_PEERS"
	log::debug "P2POOL_START_MINING | $P2POOL_START_MINING"
	log::debug "P2POOL_MINI         | $P2POOL_MINI"
	log::debug "P2POOL_NO_AUTODIFF  | $P2POOL_NO_AUTODIFF"
	log::debug "P2POOL_RPC_LOGIN    | $P2POOL_RPC_LOGIN"
	log::debug "final p2pool command: $P2POOL_COMMAND"
	return 0
}
parse::state() {
	log::debug "starting"
	local i IFS=$'\n' STATE_ARRAY STATE_PATH || return 1
	if [[ -e "$RELATIVE/txt/state" ]]; then
		log::debug "state found, using: ${RELATIVE}/txt/state"
		mapfile STATE_ARRAY < "${RELATIVE}/txt/state" || return 2
	else
		print::exit "state file was not found"
	fi
	for i in ${STATE_ARRAY[@]}; do
		[[ $i = FIRST_TIME=true* ]]      && declare -g FIRST_TIME=true
		[[ $i = MONERO_BASH_VER=* ]]     && declare -g MONERO_BASH_VER="${i//*=}"
		[[ $i = MONERO_VER=* ]]          && declare -g MONERO_VER="${i//*=}"
		[[ $i = P2POOL_VER=* ]]          && declare -g P2POOL_VER="${i//*=}"
		[[ $i = XMRIG_VER=* ]]           && declare -g XMRIG_VER="${i//*=}"
		[[ $i = MONERO_BASH_OLD=true* ]] && declare -g MONERO_BASH_OLD=true
		[[ $i = MONERO_OLD=true* ]]      && declare -g MONERO_OLD=true
		[[ $i = P2POOL_OLD=true* ]]      && declare -g P2POOL_OLD=true
		[[ $i = XMRIG_OLD=true* ]]       && declare -g XMRIG_OLD=true
	done
	[[ $FIRST_TIME != true ]]        && declare -g FIRST_TIME=false
	[[ $MONERO_BASH_OLD != true ]]   && unset -v MONERO_BASH_OLD
	[[ $MONERO_OLD != true ]]        && unset -v MONERO_OLD
	[[ $P2POOL_OLD != true ]]        && unset -v P2POOL_OLD
	[[ $XMRIG_OLD != true ]]         && unset -v XMRIG_OLD
	log::debug "--- state file ---"
	log::debug "FIRST_TIME      | $FIRST_TIME"
	log::debug "MONERO_BASH_VER | $MONERO_BASH_VER"
	log::debug "MONERO_VER      | $MONERO_VER"
	log::debug "P2POOL_VER      | $P2POOL_VER"
	log::debug "XMRIG_VER       | $XMRIG_VER"
	log::debug "MONERO_BASH_OLD | $MONERO_BASH_OLD"
	log::debug "MONERO_OLD      | $MONERO_OLD"
	log::debug "P2POOL_OLD      | $P2POOL_OLD"
	log::debug "XMRIG_OLD       | $XMRIG_OLD"
}
pkg::download() {
	log::debug "starting"
	local i
	for i in $UPGRADE_LIST; do
		struct::pkg $i
		pkg::tmp::download
		if [[ ${PKG[short]} = xmrig ]]; then
			pkg::download::sig & JOB[${i}_download_sig]=$!
		fi
		pkg::download::hash & JOB[${i}_download_hash]=$!
		pkg::download::pkg & JOB[${i}_download_pkg]=$!
	done
	char UPGRADE_LIST_SIZE
	[[ $UPGRADE_LIST = *bash* ]]   && UPGRADE_LIST_SIZE="bash"
	[[ $UPGRADE_LIST = *p2pool* ]] && UPGRADE_LIST_SIZE="$UPGRADE_LIST_SIZE p2pool"
	[[ $UPGRADE_LIST = *xmrig* ]]  && UPGRADE_LIST_SIZE="$UPGRADE_LIST_SIZE xmrig"
	[[ $UPGRADE_LIST = *monero* ]] && UPGRADE_LIST_SIZE="$UPGRADE_LIST_SIZE monero"
	for i in $UPGRADE_LIST_SIZE; do
		struct::pkg $i
		log::debug "${PKG[pretty]} | waiting for download threads to complete"
		log::prog "${PKG[pretty]} | ${LINK_DOWN[${PKG[short]}]}"
		if [[ ${PKG[short]} = xmrig ]]; then
			if ! wait -f ${JOB[${i}_download_sig]}; then
				printf "\n"
				print::exit "Upgrade failure | ${PKG[pretty]} signature download failed"
			fi
		fi
		if ! wait -f ${JOB[${i}_download_hash]}; then
			printf "\n"
			print::exit "Upgrade failure | ${PKG[pretty]} hash download failed"
		fi
		if ! wait -f ${JOB[${i}_download_pkg]}; then
			printf "\n"
			print::exit "Upgrade failure | ${PKG[pretty]} package download failed"
		fi
		pkg::download::find_tar
		log::ok "${PKG[pretty]} | ${LINK_DOWN[${PKG[short]}]}"
	done
	return 0
}
pkg::download::sig() {
	log::debug "${PKG[pretty]} | starting sig download thread"
	[[ ${PKG[short]} != xmrig ]] && log::debug "${PKG[pretty]} sig file is not seperate, returning 0" && return 0
	if $DOWNLOAD_OUT "${TMP_PKG[${PKG[short]}_sig]}" "${LINK_SIG[${PKG[short]}]}"; then
		log::debug "${PKG[pretty]} | sig download OK"
	else
		log::debug "${PKG[pretty]} | sig download FAIL"
		return 1
	fi
}
pkg::download::hash() {
	log::debug "${PKG[pretty]} | starting hash download thread"
	if $DOWNLOAD_OUT "${TMP_PKG[${PKG[short]}_hash]}" "${LINK_HASH[${PKG[short]}]}"; then
		log::debug "${PKG[pretty]} | hash download OK"
	else
		log::debug "${PKG[pretty]} | hash download FAIL"
		return 1
	fi
}
pkg::download::pkg() {
	log::debug "${PKG[pretty]} | starting pkg download thread"
	if [[ $CURL = true ]]; then
		if (cd "${TMP_PKG[${PKG[short]}_pkg]}" && $DOWNLOAD_DIR "${LINK_DOWN[${PKG[short]}]}"); then
			log::debug "${PKG[pretty]} | pkg download OK"
		else
			log::debug "${PKG[pretty]} | pkg download FAIL"
			return 1
		fi
	else
		if $DOWNLOAD_DIR "${TMP_PKG[${PKG[short]}_pkg]}" "${LINK_DOWN[${PKG[short]}]}"; then
			log::debug "${PKG[pretty]} | pkg download OK"
		else
			log::debug "${PKG[pretty]} | pkg download FAIL"
			return 1
		fi
	fi
}
pkg::download::find_tar() {
	log::debug "${PKG[pretty]} | starting"
	map TMP_PKG[${PKG[short]}_tar]
	TMP_PKG[${PKG[short]}_tar]="$(ls ${TMP_PKG[${PKG[short]}_pkg]})"
	TMP_PKG[${PKG[short]}_tar]="${TMP_PKG[${PKG[short]}_pkg]}/${TMP_PKG[${PKG[short]}_tar]}"
	log::debug "downloaded tar: ${TMP_PKG[${PKG[short]}_tar]}"
}
pkg::extract() {
	log::debug "starting"
	local i
	for i in $UPGRADE_LIST; do
		struct::pkg $i
		pkg::extract::multi & JOB[${i}_extract]=$!
	done
	for i in $UPGRADE_LIST_SIZE; do
		struct::pkg $i
		log::debug "${PKG[pretty]} | waiting for extraction/copy thread to complete"
		log::prog "${PKG[pretty]}"
		if ! wait -f ${JOB[${i}_extract]}; then
			printf "\n"
			print::exit "Upgrade failure | ${PKG[pretty]} installation failure"
		fi
		log::ok "${PKG[pretty]}"
	done
	return 0
}
pkg::extract::multi() {
	log::debug "${PKG[pretty]} | starting extraction thread"
	if tar -xf "${TMP_PKG[${PKG[short]}_tar]}" -C "${TMP_PKG[${PKG[short]}_pkg]}"; then
		log::debug "${PKG[pretty]} | tar extract OK | ${TMP_PKG[${PKG[short]}_tar]}"
	else
		log::debug "${PKG[pretty]} | tar extract FAIL | ${TMP_PKG[${PKG[short]}_tar]}"
		return 1
	fi
	if rm "${TMP_PKG[${PKG[short]}_tar]}"; then
		log::debug "${PKG[pretty]} | tar rm OK | ${TMP_PKG[${PKG[short]}_tar]}"
	else
		log::debug "${PKG[pretty]} | tar rm FAIL | ${TMP_PKG[${PKG[short]}_tar]}"
		return 2
	fi
	TMP_PKG[${PKG[short]}_folder]="$(ls ${TMP_PKG[${PKG[short]}_pkg]})"
	TMP_PKG[${PKG[short]}_folder]="${TMP_PKG[${PKG[short]}_pkg]}/${TMP_PKG[${PKG[short]}_folder]}"
	log::debug "package folder: ${TMP_PKG[${PKG[short]}_folder]}"
	if [[ -z ${TMP_PKG[${PKG[short]}_folder]} || ${TMP_PKG[${PKG[short]}_folder]} =~ ^[[:space:]]+$ ]]; then
		log::debug "${PKG[pretty]} | NULL folder variable"
		return 3
	fi
	mkdir -p "${PKG[directory]}"
	if cp -fr "${TMP_PKG[${PKG[short]}_folder]}"/* "${PKG[directory]}"; then
		log::debug "copied ${TMP_PKG[${PKG[short]}_folder]} contents into ${PKG[directory]}"
	else
		log::debug "${PKG[pretty]} | cp folder FAIL"
		return 4
	fi
}
pkg::hook::pre() {
	log::debug "starting"
	log::prog "Saving state..."
	array HOOK_STATE
	mapfile HOOK_STATE < "$STATE"
	log::ok "State saved"
}
pkg::hook::post() {
	log::debug "starting"
	log::prog "Recreating old state..."
	printf "%s" "${HOOK_STATE[@]}" > "$STATE"
	log::ok "Recreated old state"
	[[ $UPGRADE_LIST = *bash* ]] && pkg::hook::post::bash
	local i
	for i in $UPGRADE_LIST; do
		struct::pkg $i
		pkg::hook::post::state
		pkg::hook::post::changes
		pkg::hook::post::config
		pkg::hook::post::systemd
	done
	case "$UPGRADE_LIST" in
		*monero*|*xmr*|*p2p*)
		log::prog "Reloading systemd..."
		systemd::reload
		log::ok "Reloaded systemd"
		;;
	esac
	log::prog "Setting file permissions..."
	sudo chmod -R 770 "$PACKAGES"
	sudo chown -R "monero-bash:$USER" "$PACKAGES"
	log::ok "Set file permissions"
}
pkg::hook::post::state() {
	log::debug "${PKG[pretty]} | starting"
	log::prog "${PKG[pretty]} | ... | ..."
	sed -i "s/${PKG[var]}_VER=.*/${PKG[var]}_VER=${VER[${PKG[short]}]}/g" "$STATE"
	sed -i "s/${PKG[var]}_OLD=.*/${PKG[var]}_OLD=/g" "$STATE"
	log::ok "${PKG[pretty]} | ${VER[${PKG[short]}]} | ${RELEASE[${PKG[short]}]}"
}
pkg::hook::post::changes() {
	log::debug "${PKG[pretty]} | starting"
	log::prog "Creating changelog for: ${PKG[pretty]}..."
	mkdir -p "$CHANGES"
	echo "# PACKAGE | ${PKG[pretty]}"            > "$CHANGES/${PKG[name]}"
	echo "# VERSION | ${VER[${PKG[short]}]}"     >> "$CHANGES/${PKG[name]}"
	echo "# RELEASE | ${RELEASE[${PKG[short]}]}" >> "$CHANGES/${PKG[name]}"
	echo "#" >> "$CHANGES/${PKG[name]}"
	echo "${BODY[${PKG[short]}]}" >> "$CHANGES/${PKG[name]}"
	log::ok "${PKG[pretty]} | Changelog created"
}
pkg::hook::post::config() {
	log::debug "${PKG[pretty]} | starting"
	log::prog "${PKG[pretty]} | Config check: ${PKG[conf_name]}..."
	if [[ -e ${PKG[conf]} ]]; then
		log::ok "${PKG[pretty]} | Config found: ${PKG[conf_name]}"
	else
		log::debug "no config found, copying $SRC_CONFIG/${PKG[conf_name]} to $CONFIG"
		cp "$SRC_CONFIG/${PKG[conf_name]}" "$CONFIG"
		log::ok "${PKG[pretty]} | Config installed: ${PKG[conf_name]}"
	fi
	if [[ ${PKG[name]} = monero ]]; then
		log::prog "${PKG[pretty]} | Config found: monero-wallet-cli.conf..."
		if [[ -e "$CONFIG/monero-wallet-cli.conf" ]]; then
			log::ok "${PKG[pretty]} | Config found: monero-wallet-cli.conf"
		else
			log::debug "no config found, copying $SRC_CONFIG/monero-wallet-cli.conf to $CONFIG"
			cp "$SRC_CONFIG/monero-wallet-cli.conf" "$CONFIG"
			log::ok "${PKG[pretty]} | Config installed: monero-wallet-cli.conf"
		fi
	fi
}
pkg::hook::post::systemd() {
	log::debug "${PKG[pretty]} | starting"
	log::prog "${PKG[pretty]} | systemd check: ${PKG[service]}..."
	if [[ -e "$SYSTEMD/${PKG[service]}" ]]; then
		log::ok "${PKG[pretty]} | systemd found: ${PKG[service]}"
	else
		log::debug "no systemd service found, creating: $SYSTEMD/${PKG[service]}"
		systemd::create
		log::ok "${PKG[pretty]} | systemd installed: ${PKG[service]}"
	fi
}
pkg::hook::post::bash() {
	log::debug "starting"
	unset -v DIFF
	local DIFF
	local IFS=$'\n' i
	log::prog "monero-bash | diff for: monero-bash.conf..."
	if DIFF=$(diff --side-by-side --left-column "$CONFIG_MONERO_BASH" "${TMP_PKG[bash_pkg]}/config/monero-bash.conf"); then
		log::ok "monero-bash | no diff: monero-bash.conf"
	else
		log::debug "--- monero-bash.conf diff ---"
		for i in $DIFF; do
			log::debug "$i"
		done
		DIFF=$(echo "$DIFF" | sed -e 's/[[:space:]]\+(//g' -e 's/[[:space:]]\+|.*$//g' -e 's/[[:space:]]\+>\t//g' -e 's/[[:space:]]\+>$//g')
		echo "$DIFF" > "$CONFIG_MONERO_BASH"
		log::ok "monero-bash | diff applied: monero-bash.conf"
	fi
	unset -v DIFF
	local DIFF
	log::prog "monero-bash | diff for: state..."
	if DIFF=$(diff --side-by-side --left-column "$STATE" "${TMP_PKG[bash_pkg]}/txt/state"); then
		log::ok "monero-bash | no diff: state"
	else
		log::debug "--- state diff ---"
		for i in $DIFF; do
			log::debug "$i"
		done
		DIFF=$(echo "$DIFF" | sed -e 's/[[:space:]]\+(//g' -e 's/[[:space:]]\+|.*$//g' -e 's/[[:space:]]\+>\t//g' -e 's/[[:space:]]\+>$//g')
		echo "$DIFF" > "$STATE"
		log::ok "monero-bash | diff applied: state"
	fi
	unset -v DIFF
	local DIFF
	[[ $P2POOL_VER ]] || return 0
	log::prog "p2pool | diff for: p2pool.conf..."
	if DIFF=$(diff --side-by-side --left-column "$CONFIG_P2POOL" "${TMP_PKG[bash_pkg]}/config/p2pool.conf"); then
		log::ok "p2pool | no diff: p2pool.conf"
	else
		log::debug "--- p2pool.conf diff ---"
		for i in $DIFF; do
			log::debug "$i"
		done
		DIFF=$(echo "$DIFF" | sed -e 's/[[:space:]]\+(//g' -e 's/[[:space:]]\+|.*$//g' -e 's/[[:space:]]\+>\t//g' -e 's/[[:space:]]\+>$//g')
		echo "$DIFF" > "$CONFIG_P2POOL"
		log::ok "p2pool | diff applied: p2pool.conf"
	fi
	return 0
}
pkg::info() {
	log::debug "starting"
	pkg::tmp::info info
	map VER RELEASE BODY LINK_DOWN LINK_HASH LINK_SIG
	local UPDATE_FOUND i j
	declare -a SCRATCH
	for i in $UPGRADE_LIST; do
		struct::pkg $i
		pkg::update::multi & JOB[${i}_update]=$!
	done
	for i in $UPGRADE_LIST; do
		struct::pkg $i
		log::debug "waiting for metadata threads to complete"
		if ! wait -f ${JOB[${i}_update]}; then
			log::fail "${PKG[pretty]} | metadata fetch"
			local UPDATE_FAILED=true
		fi
	done
	if [[ $UPDATE_FAILED = true ]]; then
		echo
		print::error "Upgrade failure | Metadata fetch from GitHub API failed"
		print::exit "Are you using a VPN/TOR? GitHub API will often rate-limit them."
	fi
	for i in $UPGRADE_LIST; do
		struct::pkg $i
		pkg::update::ver
		pkg::info::down
		pkg::info::hash
		[[ ${PKG[short]} = xmrig ]] && pkg::info::sig
		pkg::info::changes
		if [[ ${PKG[short]} = bash && ${VER[${PKG[short]}]} != v2* ]]; then
			log::debug "${PKG[pretty]} | new version found != v2* | printing EOL message"
			print::eol
			UPGRADE_LIST="${UPGRADE_LIST//bash}"
		fi
	done
}
pkg::info::down() {
	log::debug "starting: ${PKG[pretty]}"
	if [[ ${PKG[name]} = monero ]]; then
		LINK_DOWN[${PKG[short]}]="https://downloads.getmonero.org/cli/linux64"
		log::debug "package Monero detected, LINK_DOWN: ${LINK_DOWN[${PKG[short]}]}"
		return 0
	fi
	LINK_DOWN[${PKG[short]}]="$(grep -o "https://github.com/${PKG[author]}/${PKG[name]}/releases/download/${VER[${PKG[short]}]}/${PKG[regex]}" "${TMP_INFO[${PKG[short]}]}")"
	LINK_DOWN[${PKG[short]}]="${LINK_DOWN[${PKG[short]}]//\"}"
	log::debug "${PKG[pretty]} download link found: ${LINK_DOWN[${PKG[short]}]}"
}
pkg::info::hash() {
	log::debug "starting: ${PKG[pretty]}"
	if [[ ${PKG[name]} = monero ]]; then
		LINK_HASH[${PKG[short]}]="https://www.getmonero.org/downloads/hashes.txt"
		log::debug "package Monero detected, LINK_HASH: ${LINK_HASH[${PKG[short]}]}"
		return 0
	fi
	LINK_HASH[${PKG[short]}]="https://github.com/${PKG[author]}/${PKG[name]}/releases/download/${VER[${PKG[short]}]}/${PKG[hash]}"
	log::debug "${PKG[pretty]} hash link: ${LINK_HASH[${PKG[short]}]}"
}
pkg::info::sig() {
	log::debug "starting: ${PKG[pretty]}"
	LINK_SIG[${PKG[short]}]="https://github.com/${PKG[author]}/${PKG[name]}/releases/download/${VER[${PKG[short]}]}/${PKG[sig]}"
	log::debug "${PKG[pretty]} sig link: ${LINK_SIG[${PKG[short]}]}"
}
pkg::info::changes() {
	log::debug "starting: ${PKG[pretty]}"
	RELEASE[${PKG[short]}]="$(grep -m 1 "\"created_at\":" "${TMP_INFO[${PKG[short]}]}")"
	RELEASE[${PKG[short]}]="${RELEASE[${PKG[short]}]//*\"created_at\": }"
	RELEASE[${PKG[short]}]="${RELEASE[${PKG[short]}]//\"}"
	RELEASE[${PKG[short]}]="${RELEASE[${PKG[short]}]//,}"
	RELEASE[${PKG[short]}]="${RELEASE[${PKG[short]}]//T/ }"
	RELEASE[${PKG[short]}]="${RELEASE[${PKG[short]}]//Z/}"
	log::debug "${PKG[pretty]} RELEASE: ${RELEASE[${PKG[short]}]}"
	BODY[${PKG[short]}]="$(grep -m 1 "\"body\":" "${TMP_INFO[${PKG[short]}]}")"
	BODY[${PKG[short]}]="${BODY[${PKG[short]}]//*\"body\": \"}"
	BODY[${PKG[short]}]="${BODY[${PKG[short]}]:0:-2}"
	BODY[${PKG[short]}]="${BODY[${PKG[short]}]//\\r\\n/$'\n'}"
	log::debug "${PKG[pretty]} BODY: OK"
}
pkg::prompt() {
	log::debug "starting"
	local PROMPT_VERB PROMPT_NOUN
	if [[ $1 = install ]]; then
		PROMPT_VERB="Installing"
		PROMPT_NOUN="install"
	else
		PROMPT_VERB="Upgrading"
		PROMPT_NOUN="upgrade"
	fi
	char UPGRADE_LIST
	if [[ $1 = install ]]; then
		[[ $OPTION_BASH = true ]]   && UPGRADE_LIST="bash"
		[[ $OPTION_MONERO = true ]] && UPGRADE_LIST="$UPGRADE_LIST monero"
		[[ $OPTION_P2POOL = true ]] && UPGRADE_LIST="$UPGRADE_LIST p2pool"
		[[ $OPTION_XMRIG = true ]]  && UPGRADE_LIST="$UPGRADE_LIST xmrig"
		if [[ $OPTION_FORCE != true ]]; then
			for i in $UPGRADE_LIST; do
				struct::pkg $i
				pkg::prompt::check::install
			done
		fi
	elif [[ $1 = upgrade ]]; then
		[[ $MONERO_BASH_VER ]] && UPGRADE_LIST="bash"
		[[ $MONERO_VER ]]      && UPGRADE_LIST="$UPGRADE_LIST monero"
		[[ $P2POOL_VER ]]      && UPGRADE_LIST="$UPGRADE_LIST p2pool"
		[[ $XMRIG_VER ]]       && UPGRADE_LIST="$UPGRADE_LIST xmrig"
		if [[ $OPTION_FORCE != true ]]; then
			for i in $UPGRADE_LIST; do
				struct::pkg $i
				pkg::prompt::check::old
			done
		fi
	fi
	if [[ $UPGRADE_LIST =~ ^[[:space:]]+$ || -z $UPGRADE_LIST ]]; then
		log::debug "UPGRADE_LIST is empty, exiting"
		case "$1" in
			install) print::exit "No valid packages specified";;
			upgrade) printf "${BGREEN}%s${BWHITE}%s${OFF}\n" "|| " "All packages up to date"; exit 1;;
		esac
	fi
	if [[ $OPTION_VERBOSE = true ]]; then
		STD_LOG_DEBUG=true
		printf "${BPURPLE}%s${BWHITE}%s${OFF}\n" "!! " "$PROMPT_VERB verbosely!"
	fi
	[[ $OPTION_FORCE = true ]] && printf "${BPURPLE}%s${BWHITE}%s${OFF}\n" "!! " "$PROMPT_VERB forcefully!"
	[[ $OPTION_YES = true ]]   && printf "${BPURPLE}%s${BWHITE}%s${OFF}\n" "!! " "$PROMPT_VERB automatically!"
	echo
	local PROMPT_UPGRADE_LIST i
	for i in $UPGRADE_LIST; do
		case "$i" in
			bash)   PROMPT_UPGRADE_LIST="$PROMPT_UPGRADE_LIST  [monero-bash]";;
			monero) PROMPT_UPGRADE_LIST="$PROMPT_UPGRADE_LIST  [Monero]";;
			p2pool) PROMPT_UPGRADE_LIST="$PROMPT_UPGRADE_LIST  [P2Pool]";;
			xmrig) PROMPT_UPGRADE_LIST="$PROMPT_UPGRADE_LIST  [XMRig]";;
		esac
	done
	printf "${BBLUE}%s${BWHITE}%s${OFF}%s\n${BBLUE}%s\n%s${BWHITE}%s${OFF}" \
		"|| " \
		"Packages to $PROMPT_NOUN: " \
		"$PROMPT_UPGRADE_LIST" \
		"|| " \
		"|| " \
		"Continue with ${PROMPT_NOUN}? (Y/n) "
	if [[ $OPTION_YES = true ]]; then
		printf "${BBLUE}%s${OFF}\n" "AUTOMATIC ${PROMPT_NOUN^^} STARTING"
	else
		if ! ask::yes; then
			printf "${BRED}%s${BWHITE}%s${OFF}\n" \
				"|| " \
				"Canceling $PROMPT_NOUN"
			exit 1
		fi
	fi
	if ! ask::sudo; then
		print::exit "sudo is required"
	fi
	log::debug "starting $PROMPT_NOUN of packages: $UPGRADE_LIST"
	pkg::upgrade $1
}
pkg::prompt::check::install() {
	log::debug "starting | ${PKG[pretty]}"
	if [[ ${PKG[current_version]} ]]; then
		printf "${BYELLOW}%s${OFF}%s\n" "!! " "[${PKG[pretty]}] (${PKG[current_version]}) is already installed | skipping"
		UPGRADE_LIST="${UPGRADE_LIST//${PKG[short]}}"
	fi
}
pkg::prompt::check::old() {
	log::debug "starting | ${PKG[pretty]}"
	if [[ ${PKG[old]} != true ]]; then
		log::debug "[${PKG[pretty]}] (${PKG[current_version]}) is up to date | skipping"
		UPGRADE_LIST="${UPGRADE_LIST//${PKG[short]}}"
	fi
}
pkg::remove::prompt() {
	if [[ $OPTION_VERBOSE = true ]]; then
		STD_LOG_DEBUG=true
		printf "${BPURPLE}%s${BWHITE}%s${OFF}\n" "!! " "Removing verbosely!"
	fi
	[[ $OPTION_YES = true ]] && printf "${BPURPLE}%s${BWHITE}%s${OFF}\n" "!! " "Removing automatically!"
	echo
	log::debug "starting"
	local REMOVE_LIST || return 1
	if [[ $OPTION_BASH = true ]]; then
		printf "${BYELLOW}%s${OFF}%s\n${BYELLOW}%s${OFF}%s${BCYAN}%s${OFF}%s\n" \
			"!! " \
			"[monero-bash] ($MONERO_BASH_VER) cannot be removed normally" \
			"!! " \
			"Type: " \
			"[monero-bash uninstall] " \
			"to cleanly uninstall monero-bash from your system"
		exit 1
	fi
	[[ $OPTION_MONERO = true ]] && REMOVE_LIST="$REMOVE_LIST monero"
	[[ $OPTION_P2POOL = true ]] && REMOVE_LIST="$REMOVE_LIST p2pool"
	[[ $OPTION_XMRIG = true ]]  && REMOVE_LIST="$REMOVE_LIST xmrig"
	if [[ $OPTION_MONERO = true && -z $MONERO_VER ]]; then
		printf "${OFF}%s\n" "[Monero] is not installed"
		REMOVE_LIST="${REMOVE_LIST//monero}"
	fi
	if [[ $OPTION_P2POOL = true && -z $P2POOL_VER ]]; then
		printf "${OFF}%s\n" "[P2Pool] is not installed"
		REMOVE_LIST="${REMOVE_LIST//p2pool}"
	fi
	if [[ $OPTION_XMRIG = true && -z $XMRIG_VER ]]; then
		printf "${OFF}%s\n" "[XMRig] is not installed"
		REMOVE_LIST="${REMOVE_LIST//xmrig}"
	fi
	if [[ $REMOVE_LIST =~ ^[[:space:]]+$ || -z $REMOVE_LIST ]]; then
		log::debug "REMOVE_LIST is empty, exiting"
		exit 1
	fi
	local PROMPT_REMOVE_LIST i
	for i in $REMOVE_LIST; do
		case "$i" in
			monero) PROMPT_REMOVE_LIST="$PROMPT_REMOVE_LIST  [Monero]";;
			p2pool) PROMPT_REMOVE_LIST="$PROMPT_REMOVE_LIST  [P2Pool]";;
			xmrig) PROMPT_REMOVE_LIST="$PROMPT_REMOVE_LIST  [XMRig]";;
		esac
	done
	printf "${BRED}%s${BWHITE}%s${OFF}%s\n${BRED}%s\n${BRED}%s${BWHITE}%s" \
		"|| " \
		"Packages to remove: " \
		"$PROMPT_REMOVE_LIST" \
		"|| " \
		"|| " \
		"Continue with removal? (y/N) "
	if [[ $OPTION_YES = true ]]; then
		printf "${BBLUE}%s${OFF}\n" "AUTOMATIC REMOVAL STARTING"
	else
		if ask::no; then
			printf "${BGREEN}%s${OFF}%s\n" "|| " "Canceling installation"
			exit 1
		fi
	fi
	if ! ask::sudo; then
		print::exit "sudo is required"
	fi
	for i in $REMOVE_LIST; do
		struct::pkg $i
		pkg::remove
	done
	exit 0
}
pkg::remove() {
	log::debug "${PKG[pretty]} | starting"
	log::debug "Ignoring INT signal for safety"
	trap "" INT
	print::pkg::remove
	log::debug "Setting trap to continue removal on EXIT signal"
	trap 'trap::remove' EXIT
	log::prog "Removing ${PKG[directory]}..."
	rm -rf "${PKG[directory]}"
	log::ok "Removed ${PKG[directory]}"
	log::prog "Removing ${PKG[service]}..."
	sudo rm -f "${SYSTEMD:?}/${PKG[service]:?}"
	log::ok "Removed ${PKG[service]}"
	log::prog "Removing ${CHANGES:?}/${PKG[name]:?}..."
	rm -rf "${CHANGES:?}/${PKG[name]:?}"
	log::ok "Removed ${CHANGES:?}/${PKG[name]:?}"
	log::prog "Updating local state..."
	sudo sed \
		-i -e "s/${PKG[var]}_VER=.*/${PKG[var]}_VER=/" "$STATE" \
		-i -e "s/${PKG[var]}_OLD=.*/${PKG[var]}_OLD=\"true\"/" "$STATE"
	log::debug "STATE | ${PKG[var]}_VER -> null"
	log::debug "STATE | ${PKG[var]}_OLD -> true"
	log::ok "Updated local state"
	log::debug "Resetting INT and EXIT signals"
	trap - INT EXIT
	log::prog "Reloading systemd..."
	systemd::reload
	log::ok "Reloaded systemd"
	log::debug "${PKG[pretty]} | removal OK"
	print::pkg::removed
	return 0
}
pkg::tmp::download() {
	log::debug "starting: ${PKG[pretty]}"
	declare -Ag TMP_PKG
	TMP_PKG[${PKG[short]}_main]="$(mktemp -d /tmp/monero-bash-${PKG[short]}.XXXXXXXXXX)"
	TMP_PKG[${PKG[short]}_pkg]="$(mktemp -d ${TMP_PKG[${PKG[short]}_main]}/pkg.XXX)"
	TMP_PKG[${PKG[short]}_gpg]="$(mktemp ${TMP_PKG[${PKG[short]}_main]}/gpg.XXX)"
	TMP_PKG[${PKG[short]}_sig]="$(mktemp ${TMP_PKG[${PKG[short]}_main]}/sig.XXX)"
	TMP_PKG[${PKG[short]}_hash]="$(mktemp ${TMP_PKG[${PKG[short]}_main]}/hash.XXX)"
	TMP_PKG[${PKG[short]}_changes]="$(mktemp ${TMP_PKG[${PKG[short]}_main]}/changes.XXX)"
	TMP_PKG[${PKG[short]}_key]="$(mktemp ${TMP_PKG[${PKG[short]}_main]}/key.XXX)"
	TMP_PKG[${PKG[short]}_key_output]="$(mktemp ${TMP_PKG[${PKG[short]}_main]}/output.XXX)"
	TMP_PKG[${PKG[short]}_hash_calc]="$(mktemp ${TMP_PKG[${PKG[short]}_main]}/calc.XXX)"
	TMP_PKG[${PKG[short]}_folder]="$(mktemp ${TMP_PKG[${PKG[short]}_main]}/folder.XXX)"
	log::debug "--- tmp pkg folder for ${PKG[pretty]} ---"
	log::debug "TMP_PKG[main]       | ${TMP_PKG[${PKG[short]}_main]}"
	log::debug "TMP_PKG[pkg]        | ${TMP_PKG[${PKG[short]}_pkg]}"
	log::debug "TMP_PKG[gpg]        | ${TMP_PKG[${PKG[short]}_gpg]}"
	log::debug "TMP_PKG[sig]        | ${TMP_PKG[${PKG[short]}_sig]}"
	log::debug "TMP_PKG[hash]       | ${TMP_PKG[${PKG[short]}_hash]}"
	log::debug "TMP_PKG[changes]    | ${TMP_PKG[${PKG[short]}_changes]}"
	log::debug "TMP_PKG[key]        | ${TMP_PKG[${PKG[short]}_key]}"
	log::debug "TMP_PKG[key_output] | ${TMP_PKG[${PKG[short]}_key_output]}"
	log::debug "TMP_PKG[hash_calc]  | ${TMP_PKG[${PKG[short]}_hash_calc]}"
	log::debug "TMP_PKG[folder]     | ${TMP_PKG[${PKG[short]}_folder]}"
}
pkg::tmp::info() {
	log::debug "starting for: $1"
	pkg::tmp::remove
	map TMP_INFO TMP_INFO[main] TMP_INFO[bash] TMP_INFO[monero] TMP_INFO[p2pool] TMP_INFO[xmrig]
	if [[ $1 = update ]]; then
		TMP_INFO[main]="$(mktemp -d /tmp/monero-bash-info.XXXXXXXXXX)"
		TMP_INFO[bash]="$(mktemp ${TMP_INFO[main]}/bash-info.XXX)"
		[[ $MONERO_VER ]] && TMP_INFO[monero]="$(mktemp ${TMP_INFO[main]}/monero-info.XXX)"
		[[ $P2POOL_VER ]] && TMP_INFO[p2pool]="$(mktemp ${TMP_INFO[main]}/p2pool-info.XXX)"
		[[ $XMRIG_VER ]]  && TMP_INFO[xmrig]="$(mktemp ${TMP_INFO[main]}/xmrig-info.XXX)"
	elif [[ $1 = info ]]; then
		TMP_INFO[main]="$(mktemp -d /tmp/monero-bash-info.XXXXXXXXXX)"
		[[ $UPGRADE_LIST = *bash* ]]     && TMP_INFO[bash]="$(mktemp ${TMP_INFO[main]}/bash-info.XXX)"
		[[ $UPGRADE_LIST = *monero* ]] && TMP_INFO[monero]="$(mktemp ${TMP_INFO[main]}/monero-info.XXX)"
		[[ $UPGRADE_LIST = *p2p* ]]      && TMP_INFO[p2pool]="$(mktemp ${TMP_INFO[main]}/p2pool-info.XXX)"
		[[ $UPGRADE_LIST = *xmr* ]]      && TMP_INFO[xmrig]="$(mktemp ${TMP_INFO[main]}/xmrig-info.XXX)"
	fi
	log::debug "--- tmp info folder ---"
	log::debug "TMP_INFO[main]   | ${TMP_INFO[main]}"
	log::debug "TMP_INFO[bash]   | ${TMP_INFO[bash]}"
	log::debug "TMP_INFO[monero] | ${TMP_INFO[monero]}"
	log::debug "TMP_INFO[p2pool] | ${TMP_INFO[p2pool]}"
	log::debug "TMP_INFO[xmrig]  | ${TMP_INFO[xmrig]}"
	return 0
}
pkg::tmp::remove() {
	log::debug "starting"
	if find /tmp/monero-bash* &>/dev/null; then
		log::debug "old tmp folders found, removing"
		if rm -rf /tmp/monero-bash*; then
			log::debug "rm tmp folder OK"
		else
			log::debug "rm tmp folder FAIL"
			return 1
		fi
	else
		log::debug "no old tmp folders found, skipping"
	fi
}
pkg::trap::pkg_folders() {
	log::debug "starting"
	printf "%s\n\n" ""
	printf "${BRED}%s${BYELLOW}%s${OFF}%s${BWHITE}%s${OFF}\n" \
	"[monero-bash] " \
	"exit signal caught " \
	"| " \
	"cleaning up temporary files"
	pkg::tmp::remove
}
pkg::trap::state::old() {
	log::debug "starting"
	echo "${HOOK_BASH_STATE[@]}" > "$STATE"
}
pkg::trap::remove() {
	log::debug "starting"
	printf "${BRED}%s${BYELLOW}%s${OFF}%s${BWHITE}%s${OFF}\n" \
	"[monero-bash] " \
	"exit signal caught " \
	"| " \
	"updating local state"
	sudo sed \
		-i -e "s/${PKG[var]}_VER=./${PKG[var]}_VER=/" "$STATE" \
		-i -e "s/${PKG[var]}_OLD=./${PKG[var]}_OLD=\"true\"/" "$STATE"
}
pkg::update() {
	if [[ $OPTION_VERBOSE = true ]]; then
		STD_LOG_DEBUG=true
		printf "${BPURPLE}%s${BWHITE}%s${OFF}\n" "!! " "Updating verbosely!"
	fi
	log::debug "starting"
	trap 'pkg::tmp::remove; lock::free monero_bash_update; exit 1' EXIT
	if lock::alloc "monero_bash_update"; then
		log::debug "created lock: ${STD_LOCK_FILE[monero_bash_update]}"
	else
		print::error "Could not get update lock!"
		print::exit  "Is there another [monero-bash] update running?"
	fi
	pkg::tmp::info update
	map VER
	[[ $JOB ]] || map JOB
	local UPDATE_LIST UPDATE_FOUND j
	declare -a SCRATCH
	log::prog "Fetching package metadata"
	struct::pkg bash
	UPDATE_LIST="${PKG[short]}"
	pkg::update::multi & JOB[${PKG[short]}_update]=$!
	if [[ $MONERO_VER ]]; then
		struct::pkg monero
		UPDATE_LIST="$UPDATE_LIST ${PKG[short]}"
		pkg::update::multi & JOB[${PKG[short]}_update]=$!
	fi
	if [[ $P2POOL_VER ]]; then
		struct::pkg p2pool
		UPDATE_LIST="$UPDATE_LIST ${PKG[short]}"
		pkg::update::multi & JOB[${PKG[short]}_update]=$!
	fi
	if [[ $XMRIG_VER ]]; then
		struct::pkg xmrig
		UPDATE_LIST="$UPDATE_LIST ${PKG[short]}"
		pkg::update::multi & JOB[${PKG[short]}_update]=$!
	fi
	for i in $UPDATE_LIST; do
		struct::pkg $i
		log::debug "${PKG[pretty]} | waiting for metadata thread to complete"
		if wait -f ${JOB[${PKG[short]}_update]}; then
		    log::debug "${PKG[pretty]} | metadata OK"
		else
			log::fail "${PKG[pretty]}"
			local UPDATE_FAILED=true
		fi
	done
	if [[ $UPDATE_FAILED = true ]]; then
		print::error "Update failure | GitHub API connection failure"
		print::exit "Are you using a VPN/TOR? GitHub API will often rate-limit them."
	else
		log::ok "Fetched package metadata"
	fi
	echo
	struct::pkg bash
	pkg::update::ver
	pkg::update::result
	if [[ $MONERO_VER ]]; then
		struct::pkg monero
		pkg::update::ver
		pkg::update::result
	fi
	if [[ $P2POOL_VER ]]; then
		struct::pkg p2pool
		pkg::update::ver
		pkg::update::result
	fi
	if [[ $XMRIG_VER ]]; then
		struct::pkg xmrig
		pkg::update::ver
		pkg::update::result
	fi
	if [[ $UPDATE_FOUND ]]; then
		trap 'pkg::tmp::remove; lock::free monero_bash_update; exit' EXIT
		printf "${BBLUE}%s\n%s${BWHITE}%s${BYELLOW}%s${BWHITE}%s${OFF}\n" \
			"|| " \
			"|| " \
			"Updates found, type: " \
			"[monero-bash upgrade] " \
			"to upgrade all packages"
		log::debug "Updates found, exiting 0"
		exit 0
	else
		printf "${BBLUE}%s\n${BRED}%s${BWHITE}%s${OFF}\n" \
			"|| " \
			"|| " \
			"All packages up-to-date"
		log::debug "No updates found, exiting 1"
		exit 1
	fi
}
pkg::update::multi() {
	log::debug "starting metadata thread for: ${PKG[pretty]}"
	if $DOWNLOAD_OUT "${TMP_INFO[${PKG[short]}]}" "${PKG[link_api]}"; then
		log::debug "${PKG[pretty]} | metadata download OK"
		log::debug "downloaded ${PKG[link_api]} into ${TMP_INFO[${PKG[short]}]}"
	else
		log::debug "${PKG[pretty]} metadata download FAIL"
		return 1
	fi
}
pkg::update::ver() {
	log::debug "starting: ${PKG[pretty]}"
	VER[${PKG[short]}]="$(grep -m 1 "\"tag_name\":" "${TMP_INFO[${PKG[short]}]}")"
	log::debug "${PKG[pretty]} | initial \"tag_name\" filter | ${VER[${PKG[short]}]}"
	VER[${PKG[short]}]="${VER[${PKG[short]}]//*: }"
	VER[${PKG[short]}]="${VER[${PKG[short]}]//\"}"
	VER[${PKG[short]}]="${VER[${PKG[short]}]//,}"
	if [[ ${VER[${PKG[short]}]} != v* ]]; then
		log::debug "${PKG[pretty]} weird version found | ${VER[${PKG[short]}]}"
		log::debug "${PKG[pretty]} restarting metadata download"
		pkg::update::multi || print::error "Update failure | GitHub API returned funky data"
		VER[${PKG[short]}]="$(grep -m 1 "\"tag_name\":" "${TMP_INFO[${PKG[short]}]}")"
		log::debug "${PKG[pretty]} | initial \"tag_name\" filter | ${VER[${PKG[short]}]}"
		VER[${PKG[short]}]="${VER[${PKG[short]}]//*: }"
		VER[${PKG[short]}]="${VER[${PKG[short]}]//\"}"
		VER[${PKG[short]}]="${VER[${PKG[short]}]//,}"
		if [[ ${VER[${PKG[short]}]} != v* ]]; then
			echo
			print::error "Upgrade failure | ${PKG[pretty]} version fetch error"
			print::error "Congratulations! You've encountered an error I have no idea how to fix!"
			print::error "For some reason, GitHub API sends its JSON data in a single line..."
			print::error "BUT ONLY SOMETIMES, SO IT'S IMPOSSIBLE TO DEBUG :D"
			print::exit  "You can retry your update/install/upgrade and it will most likely work."
		fi
	fi
	log::debug "${PKG[pretty]} | version filtered: ${VER[${PKG[short]}]}"
}
pkg::update::result() {
	local UPDATE_NAME
	case "${PKG[short]}" in
		*bash*) UPDATE_NAME="monero-bash | ";;
		monero) UPDATE_NAME="Monero      | ";;
		*p2p*)  UPDATE_NAME="P2Pool      | ";;
		*xmr*)  UPDATE_NAME="XMRig       | ";;
	esac
	if [[ ${PKG[current_version]} = "${VER[${PKG[short]}]}" ]]; then
		log::debug "fetched version matches state, printing BGREEN"
		printf "${BBLUE}%s${BWHITE}%s${BGREEN}%s\n" \
			"|| " "$UPDATE_NAME" "${PKG[current_version]}"
	else
		log::debug "fetched version different from state, updating state and printing BRED"
		sed -i "s/${PKG[var]}_OLD=.*/${PKG[var]}_OLD=true/" "$STATE"
		UPDATE_FOUND=true
		printf "${BRED}%s${BWHITE}%s${BRED}%s${BWHITE}%s${BGREEN}%s\n" \
			"|| " "$UPDATE_NAME" "${PKG[current_version]} " "-> " "${VER[${PKG[short]}]}"
	fi
	return 0
}
pkg::upgrade() {
	log::debug "starting"
	if [[ $1 = install ]]; then
		log::debug "packages getting installed: $UPGRADE_LIST"
	else
		log::debug "packages getting upgraded: $UPGRADE_LIST"
	fi
	map JOB
	if lock::alloc monero_bash_upgrade; then
		trap 'pkg::trap::pkg_folders; lock::free monero_bash_upgrade; kill -s KILL 0; exit 1' EXIT
		log::debug "created lock file: ${STD_LOCK_FILE[monero_bash_upgrade]}"
	else
		log::debug "lock file already found: $(find /tmp/std_lock_monero_bash* || :)"
		print::error "Could not get lock!"
		print::exit  "Is there another [monero-bash] install/upgrade running?"
	fi
	print::pkg::download
	log::prog "Fetching package metadata... "
	pkg::info
	log::ok "Fetched package metadata"
	if [[ $UPGRADE_LIST =~ ^[[:space:]]+$ || -z $UPGRADE_LIST ]]; then
		print::pkg::upgrade_fail
		log::debug "UPGRADE_LIST is empty, exiting"
		exit 1
	fi
	trap 'pkg::trap::pkg_folders; lock::free monero_bash_upgrade; kill -s KILL 0; exit 1' EXIT
	pkg::download
	print::pkg::verify
	pkg::verify
	if [[ $UPGRADE_LIST =~ ^[[:space:]]+$ || -z $UPGRADE_LIST ]]; then
		print::pkg::upgrade_fail
		log::debug "UPGRADE_LIST is empty, exiting"
		exit 1
	fi
	print::pkg::hook::pre
	pkg::hook::pre
	if [[ $1 = install ]]; then
		print::pkg::install
	else
		print::pkg::upgrade
	fi
	pkg::extract
	trap 'pkg::hooks::post &>/dev/null; pkg::trap::pkg_folders; lock::free monero_bash_upgrade; kill -s KILL 0; exit 1' EXIT
	print::pkg::hook::post
	pkg::hook::post
	log::debug "freeing lock file: ${STD_LOCK_FILE[monero_bash_upgrade]}"
	lock::free monero_bash_upgrade
	trap 'pkg::trap::pkg_folders' EXIT
	pkg::tmp::remove
	trap - EXIT
	if [[ $1 = install ]]; then
		print::pkg::installed
	else
		print::pkg::upgraded
	fi
	log::debug "pkg::upgrade() done"
	exit 0
}
pkg::verify() {
	log::debug "starting"
	local i
	unset -v JOB_HASH
	map HASH
	char VERIFY_MSG
	for i in $UPGRADE_LIST; do
		struct::pkg $i
		pkg::verify::hash_calc & JOB[${PKG[short]}_hash]=$!
		pkg::verify::check_key & JOB[${PKG[short]}_key]=$!
	done
	for i in $UPGRADE_LIST; do
		struct::pkg $i
		log::debug "waiting for hash_calc() & check_key() threads to complete"
		if ! wait -f ${JOB[${PKG[short]}_hash]}; then
			print::exit "${PKG[pretty]} | hash calculation failed"
		fi
		if ! wait -f ${JOB[${PKG[short]}_key]}; then
			print::exit "${PKG[pretty]} | ${PKG[gpg_owner]} PGP key download/import failed"
		fi
	done
	for i in $UPGRADE_LIST; do
		struct::pkg $i
		log::prog "${PKG[pretty]} | HASH ... | PGP Signed by ..."
		pkg::verify::hash &&
		pkg::verify::pgp  &&
		log::ok "${PKG[pretty]} | ${VERIFY_MSG[${PKG[short]}]}" ||
		log::fail "${PKG[pretty]} | ${VERIFY_MSG[${PKG[short]}]}"
	done
}
pkg::verify::hash_calc() {
	log::debug "starting: ${PKG[pretty]}"
	if sha256sum "${TMP_PKG[${PKG[short]}_tar]}" > "${TMP_PKG[${PKG[short]}_hash_calc]}"; then
		log::debug "${PKG[pretty]} | hash_calc OK"
	else
		log::debug "${PKG[pretty]} | hash_calc FAIL"
		return 1
	fi
}
pkg::verify::check_key() {
	log::debug "starting: ${PKG[pretty]}"
	if gpg --list-keys "${PKG[fingerprint]}" &>/dev/null; then
		log::debug "PGP key found: ${PKG[gpg_owner]} | ${PKG[fingerprint]}"
	else
		log::debug "PGP key not found: ${PKG[gpg_owner]} | ${PKG[fingerprint]}"
		printf "${BWHITE}%s${BYELLOW}%s${BWHITE}%s${OFF}\n" \
			"Importing " \
			"${PKG[gpg_owner]}'s " \
			"PGP key..."
		log::debug "storing ${PKG[gpg_owner]}.asc into: ${TMP_PKG[${PKG[short]}_key]}"
		log::debug "storing import output into: ${TMP_PKG[${PKG[short]}_key_output]}"
		log::debug "${PKG[gpg_owner]} | starting PGP key download thread | ${PKG[gpg_pub_key]}"
		if $DOWNLOAD_OUT "${TMP_PKG[${PKG[short]}_key]}" "${PKG[gpg_pub_key]}"; then
			log::debug "${PKG[gpg_owner]} | PGP key download OK"
		else
			log::debug "${PKG[gpg_owner]} | PGP key download FAIL"
			return 1
		fi
		if gpg --import "${TMP_PKG[${PKG[short]}_key]}" &> "${TMP_PKG[${PKG[short]}_key_output]}"; then
			log::debug "${PKG[gpg_pub_key]} | PGP key import OK"
		else
			log::debug "${PKG[gpg_pub_key]} | PGP key import FAIL"
			return 2
		fi
		local IMPORT_KEY_OUTPUT i IFS=$'\n'
		mapfile IMPORT_KEY_OUTPUT < "${TMP_PKG[${PKG[short]}_key_output]}"
		log::debug "--- imported ${PKG[gpg_owner]}'s PGP key ---"
		for i in ${IMPORT_KEY_OUTPUT[@]}; do
			log::debug "$i"
		done
	fi
}
pkg::verify::hash() {
	log::debug "starting: ${PKG[pretty]}"
	map VERIFY_MSG[${PKG[short]}]
	local VERIFY_HASH
	mapfile VERIFY_HASH < "${TMP_PKG[${PKG[short]}_hash_calc]}"
	HASH[${PKG[short]}]="${VERIFY_HASH// *}"
	log::debug "${PKG[pretty]} HASH | ${HASH[${PKG[short]}]}"
	if [[ -z ${HASH[${PKG[short]}]} || ${HASH[${PKG[short]}]} =~ ^[[:space:]]+$ ]]; then
		echo
		print::exit "Upgrade failure | NULL Hash variable"
	fi
	if grep -o "${HASH[${PKG[short]}],,}" "${TMP_PKG[${PKG[short]}_hash]}" &>/dev/null; then
		log::debug "${PKG[pretty]} | lower-case hash match found"
		local HASH_START HASH_END HASH_DIGIT
		HASH_DIGIT="${#HASH[${PKG[short]}]}"
		HASH_START="${HASH[${PKG[short]}]:0:6}"
		HASH_END="$((HASH_DIGIT-6))"
		HASH_END="${HASH[${PKG[short]}]:${HASH_END}}"
		VERIFY_MSG[${PKG[short]}]="HASH: ${HASH_START}...${HASH_END}"
	elif grep -o "${HASH[${PKG[short]}]^^}" "${TMP_PKG[${PKG[short]}_hash]}" &>/dev/null; then
		log::debug "${PKG[pretty]} | upper-case hash match found"
		local HASH_START HASH_END HASH_DIGIT
		HASH_DIGIT="${#HASH[${PKG[short]}]}"
		HASH_START="${HASH[${PKG[short]}]:0:6}"
		HASH_END="$((HASH_DIGIT-6))"
		HASH_END="${HASH[${PKG[short]}]:${HASH_END}}"
		VERIFY_MSG[${PKG[short]}]="HASH: ${HASH_START}...${HASH_END}"
	else
		printf "\r\e[2K"
		print::compromised::hash
		log::debug "${PKG[pretty]} | HASH COMPROMISED | removing from UPGRADE_LIST"
		VERIFY_MSG[${PKG[short]}]="HASH FAIL"
		UPGRADE_LIST="${UPGRADE_LIST//${PKG[short]}}"
		return 1
	fi
}
pkg::verify::pgp() {
	log::debug "starting: ${PKG[pretty]}"
	if [[ ${PKG[short]} = xmrig ]]; then
		local VERIFY_PGP_CMD="gpg --verify ${TMP_PKG[${PKG[short]}_sig]} ${TMP_PKG[${PKG[short]}_hash]}"
	else
		local VERIFY_PGP_CMD="gpg --verify ${TMP_PKG[${PKG[short]}_hash]}"
	fi
	if $VERIFY_PGP_CMD &> ${TMP_PKG[${PKG[short]}_gpg]}; then
		VERIFY_MSG[${PKG[short]}]="${VERIFY_MSG[${PKG[short]}]} | PGP signed by: ${PKG[gpg_owner]}"
		local PGP_OUTPUT IFS=$'\n' i
		mapfile PGP_OUTPUT < "${TMP_PKG[${PKG[short]}_gpg]}"
		log::debug "PGP success for ${PKG[gpg_owner]}: ${TMP_PKG[${PKG[short]}_hash]}"
		for i in ${PGP_OUTPUT[@]}; do
			log::debug "$i"
		done
	else
		VERIFY_MSG[${PKG[short]}]="${VERIFY_MSG[${PKG[short]}]} | PGP FAIL: ${PKG[gpg_owner]}"
		local PGP_OUTPUT IFS=$'\n' i
		mapfile PGP_OUTPUT < "${TMP_PKG[${PKG[short]}_gpg]}"
		log::debug "PGP failure for ${PKG[gpg_owner]}: ${TMP_PKG[${PKG[short]}_hash]}"
		for i in ${PGP_OUTPUT[@]}; do
			log::debug "$i"
		done
		printf "\r\e[2K"
		print::compromised::pgp
		log::debug "${PKG[pretty]} | PGP COMPROMISED | removing from UPGRADE_LIST"
		UPGRADE_LIST="${UPGRADE_LIST//${PKG[short]}}"
		return 1
	fi
}
print::changes::list() {
	log::debug "$1 | starting"
	local i CHANGE_LIST
	[[ $OPTION_BASH = true ]]   && CHANGE_LIST="monero-bash"
	[[ $OPTION_MONERO = true ]] && CHANGE_LIST="${CHANGE_LIST} monero"
	[[ $OPTION_P2POOL = true ]] && CHANGE_LIST="${CHANGE_LIST} p2pool"
	[[ $OPTION_XMRIG = true ]]  && CHANGE_LIST="${CHANGE_LIST} xmrig"
	for i in $CHANGE_LIST; do
		if [[ -e "$CHANGES/$i" ]]; then
			log::debug "$CHANGES/$i found"
		else
			print::exit "$CHANGES/$i was not found!"
		fi
	done
	for i in $CHANGE_LIST; do
		if [[ $OPTION_PRINT = true ]]; then
			log::debug "$i | printing changelog"
			print::changes "$i"
		else
			log::debug "$i | piping to: less -R -N"
			print::changes "$i" | less -R -N
		fi
	done
}
print::changes() {
	set -f
	local LINE WORD IFS=$'\n' i w CODE TITLE s FIRST SET_BOLD
	mapfile LINE < "$CHANGES/$1"
	FIRST=true
	for i in ${LINE[@]}; do
		i="${i//$'\r'}"
		unset -v WORD
		s=''
		IFS=' '
		WORD=($i)
		for w in ${WORD[@]}; do
		case "$i" in
			\#*)
				if [[ ${w//[[:blank:]]} = \#* ]]; then
					if [[ $TITLE = true ]]; then
						printf "${BCYAN}%s" "$w "
					else
						if [[ $FIRST = true ]]; then
							printf "${BCYAN}%s" "$w "
							FIRST=
						else
							printf "\n${BCYAN}%s" "$w "
						fi
					fi
					TITLE=true
					continue
				fi
				;;
			*\`\`\`*)
				if [[ $CODE = true ]]; then
					CODE=
					printf "${OFF}"
					break
				else
					CODE=true
					break
				fi
				;;
			*)
				if [[ $CODE = true ]]; then
					printf "${BYELLOW}%s" "    $i"
					break
				elif [[ $TITLE = true ]]; then
					printf "${OFF}"
					TITLE=
				fi
				;;
		esac
		case "${w//[[:blank:]]}" in
			\*)
				if [[ ${i//[[:blank:]]} = \** ]]; then
					printf "${BWHITE}%s${OFF}" "${i//\**}  •"
				else
					printf "${OFF}%s" "${s}${w}"
				fi
				;;
			-)
				if [[ ${i//[[:blank:]]} = -* ]]; then
					printf "${BWHITE}%s${OFF}" "${i//\-*}  -"
				else
					printf "${OFF}%s" "${s}${w}"
				fi
				;;
			\**\*)
				printf "${BWHITE}%s${OFF}" "${s}${w//\*}";;
			\**)
				printf "${BWHITE}%s" "${s}${w//\*}"
				SET_BOLD=true
				;;
			*\`*\*)
				w="${w//\`}"
				printf "${BRED}%s${OFF}" "${s}${w//\*}"
				SET_BOLD=
				;;
			*\*)
				w="${w//\`}"
				printf "${BWHITE}%s${OFF}" "${s}${w//\*}"
				SET_BOLD=
				;;
			\[*\]\(*\)) printf "${BPURPLE}%s${OFF}" "${s}${w}";;
			[*) printf "${BPURPLE}%s" "${s}${w}";;
			*]\(*\)) printf "%s${OFF}" "${s}${w}";;
			\`*\`)
				w="${w//\*}"
				if [[ $SET_BOLD = true ]]; then
					printf "${BRED} %s${BWHITE}" "${w//\`}"
				else
					printf "${BRED} %s${OFF}" "${w//\`}"
				fi
				;;
			\`*)
				w="${w//\*}"
				if [[ $SET_BOLD = true ]]; then
					printf "${BRED} %s${BWHITE}" "${w//\`}"
				else
					printf "${BRED} %s${OFF}" "${w//\`}"
				fi
				;;
			*\`)
				w="${w//\*}"
				if [[ $SET_BOLD = true ]]; then
					printf "${BRED} %s${BWHITE}" "${w//\`}"
				else
					printf "${BRED} %s${OFF}" "${w//\`}"
				fi
				;;
			*)	printf "%s" "${s}${w}"
		esac
		s=' '
		done
		printf "\n"
	done
}
print::compromised::hash() {
	log::debug "package hash error has occurred for: ${PKG[pretty]}"
	printf "${BWHITE}%s\n${BRED}%s\n${BRED}%s\n${BRED}%s\n${BRED}%s\n${BWHITE}%s\n" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		" WARNING: HASH ERROR!                       " \
		" [${PKG[pretty]}] hash did not match!       " \
		" [${PKG[author]}] might be compromised!     " \
		" (or more likely, there was an error)       " \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	printf "${BWHITE}%s${BRED}%s${OFF}\n" \
		"INVALID HASH: " \
		"${HASH[${PKG[short]}]}"
	declare -Ag COMP[${PKG[short]}]=true
}
print::compromised::pgp() {
	log::debug "package pgp error has occurred for: ${PKG[pretty]}"
	printf "${BWHITE}%s\n${BBLUE}%s\n${BBLUE}%s\n${BBLUE}%s\n${BBLUE}%s\n${BWHITE}%s\n" \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" \
		" WARNING: PGP ERROR!                       " \
		" [${PKG[pretty]}] PGP signature failed!     " \
		" [${PKG[gpg_owner]}] might be compromised!  " \
		" (or more likely, there was an error)       " \
		"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	printf "${BWHITE}%s${BRED}%s\n${BWHITE}%s\n${OFF}%s\n" \
		"TAR FILE HASH: " \
		"${HASH[${PKG[short]}]}" \
		"--------------- BAD SIGNATURE ---------------" \
		"$(cat ${TMP_PKG[${PKG[short]}_gpg]})"
	declare -Ag COMP[${PKG[short]}]=true
}
print::eol() {
	printf "${BRED}%s${OFF}\n"\
		"" \
	    "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"\
	    "@ This version of [monero-bash] is no @"\
	    "@ longer supported ($MONERO_BASH_VER).          @"\
	    "@ Every major version change, e.g:    @"\
	    "@ v2.0.0 > v3.0.0 contains changes    @"\
	    "@ that break backwards compatability. @"\
	    "@                                     @"\
	    "@ You are free to continue to use     @"\
	    "@ this version, but be aware you will @"\
	    "@ not be able to upgrade monero-bash  @"\
	    "@ and may face bugs in the future.    @"\
	    "@                                     @"\
	    "@ Please move your .bitmonero, wallet @"\
	    "@ and config folders outside of the   @"\
	    "@ [.monero-bash] folder and then      @"\
	    "@ uninstall this monero-bash with:    @"\
	    "@ \"monero-bash uninstall\"             @"\
	    "@ then, you can reinstall the         @"\
	    "@ latest version from:                @@@@@@@@@@"\
	    "@ https://github.com/hinto-janaiyo/monero-bash @"\
	    "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
}
print::error() {
	until [[ $# = 0 ]]; do
		printf "${BRED}%s${OFF}%s\n" "[monero-bash error] " "$1"
		shift
	done
}
print::exit() {
	until [[ $# = 0 ]]; do
		printf "${BRED}%s${OFF}%s\n" "[monero-bash error] " "$1"
		shift
	done
	exit 1
}
print::help() {
	log::debug "starting"
	printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s${BPURPLE}%s\n\n" \
		"USAGE: " "monero-bash " "command " "<argument> " "[--option]"
	printf "${BWHITE}%s${OFF}\n" "WALLET"
	printf "    ${OFF}%s\n" \
		"monero-bash                                      Open interactive wallet menu" \
		"list                                             List wallets"
	printf "    ${OFF}%s${BYELLOW}%s${BPURPLE}%s${OFF}%s\n" \
		"open    " "<wallet> " "[--password <pass>]             " "Open a wallet directly"
	printf "    ${OFF}%s${BYELLOW}%s${OFF}%s\n" \
		"new     " "<wallet type>                            " "Enter wallet creation mode"
	printf "\n${BWHITE}%s${OFF}\n" "PACKAGE"
	printf "    ${OFF}%s${BPURPLE}%s${OFF}%s\n" \
		"update  " "[--verbose]                              " "Check for package updates" \
		"upgrade " "[--verbose] [--force] [--yes]            " "Upgrade all out-of-date packages"
	printf "    ${OFF}%s${BYELLOW}%s${BPURPLE}%s${OFF}%s\n" \
		"install " "<packages> " "[--verbose] [--force] [--yes] " "Install one/multiple packages" \
		"remove  " "<packages> " "[--verbose] [--yes]           " "Remove one/multiple packages"
	printf "\n${BWHITE}%s${OFF}\n" "PROCESS"
	printf "    ${OFF}%s${BYELLOW}%s${OFF}%s\n" \
		"full    " "<process>                                " "Start <process> fully attached in foreground" \
		"config  " "<processes>                              " "Enter interactive configuration for <process>"
	printf "    ${OFF}%s${BYELLOW}%s${BPURPLE}%s${OFF}%s\n" \
		"default " "<processes> " "[--config] [--systemd]       " "Reset your config/systemd file to the default"
	printf "\n${BWHITE}%s${OFF}\n" "SYSTEMD"
	printf "    ${OFF}%s${BYELLOW}%s${OFF}%s\n" \
		"start   " "<processes>                              " "Start process as systemd background process" \
		"stop    " "<processes>                              " "Gracefully stop systemd background process" \
		"kill    " "<processes>                              " "Forcefully kill systemd background process" \
		"restart " "<processes>                              " "Restart systemd background process" \
		"enable  " "<processes>                              " "Enable <process> to auto-start on computer boot" \
		"disable " "<processes>                              " "Disable <process> from auto-starting on computer boot" \
		"edit    " "<processes>                              " "Edit systemd service file" \
		"refresh " "<processes>                              " "Refresh your systemd service file to match your config" \
		"watch   " "<processes>                              " "Watch live output of systemd background process"
	printf "\n${BWHITE}%s${OFF}\n"    "STATS"
	printf "    %s\n" \
		"status                                           Print status of all running processes" \
		"size                                             Print size of all packages and folders" \
		"version                                          Print current package versions"
	printf "\n${BWHITE}%s${OFF}\n"    "OTHER"
	printf "    ${OFF}%s${BYELLOW}%s${BPURPLE}%s${OFF}%s\n" \
		"changes " "<packages> " "[--print]                     " "View the latests changes for <package>" \
		"rpc     " "<JSON-RPC method> " "[--verbose]            " "Send a JSON-RPC call to monerod"
	printf "    ${OFF}%s${BYELLOW}%s${OFF}%s\n" \
		"help    " "<command>                                " "Print help for a command, or all if none specified"
}
print::help::command() {
	until [[ $# = 0 ]]; do
	log::debug "starting ${FUNCNAME}() for: $1"
	case "$1" in
		monero-bash|mb)
			printf "${BWHITE}%s${BRED}%s\n\n" "USAGE: " "monero-bash"
			printf "${OFF}%s\n" \
			"Open the interactive wallet menu." \
			"" \
			"Looks for wallets inside the wallet folder:" \
			"[\$HOME/.monero-bash/wallets]" \
			"Ignores [.keys] files, only looking for wallet files." \
			"" \
			"Allows selection of existing wallets and interactive" \
			"creation of a new wallet with these types: " \
			"" \
			"--generate-new-wallet         | [new]" \
			"--generate-from-view-key      | [view]" \
			"--restore-from-seed           | [seed]" \
			"--generate-from-json          | [json]" \
			"--generate-from-spend-key     | [spend]" \
			"--generate-from-device        | [device]" \
			"--generate-from-keys          | [private]" \
			"--generate-from-multisig-keys | [multisig]" \
			"" \
			"Each time the [monero-bash] title is printed, it rolls" \
			"some RNG to print varying levels of title rarity:" \
			"" \
			"RED    # | common    | 60%" \
			"BLUE   x | rare      | 30%" \
			"PURPLE : | ultra     | 9%" \
			"GOLDEN / | legendary | 0.99%" \
			"GREEN  # | lottery   | 0.0030519%"
			;;
		list)
			printf "${BWHITE}%s${BRED}%s${OFF}%s\n\n" "USAGE: " "monero-bash " "list"
			printf "${OFF}%s\n" \
			"Print the full list and amount of wallets." \
			"" \
			"Looks for wallets inside of the wallet folder:" \
			"[\$HOME/.monero-bash/wallets]" \
			"Ignores [.keys] files, only looking for wallet files." \
			"" \
			"Each time the [monero-bash] title is printed, it rolls" \
			"some RNG to print varying levels of title rarity:" \
			"" \
			"RED    # | common    | 60%" \
			"BLUE   x | rare      | 30%" \
			"PURPLE : | ultra     | 9%" \
			"GOLDEN / | legendary | 0.99%" \
			"GREEN  # | lottery   | 0.0030519%"
			;;
		open)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "open " "<wallet> " "[-p|--password <pass>]"
			printf "${OFF}%s\n" \
			"Open a specific wallet directly, skipping the interactive menu." \
			"" \
			"This skips the interactive selection menu, and opens the wallet directly." \
			"" \
			"If the [-p|--password] option is NOT given, a password prompt will appear."\
			"If the [-p|--password] option is given, the next argument will be used" \
			"as the password, if no password given, an empty password is used."
			;;
		new)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "new " "<wallet type>"
			printf "${OFF}%s\n" \
			"Create a new wallet." \
			"" \
			"If a wallet type is given, wallet creation is started" \
			"with that type, if no wallet type is given, interactive" \
			"wallet creation mode is started. Creates wallets inside" \
			"of the wallet folder: [\$HOME/.monero-bash/wallets]" \
			"Allows creation of a wallet with these types:" \
			"" \
			"--generate-new-wallet         | [new]" \
			"--generate-from-view-key      | [view]" \
			"--restore-from-seed           | [seed]" \
			"--generate-from-json          | [json]" \
			"--generate-from-spend-key     | [spend]" \
			"--generate-from-device        | [device]" \
			"--generate-from-keys          | [private]" \
			"--generate-from-multisig-keys | [multisig]"
			;;
		install)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "install " "<packages> " "[-v|--verbose] [-f|--force] [-y|--yes]"
			printf "${OFF}%s\n" \
			"Start the installation process of packages." \
			"" \
			"Packages are installed in their respective folders in:" \
			"[\$HOME/.monero-bash/packages/<PACKAGE_NAME>]" \
			"and [systemd] service files are created, if not already" \
			"found in: [/etc/systemd/system]" \
			"" \
			"Packages are verified by hash and PGP signature before" \
			"installation. PGP keys are automatically verified, then" \
			"imported if not already found. If verification fails, the" \
			"package will not be installed. The rest of the packages" \
			"will continue to be installed." \
			"" \
			"A single package or multiple packages can be installed at the same time." \
			"" \
			"--- PACKAGE LIST ---" \
			"[monero]" \
			"[p2pool]" \
			"[xmrig]" \
			"" \
			"If the [-v|--verbose] option is given, detailed" \
			"debug information will be printed during the install." \
			"If the [-f|--force] option is given, the package will" \
			"be installed even if it is already installed." \
			"If the [-y|--yes] option is given, the (Y/n) prompt will" \
			"be skipped, and the installation will start automatically."
			;;
		remove)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "remove " "<packages> " "[-v|--verbose] [-y|--yes]"
			printf "${OFF}%s\n" \
			"Start the removal process of packages." \
			"" \
			"Packages folders are deleted: [\$HOME/.monero-bash/packages/<PACKAGE_NAME>]" \
			"and systemd service files are removed: [/etc/systemd/system/<PACKAGE_NAME>.service]" \
			"Configuration files are left alone: [\$HOME/.monero-bash/config/<PACKAGE_CONFIG>]" \
			"A single package or multiple packages can be removed at the same time." \
			"" \
			"--- PACKAGE LIST ---" \
			"[monero]" \
			"[p2pool]" \
			"[xmrig]" \
			"" \
			"If the [-v|--verbose] option is given, detailed" \
			"debug information will be printed during the removal." \
			"If the [-y|--yes] option is given, the (y/N) prompt will" \
			"be skipped, and the removal will start automatically."
			;;
		update)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "update " "[-v|--verbose]"
			printf "${OFF}%s\n" \
			"Check for new versions of installed packages." \
			"" \
			"If a new version is found, the new update will" \
			"be printed along with the old version:" \
			"<PACKAGE_NAME> | [OLD_VERSION] -> [NEW_VERSION]" \
			"The package version from that point will be" \
			"printed in [RED] instead of [GREEN] until it" \
			"is upgraded with [monero-bash upgrade]." \
			"" \
			"If the [-v|--verbose] option is given, detailed" \
			"debug information will be printed during the update."
			;;
		upgrade)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "upgrade " "[-v|--verbose] [-f|--force] [-y|--yes]"
			printf "${OFF}%s\n" \
			"Upgrade all installed packages that are out-of-date." \
			"" \
			"Packages folders are upgraded:" \
			"[\$HOME/.monero-bash/packages/<PACKAGE_NAME>]" \
			"" \
			"Packages are verified by hash and PGP signature before" \
			"upgrade. PGP keys are automatically verified, then" \
			"imported if not already found. If verification fails, the" \
			"package will not be upgraded. The rest of the packages" \
			"will continue to be upgraded." \
			"" \
			"--- PACKAGE LIST ---" \
			"[monero]" \
			"[p2pool]" \
			"[xmrig]" \
			"" \
			"If the [-v|--verbose] option is given, detailed" \
			"debug information will be printed during the upgrade." \
			"If the [-f|--force] option is given, all installed" \
			"packages will be upgraded even if they are up-to-date." \
			"If the [-y|--yes] option is given, the (Y/n) prompt will" \
			"be skipped, and the upgrade will start automatically."
			;;
		full)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "full " "<process>"
			printf "${OFF}%s\n" \
			"Start a process attached to the current terminal." \
			"" \
			"The process will be started in the foreground in the" \
			"current terminal with configuration sourced from the" \
			"process's configuration file found in:" \
			"[\$HOME/.monero-bash/config/<PROCESS_CONFIG>]" \
			"" \
			"The process will be ran as the [monero-bash] user for" \
			"security reasons. It has a [nologin] shell. The exeception" \
			"is [XMRig] which runs as [root] for hugepage allocation." \
			"This can be disabled by editing the XMRIG_ROOT option in:" \
			"[\$HOME/.monero-bash/config/monero-bash.conf]"\
			"" \
			"#---------------------------------------------------------------#" \
			"# PROCESS | USER        | CONFIG FILE                           #" \
			"#---------------------------------------------------------------#" \
			"# Monero  | monero-bash | monerod.conf & monero-wallet-cli.conf #" \
			"# P2Pool  | monero-bash | p2pool.conf (& optional p2pool.json)  #" \
			"# XMRig   | root        | xmrig.json                            #" \
			"#---------------------------------------------------------------#"
			;;
		config)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "config " "<processes>"
			printf "${OFF}%s\n" \
			"Start interactive configuration for processes." \
			"" \
			"This will edit the configuration files found in:" \
			"[\$HOME/.monero-bash/config/<PROCESS_CONFIG>]" \
			"" \
			"#-----------------------------------------------------#" \
			"# PROCESS     | CONFIG FILE                           #" \
			"#-----------------------------------------------------#" \
			"# monero-bash | monero-bash.conf                      #" \
			"# Monero      | monerod.conf & monero-wallet-cli.conf #" \
			"# P2Pool      | p2pool.conf                           #" \
			"# XMRig       | xmrig.json                            #" \
			"#-----------------------------------------------------#" \
			"" \
			"After configuration, a prompt will ask you if you'd like to" \
			"refresh your [systemd] service to match the configuration." \
			"This can also manually be done with: [monero-bash refresh <processes>]"
			;;
		default)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "default " "<processes> " "[-c|--config] [-s|--systemd]"
			printf "${OFF}%s\n" \
			"Reset config files/systemd services to the default." \
			"" \
			"This will reset the configuration files of <process>" \
			"found in: [\$HOME/.monero-bash/config/<PROCESS_CONFIG>]" \
			"and the [systemd] service files found in: [/etc/systemd/system]" \
			"to a generic default version." \
			"" \
			"#-----------------------------------------------------------------------------------#" \
			"# PROCESS     | CONFIG FILE                           | SYSTEMD SERVICE FILE        #" \
			"#-----------------------------------------------------------------------------------#" \
			"# monero-bash | monero-bash.conf                      |                             #" \
			"# Monero      | monerod.conf & monero-wallet-cli.conf | monero-bash-monerod.service #" \
			"# P2Pool      | p2pool.conf                           | monero-bash-p2pool.service  #" \
			"# XMRig       | xmrig.json                            | monero-bash-xmrig.service   #" \
			"#-----------------------------------------------------------------------------------#" \
			"" \
			"If the [-c|--config] option is given, only the config is reset." \
			"If the [-s|--systemd] option is given, only the systemd service is reset." \
			"If no options are supplied, both the config file and systemd file are reset."
			;;
		start)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "start " "<processes>"
			printf "${OFF}%s\n" \
			"Start a process in the background with systemd" \
			"" \
			"The process will be started in the background with a" \
			"[systemd] service file found in: [/etc/systemd/system]" \
			"" \
			"The process will be ran as the [monero-bash] user for" \
			"security reasons. It has a [nologin] shell. The exeception" \
			"is [XMRig] which runs as [root] for hugepage allocation." \
			"This can be disabled by editing the XMRIG_ROOT option in:" \
			"[\$HOME/.monero-bash/config/monero-bash.conf]"\
			"and then refreshing the [systemd] service with:" \
			"[monero-bash refresh xmrig]" \
			"" \
			"#-----------------------------------------------------#" \
			"# PROCESS | USER        | SYSTEMD SERVICE FILE        #" \
			"#-----------------------------------------------------#" \
			"# Monero  | monero-bash | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash | monero-bash-p2pool.service  #" \
			"# XMRig   | root        | monero-bash-xmrig.service   #" \
			"#-----------------------------------------------------#"
			;;
		stop)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "stop " "<processes>"
			printf "${OFF}%s\n" \
			"Gracefully stop a background process with systemd" \
			"" \
			"[systemd] service files are found in: [/etc/systemd/system]" \
			"" \
			"#---------------------------------------#" \
			"# PROCESS | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------#" \
			"# Monero  | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash-p2pool.service  #" \
			"# XMRig   | monero-bash-xmrig.service   #" \
			"#---------------------------------------#"
			;;
		kill)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "kill " "<processes>"
			printf "${OFF}%s\n" \
			"Forcefully kill a background process with systemd" \
			"" \
			"[systemd] service files are found in: [/etc/systemd/system]" \
			"" \
			"#---------------------------------------#" \
			"# PROCESS | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------#" \
			"# Monero  | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash-p2pool.service  #" \
			"# XMRig   | monero-bash-xmrig.service   #" \
			"#---------------------------------------#"
			;;
		restart)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "restart " "<processes>"
			printf "${OFF}%s\n" \
			"Gracefully restart a background process with systemd" \
			"" \
			"[systemd] service files are found in: [/etc/systemd/system]" \
			"" \
			"#---------------------------------------#" \
			"# PROCESS | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------#" \
			"# Monero  | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash-p2pool.service  #" \
			"# XMRig   | monero-bash-xmrig.service   #" \
			"#---------------------------------------#"
			;;
		enable)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "enable " "<processes>"
			printf "${OFF}%s\n" \
			"Enable a background process to auto-start" \
			"on computer boot with systemd" \
			"" \
			"[systemd] service files are found in: [/etc/systemd/system]" \
			"" \
			"#---------------------------------------#" \
			"# PROCESS | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------#" \
			"# Monero  | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash-p2pool.service  #" \
			"# XMRig   | monero-bash-xmrig.service   #" \
			"#---------------------------------------#"
			;;
		disable)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "disable " "<processes>"
			printf "${OFF}%s\n" \
			"Disable background process from auto-start" \
			"on computer boot with systemd" \
			"" \
			"[systemd] service files are found in: [/etc/systemd/system]" \
			"" \
			"#---------------------------------------#" \
			"# PROCESS | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------#" \
			"# Monero  | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash-p2pool.service  #" \
			"# XMRig   | monero-bash-xmrig.service   #" \
			"#---------------------------------------#"
			;;
		edit)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "edit " "<processes>"
			printf "${OFF}%s\n" \
			"Edit a process's systemd service file." \
			"" \
			"After editing, systemd is reloaded automatically." \
			"[systemd] service files are found in: [/etc/systemd/system]" \
			"" \
			"#---------------------------------------#" \
			"# PROCESS | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------#" \
			"# Monero  | monero-bash-monerod.service #" \
			"# P2Pool  | monero-bash-p2pool.service  #" \
			"# XMRig   | monero-bash-xmrig.service   #" \
			"#---------------------------------------#"
			;;
		refresh)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "refresh " "<processes> "
			printf "${OFF}%s\n" \
			"Refresh [systemd] to match configuration files." \
			"" \
			"This will reset the [systemd] service of <process>" \
			"to match the configuration options found in:" \
			"[\$HOME/.monero-bash/config/<PROCESS_CONFIG>]" \
			"" \
			"By default, packages will come with a generic [systemd] service file." \
			"" \
			"#---------------------------------------------------------------------------#" \
			"# PROCESS     | CONFIG FILE TO MATCH          | SYSTEMD SERVICE FILE        #" \
			"#---------------------------------------------------------------------------#" \
			"# Monero      | monerod.conf                  | monero-bash-monerod.service #" \
			"# P2Pool      | p2pool.conf                   | monero-bash-p2pool.service  #" \
			"# XMRig       | monero-bash.conf + xmrig.json | monero-bash-xmrig.service   #" \
			"#---------------------------------------------------------------------------#" \
			"" \
			"If no options are supplied, both the config file and systemd file are reset."
			;;
		watch)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "watch " "<processes>"
			printf "${OFF}%s\n" \
			"Watch live output of a background systemd process" \
			"" \
			"The terminal will switch to output of <processes>" \
			"To exit and return: <CTRL+C>" \
			"If multiple procceses are selected, they are queued." \
			"" \
			"--- PROCESSES ---" \
			"[monero]" \
			"[p2pool]" \
			"[xmrig]"
			;;
		status)
			printf "${BWHITE}%s${BRED}%s${OFF}%s\n\n" "USAGE: " "monero-bash " "status"
			printf "${OFF}%s\n" \
			"Print status of all running processes." \
			"" \
			"#---------------------------------------------------------------------------#" \
			"# PROCESS     | INFORMATION PRINTED                                         #" \
			"#---------------------------------------------------------------------------#" \
			"# Monero      | Blockchain stats + /.bitmonero/ size                        #" \
			"# P2Pool      | Wallet + Latest share + Latest payout + Shares per hour/day #" \
			"# XMRig       | Wallet + Hashrate + Shares + Pool                           #" \
			"#---------------------------------------------------------------------------#"
			;;
		size)
			printf "${BWHITE}%s${BRED}%s${OFF}%s\n\n" "USAGE: " "monero-bash " "size"
			printf "${OFF}%s\n" "Print size of installed packages and blockchain folder."
			;;
		version)
			printf "${BWHITE}%s${BRED}%s${OFF}%s\n\n" "USAGE: " "monero-bash " "version"
			printf "${OFF}%s\n" \
			"Print version of installed packages." \
			"" \
			"Versions will be printed in [BOLD RED] if they" \
			"are out-of-date. Otherwise they will be printed" \
			"in [BOLD GREEN]."
			;;
		rpc)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BBLUE}%s${BYELLOW}%s${BGREEN}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "rpc " "[host:port] " "<JSON-RPC method> " "[name:value] " "[-v|--verbose]"
			printf "${OFF}%s\n" \
			"Send a JSON-RPC call to monerod." \
			"" \
			"This will send a JSON-RPC call to the monerod IP" \
			"specified in [\$HOME/.monero-bash/config/monero-bash.conf]" \
			"Using the [-v|--verbose] option will make [monero-bash] print" \
			"the monerod IP and payload after the RPC call finishes." \
			"" \
			"The default IP is your own monerod: [127.0.0.1:18081]" \
			"But any monerod IP is able to be used: [node.community.rino.io:18081]" \
			"" \
			"The code for this command is originally from: https://github.com/jtgrassie/xmrpc" \
			"# Copyright (c) 2019-2022, jtgrassie          | https://github.com/jtgrassie" \
			"# Copyright (c) 2014-2022, The Monero Project | https://github.com/monero-project/monero" \
			""
			printf "\n${BWHITE}%s${OFF}\n" "EXAMPLE"
			printf "    ${BRED}%s${OFF}%s${BYELLOW}%s\n" "monero-bash " "rpc " "get_block"
			printf "    ${BRED}%s${OFF}%s${BBLUE}%s${BYELLOW}%s\n" "monero-bash " "rpc " "node.community.rino.io:18081 " "get_block"
			printf "    ${BRED}%s${OFF}%s${BBLUE}%s${BYELLOW}%s${BGREEN}%s\n" \
			"monero-bash " "rpc " "127.0.0.1:18081 " "get_block " "height:123456" \
			"monero-bash " "rpc " "localhost:18081 " "get_block " "hash:418015bb9ae982a1975da7d79277c2705727a56894ba0fb246adaabb1f4632e3"
			printf "\n${BWHITE}%s${OFF}\n" "JSON RPC Methods"
			printf "    ${OFF}%s\n" \
			"get_block_count" \
			"on_get_block_hash" \
			"get_block_template" \
			"submit_block" \
			"get_last_block_header" \
			"get_block_header_by_hash" \
			"get_block_header_by_height" \
			"get_block_headers_range" \
			"get_block" \
			"get_connections" \
			"get_info" \
			"hard_fork_info" \
			"set_bans" \
			"get_bans" \
			"get_output_histogram" \
			"get_version" \
			"get_coinbase_tx_sum" \
			"get_fee_estimate" \
			"get_alternate_chains" \
			"relay_tx" \
			"sync_info" \
			"get_txpool_backlog" \
			"get_output_distribution"
			;;
		changes)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s${BPURPLE}%s\n\n" "USAGE: " "monero-bash " "changes " "<packages> " "[-p|--print]"
			printf "${OFF}%s\n" \
			"Read the changelog of <packages>." \
			"" \
			"During package installations/upgrades, [monero-bash]" \
			"will save a local changelog inside: [\$HOME/.monero-bash/changes]" \
			"This file is read and parsed for MARKDOWN syntax, then printed." \
			"" \
			"If the [-p|--print] option is given, the changelog will be printed" \
			"normally to the terminal instead of being piped to [less]."
			;;
		help)
			printf "${BWHITE}%s${BRED}%s${OFF}%s${BYELLOW}%s\n\n" "USAGE: " "monero-bash " "help " "<command>"
			printf "${OFF}%s\n" \
			"Print help for [monero-bash] commands." \
			"" \
			"If no command is given, the general help" \
			"menu will be printed for all commands."
			;;
		*) print::error "Invalid option: $1 command does not exist";return 1;;
	esac
	shift
	done
	return
}
print::pkg::download() {
	printf "${BCYAN}%s${OFF}\n" "#---------------------------------------# Downloading"
}
print::pkg::update() {
	printf "${BBLUE}%s${OFF}\n" "#---------------------------------------# Updating"
}
print::pkg::remove() {
	printf "${BRED}%s${OFF}\n" "#---------------------------------------# Removing [${PKG[pretty]}]"
}
print::pkg::verify() {
	printf "${BYELLOW}%s${OFF}\n" "#---------------------------------------# Verifying"
}
print::pkg::install() {
	printf "${BRED}%s${OFF}\n" "#---------------------------------------# Installing"
}
print::pkg::upgrade() {
	printf "${BRED}%s${OFF}\n" "#---------------------------------------# Upgrading"
}
print::pkg::hook::pre() {
	printf "${BPURPLE}%s${OFF}\n" "#---------------------------------------# Pre-Hooks"
}
print::pkg::hook::post() {
	printf "${BPURPLE}%s${OFF}\n" "#---------------------------------------# Post-Hooks"
}
print::pkg::installed() {
	printf "${BGREEN}%s${OFF}\n" "#---------------------------------------# Install done"
}
print::pkg::upgraded() {
	printf "${BGREEN}%s${OFF}\n" "#---------------------------------------# Upgrade done"
}
print::pkg::upgrade_fail() {
	printf "${BRED}%s${OFF}\n" "#---------------------------------------# Upgrade failed"
}
print::pkg::removed() {
	printf "${BRED}%s${OFF}\n" "#---------------------------------------# Removed [${PKG[pretty]}]"
}
print::pkg::updated() {
	printf "${BCYAN}%s${OFF}\n" "#---------------------------------------# All packages up-to-date"
}
print::size() {
	log::debug "starting"
	log::debug "getting folder sizes"
	local SIZE_MONERO_BASH SIZE_MONERO SIZE_P2POOL SIZE_XMRIG SIZE_BITMONERO SIZE_DOT || return 1
	SIZE_MONERO_BASH=$(du -h "$PKG_MONERO_BASH")
	[[ $MONERO_VER ]] && SIZE_MONERO=$(du -h "$PKG_MONERO") || SIZE_MONERO=
	[[ $P2POOL_VER ]] && SIZE_P2POOL=$(du -h "$PKG_P2POOL") || SIZE_P2POOL=
	[[ $XMRIG_VER ]]  && SIZE_XMRIG=$(du -h "$PKG_XMRIG") || SIZE_XMRIG=
	SIZE_DOT=$(du -h "$DOT")
	[[ -d "$DOT/.bitmonero" ]] && SIZE_BITMONERO=$(du -h "$DOT/.bitmonero") || SIZE_BITMONERO=
	log::debug "printing folder sizes"
	printf "${BWHITE}%s${BYELLOW}%s${OFF}\n" "monero-bash    | " "${SIZE_MONERO_BASH/$'\t'*}"
	[[ $SIZE_MONERO ]]    && printf "${BWHITE}%s${BYELLOW}%s${OFF}\n" "Monero         | " "${SIZE_MONERO/$'\t'*}"
	[[ $SIZE_P2POOL ]]    && printf "${BWHITE}%s${BYELLOW}%s${OFF}\n" "P2Pool         | " "${SIZE_P2POOL/$'\t'*}"
	[[ $SIZE_XMRIG ]]     && printf "${BWHITE}%s${BYELLOW}%s${OFF}\n" "XMRig          | " "${SIZE_XMRIG/$'\t'*}"
	[[ $SIZE_BITMONERO ]] && printf "${BWHITE}%s${BYELLOW}%s${OFF}\n" "/.bitmonero/   | " "${SIZE_BITMONERO/$'\t'*}"
	printf "${BWHITE}%s${BYELLOW}%s${OFF}\n" "/.monero-bash/ | " "${SIZE_DOT/$'\t'*}"
}
print::title() {
	log::debug "starting"
	log::debug "seeding title rng"
	local TITLE_RANDOM
	TITLE_RANDOM=$RANDOM
	if [[ $TITLE_RANDOM -le 19660 ]]; then
			printf "${BRED}%s${OFF}\n" \
				"###################" \
				"#   monero-bash   #" \
				"###################"
		log::debug "title luck: common 60%"
	elif [[ $TITLE_RANDOM -le 29490 ]]; then
			printf "${BBLUE}%s${OFF}\n" \
				"xxxxxxxxxxxxxxxxxxx" \
				"x   monero-bash   x" \
				"xxxxxxxxxxxxxxxxxxx"
		log::debug "title luck: rare 30%"
	elif [[ $TITLE_RANDOM -le 32439 ]]; then
			printf "${BPURPLE}%s${OFF}\n" \
				":::::::::::::::::::" \
				":   monero-bash   :" \
				":::::::::::::::::::"
		log::debug "title luck: ultra 9%"
	elif [[ $TITLE_RANDOM -le 32766 ]]; then
			printf "${BYELLOW}%s${OFF}\n" \
				"///////////////////" \
				"/   monero-bash   /" \
				"///////////////////"
		log::debug "title luck: legendary 0.99%"
	else
		printf "${BGREEN}%s${OFF}\n" \
			"###################" \
			"#   monero-bash   #" \
			"###################"
		log::debug "title luck: lottery 0.0030519%"
	fi
}
print::version() {
	log::debug "starting"
	printf "${BWHITE}%s" \
		"monero-bash | "
	if [[ $MONERO_BASH_OLD = true ]]; then
		printf "${BRED}%s\n" "$MONERO_BASH_VER"
	else
		printf "${BGREEN}%s\n" "$MONERO_BASH_VER"
	fi
	printf "${BWHITE}%s" \
		"Monero      | "
	if [[ $MONERO_OLD = true ]]; then
		printf "${BRED}%s\n" "$MONERO_VER"
	else
		printf "${BGREEN}%s\n" "$MONERO_VER"
	fi
	printf "${BWHITE}%s" \
		"P2Pool      | "
	if [[ $P2POOL_OLD = true ]]; then
		printf "${BRED}%s\n" "$P2POOL_VER"
	else
		printf "${BGREEN}%s\n" "$P2POOL_VER"
	fi
	printf "${BWHITE}%s" \
		"XMRig       | "
	if [[ $XMRIG_OLD = true ]]; then
		printf "${BRED}%s\n" "$XMRIG_VER"
	else
		printf "${BGREEN}%s\n" "$XMRIG_VER"
	fi
	printf "${OFF}%s\n" \
	"" \
	"[monero-bash] is distributed under the MIT software license." \
	"See: <https://github.com/hinto-janaiyo/monero-bash/LICENSE>" \
	"" \
	"Parts of this project are originally:" \
	"Copyright (c) 2019-2022, jtgrassie          | https://github.com/jtgrassie" \
	"Copyright (c) 2014-2022, The Monero Project | https://github.com/monero-project/monero"
}
process::reset_files() {
	log::debug "starting"
	if [[ -z ${PKG[version]} ]]; then
		print::exit "${PKG[pretty]} is not installed"
	fi
	case "${PKG[name]}" in
		*bash*)
			printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
				"This will overwrite your current " \
				"[${PKG[pretty]}] " \
				"config with a new default version"
			;;
		*)
			printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
				"This will overwrite your current " \
				"[${PKG[pretty]}] " \
				"config & systemd service files with new default versions"
			;;
	esac
	printf "${BWHITE}%s${OFF}" "Continue? (y/N) "
	if ask::no; then
		print::exit "Canceling reset"
	fi
	if ! ask::sudo; then
		print::exit "sudo is required"
	fi
	case "${PKG[name]}" in
		*bash*)
			cp -f "$PKG_MONERO_BASH/config/monero-bash.conf" "$CONFIG"
			;;
		monero)
			cp -f "$PKG_MONERO_BASH/config/monerod.conf" "$CONFIG"
			cp -f "$PKG_MONERO_BASH/config/monero-wallet-cli.conf" "$CONFIG"
			systemd::create
			systemd::reload
			;;
		p2pool)
			cp -f "$PKG_MONERO_BASH/config/p2pool.conf" "$CONFIG"
			systemd::create
			systemd::reload
			;;
		xmrig)
			cp -f "$PKG_MONERO_BASH/config/xmrig.json" "$CONFIG"
			systemd::create
			systemd::reload
			;;
	esac
	return 0
}
REAL="$(realpath $0)"
RELATIVE="$(dirname "$REAL")"
BINARY="/usr/local/bin/monero-bash"
SYMLINK="/usr/local/bin/mb"
readonly REAL RELATIVE
readonly DOT="$HOME/.monero-bash"
readonly CONFIG="$DOT/config"
readonly WALLETS="$DOT/wallets"
readonly PACKAGES="$DOT/packages"
readonly CHANGES="$DOT/changes"
readonly EXPORT_IMPORT="$DOT/export_import"
readonly CONFIG_MONERO_BASH="$CONFIG/monero-bash.conf"
readonly CONFIG_MONEROD="$CONFIG/monerod.conf"
readonly CONFIG_WALLET="$CONFIG/monero-wallet-cli.conf"
readonly CONFIG_P2POOL="$CONFIG/p2pool.conf"
readonly CONFIG_XMRIG="$CONFIG/xmrig.json"
readonly PKG_MONERO_BASH="$PACKAGES/monero-bash"
readonly PKG_MONERO="$PACKAGES/monero"
readonly PKG_P2POOL="$PACKAGES/p2pool"
readonly PKG_XMRIG="$PACKAGES/xmrig"
readonly SRC="$PKG_MONERO_BASH/src"
readonly TXT="$PKG_MONERO_BASH/txt"
readonly HASHLIST="$TXT/hashlist"
readonly STATE="$TXT/state"
readonly MAIN="$PKG_MONERO_BASH/monero-bash"
readonly SRC_CONFIG="$PKG_MONERO_BASH/config"
readonly SYSTEMD="/etc/systemd/system"
rpc() {
	log::debug "starting ${FUNCNAME}()"
	if [[ "$1" == *:* ]]; then
	    RPC_IP="$1/json_rpc"
		shift
	elif [[ "$1" != *:* && -z "$RPC_IP" ]]; then
	    RPC_IP="http://localhost:18081/json_rpc"
	elif [[ "$1" != *:* && "$RPC_IP" ]]; then
		RPC_IP="${RPC_IP}/json_rpc"
	fi
	method="$1" ; shift
	payload="{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"$method\""
	if [ -n "$1" ]; then
	    if [[ "${1::1}" == "[" ]]; then
	        payload="$payload,\"params\":$(rpc::parse_arr $1)"
	    else
	        payload="$payload,\"params\":{"
	        while [ -n "$1" ]; do
	            payload="${payload}$(rpc::parse_nv $1)"
	            [ -n "$2" ] && payload="$payload,"
	            shift
	        done
	        payload="$payload}"
	    fi
	fi
	payload="$payload}"
	if [[ $CURL = true ]]; then
		if curl -sd "$payload" "$RPC_IP"; then
			echo
		else
			print::error "Curl has failed, is monerod online?"
		fi
	else
		if wget -qO- "$RPC_IP" --header='Content-Type:application/json' --post-data="$payload"; then
			echo
		else
			print::error "Wget has failed, is monerod online?"
		fi
	fi
	[[ $OPTION_VERBOSE = true ]] && STD_LOG_DEBUG=true
	log::debug "--- RPC INFO ---"
	log::debug "RPC_IP  | $RPC_IP"
	log::debug "PAYLOAD | $payload"
	[[ $OPTION_VERBOSE = true ]] && STD_LOG_DEBUG=
	exit
}
rpc::quote() {
    [[ "$1" =~ ^[0-9]+$ ]] && echo -n "$1" && return
    [[ "$1" =~ ^true|false$ ]] && echo -n "$1" && return
    [[ "${1::1}" == "[" ]] && echo -n "$(rpc::parse_arr $1)" && return
    echo -n "\"$1\""
}
rpc::parse_arr() {
    let e=${#1}-2
    sz=${1:1:$e}
    a=(${sz//,/ })
    for i in "${!a[@]}"; do
        a[$i]=$(rpc::quote ${a[i]})
    done
    aj=$(printf ",%s" "${a[@]}")
    aj=${aj:1}
    echo -n "[${aj}]"
}
rpc::parse_nv() {
    nv=(${1//:/ })
    c=${#nv[@]}
    [[ $c == 2 ]] && echo -n "$(rpc::quote ${nv[0]}):$(rpc::quote ${nv[1]})"
}
safety::path() {
	log::debug "starting"
	if [[ $REAL = "$MAIN" ]]; then
		log::debug "PATH OK: $MAIN"
		return 0
	else
		log::debug "PATH is not in: $MAIN"
		log::debug "REAL: $REAL"
		if [[ $REAL = */monero-bash/monero-bash ]]; then
			log::debug "PATH detected to be in [monero-bash] folder, checking FIRST_TIME"
			if [[ $FIRST_TIME = true ]]; then
				log::debug "FIRST_TIME = true | OK, continuing to install"
				return 0
			else
				print::error "FIRST_TIME = $FIRST_TIME | something is very wrong"
				print::error "monero-bash is in the [monero-bash] folder, yet FIRST_TIME is not true"
				print::error "The state file might be corrupted"
				print::exit  "Exiting for safety..."
			fi
		fi
	fi
	log::debug   "incorrect path detected: $REAL"
	print::error "[monero-bash] is in an unknown PATH"
	print::exit  "Exiting for safety..."
}
safety::pipe() {
	log::debug "starting"
	if [[ -p /dev/stdin ]]; then
		print::error "Pipe detected. [monero-bash] does not support pipes!"
		print::exit  "Exiting for safety..."
	fi
	log::debug "no pipe detected"
}
safety::pkg() {
	log::debug "starting"
	[[ $1 ]] || return 1
	struct::pkg "$1" || return 2
	if [[ ${PKG[current_version]} ]]; then
		log::debug "${PKG[pretty]} (${PKG[current_version]}) is installed"
	else
		print::exit "${PKG[pretty]} is not installed"
	fi
	case "${PKG[name]}" in
		*bash*)   [[ -e $PKG_MONERO_BASH/monero-bash ]] || print::exit "monero-bash not found, this error should be impossible!";;
		*monero*)
			[[ -e $PKG_MONERO/monerod ]]                || print::exit "monerod binary was not found!"
			[[ -e $PKG_MONERO/monero-wallet-cli ]]      || print::exit "monero-wallet-cli binary was not found!"
			;;
		*p2p*)    [[ -e $PKG_P2POOL/p2pool ]]           || print::exit "P2Pool binary was not found!";;
		*xmr*)    [[ -e $PKG_XMRIG/xmrig ]]             || print::exit "XMRig binary was not found!";;
	esac
	return 0
}
safety::root() {
	log::debug "starting"
	log::debug "running as: $EUID"
	if [[ $EUID = 0 ]]; then
		print::error "Running as root is not recommended"
		print::exit  "Exiting for safety..."
	fi
}
safety::wget_curl() {
	log::debug "starting"
	char DOWNLOAD_DIR DOWNLOAD_OUT WGET CURL
	if hash wget &>/dev/null; then
		WGET=true
		DOWNLOAD_DIR="wget --quiet --content-disposition -P"
		DOWNLOAD_OUT="wget --quiet -O"
		log::debug "--- wget found ---"
		log::debug "DOWNLOAD_DIR | $DOWNLOAD_DIR"
		log::debug "DOWNLOAD_OUT | $DOWNLOAD_OUT"
	elif hash curl &>/dev/null; then
		CURL=true
		DOWNLOAD_DIR="curl --silent -L -O"
		DOWNLOAD_OUT="curl --silent -L --output"
		log::debug "--- curl found ---"
		log::debug "DOWNLOAD_DIR | $DOWNLOAD_DIR"
		log::debug "DOWNLOAD_OUT | $DOWNLOAD_OUT"
	fi
	const::char DOWNLOAD_DIR DOWNLOAD_OUT CURL WGET
	if [[ -z $WGET && -z $CURL ]]; then
		print::error "both [wget] and [curl] were not found!"
		print::error "monero-bash needs at least one to install packages"
		print::exit  "Exiting for safety..."
	else
		return 0
	fi
}
status::p2pool() {
	TOTAL_PAYOUT=$(grep -o "You received a payout of .* XMR" p2pool.log)
	TOTAL_PAYOUT="${a//[A-Za-z[:blank:]]}"
	double::sum "$TOTAL_PAYOUT"
}
status::table() {
	log::debug "creating status table"
	printf "${OFF}%s\n" \
		"#-----------------------------------------------#" \
		"# monero-bash |   Monero   |  P2Pool  |  XMRig  #" \
		"#-----------------------------------------------#" \
		"# $MONERO_BASH_VER | $MONERO_VER | $P2POOL_VER | $XMRIG_VER #" \
		"#-----------------------------------------------#" \
		"#"
}
struct::pkg() {
	log::debug "defining: $1"
	declare -Ag PKG
	[[ $# != 1 ]] && return 1
	case "$1" in
	monero)
		PKG[name]="monero"
		PKG[short]="monero"
		PKG[pretty]="Monero"
		PKG[var]="MONERO"
		PKG[author]="monero-project"
		PKG[gpg_owner]="binaryFate"
		PKG[service]="monero-bash-monerod.service"
		PKG[process]="monerod"
		PKG[directory]="$PACKAGES/monero"
		PKG[regex]="monero-linux-x64.*"
		PKG[hash]="hashes.txt"
		PKG[sig]="${PKG[hash]}"
		PKG[gpg_pub_key]="https://raw.githubusercontent.com/monero-project/monero/master/utils/gpg_keys/binaryfate.asc"
		PKG[fingerprint]="81AC591FE9C4B65C5806AFC3F0AF4D462A0BDF92"
		PKG[current_version]="$MONERO_VER"
		PKG[old]="$MONERO_OLD"
		PKG[conf]="$CONFIG_MONEROD"
		PKG[conf_name]="monerod.conf"
		;;
	*bash*)
		PKG[name]="monero-bash"
		PKG[short]="bash"
		PKG[pretty]="monero-bash"
		PKG[var]="MONERO_BASH"
		PKG[author]="hinto-janaiyo"
		PKG[gpg_owner]="hinto-janaiyo"
		PKG[service]=
		PKG[process]=
		PKG[directory]="$PACKAGES/monero-bash"
		PKG[regex]="monero-bash-v.*"
		PKG[hash]="SHA256SUM"
		PKG[sig]="${PKG[hash]}"
		PKG[gpg_pub_key]="https://github.com/hinto-janaiyo/monero-bash/blob/main/pgp/hinto-janaiyo.asc"
		PKG[fingerprint]="21958EE945980282FCB849C8D7483F6CA27D1B1D"
		PKG[current_version]="$MONERO_BASH_VER"
		PKG[old]="$MONERO_BASH_OLD"
		PKG[conf]="$CONFIG_MONERO_BASH"
		PKG[conf_name]="monero-bash.conf"
		;;
	*p2p*)
		PKG[name]="p2pool"
		PKG[short]="p2pool"
		PKG[pretty]="P2Pool"
		PKG[var]="P2POOL"
		PKG[author]="SChernykh"
		PKG[gpg_owner]="SChernykh"
		PKG[service]="monero-bash-p2pool.service"
		PKG[process]="p2pool"
		PKG[directory]="$PACKAGES/p2pool"
		PKG[regex]="p2pool.*linux-x64.tar.*"
		PKG[hash]="sha256sums.txt.asc"
		PKG[sig]="${PKG[hash]}"
		PKG[gpg_pub_key]="https://raw.githubusercontent.com/monero-project/gitian.sigs/master/gitian-pubkeys/SChernykh.asc"
		PKG[fingerprint]="1FCAAB4D3DC3310D16CBD508C47F82B54DA87ADF"
		PKG[current_version]="$P2POOL_VER"
		PKG[old]="$P2POOL_OLD"
		PKG[conf]="$CONFIG_P2POOL"
		PKG[conf_name]="p2pool.conf"
		;;
	*xmr*)
		PKG[name]="xmrig"
		PKG[short]="xmrig"
		PKG[pretty]="XMRig"
		PKG[var]="XMRIG"
		PKG[author]="xmrig"
		PKG[gpg_owner]="XMRig"
		PKG[service]="monero-bash-xmrig.service"
		PKG[process]="xmrig"
		PKG[directory]="$PACKAGES/xmrig"
		PKG[regex]="xmrig.*linux-static-x64.tar.*"
		PKG[hash]="SHA256SUMS"
		PKG[sig]="${PKG[hash]}.sig"
		PKG[gpg_pub_key]="https://raw.githubusercontent.com/xmrig/xmrig/master/doc/gpg_keys/xmrig.asc"
		PKG[fingerprint]="9AC4CEA8E66E35A5C7CDDC1B446A53638BE94409"
		PKG[current_version]="$XMRIG_VER"
		PKG[old]="$XMRIG_OLD"
		PKG[conf]="$CONFIG_XMRIG"
		PKG[conf_name]="xmrig.json"
		;;
	esac
	PKG[link_api]="https://api.github.com/repos/${PKG[author]}/${PKG[name]}/releases/latest"
}
systemd::create() {
	log::debug "starting ${FUNCNAME}() for: ${PKG[pretty]}"
	local TMP_SERVICE SYSTEMD_USER SYSTEMD_EXEC SYSTEMD_DIRECTORY || return 2
	TMP_SERVICE=$(mktemp "/tmp/${PKG[service]}.XXXXXXXXXX")
	chmod 600 "$TMP_SERVICE"
	case "${PKG[name]}" in
		monero)
			SYSTEMD_USER=monero-bash
			SYSTEMD_ENV="$CONFIG_MONERO_BASH"
			SYSTEMD_EXEC="${PKG[directory]}/monerod --config-file $CONFIG_MONEROD --non-interactive"
			;;
		p2pool)
			SYSTEMD_USER=monero-bash
			SYSTEMD_ENV="$CONFIG_P2POOL"
			SYSTEMD_EXEC="${PKG[directory]}/p2pool --wallet \$P2POOL_WALLET"
			;;
		xmrig)
			SYSTEMD_USER=root
			SYSTEMD_ENV=""
			SYSTEMD_EXEC="${PKG[directory]}/xmrig --config $CONFIG_XMRIG --log-file=$PKG_XMRIG/xmrig.log"
			;;
	esac
cat << EOM >> "$TMP_SERVICE"
[Unit]
Description=${PKG[service]}
After=network-online.target
Wants=network-online.target
[Service]
User=$SYSTEMD_USER
Type=simple
EnvironmentFile="$SYSTEMD_ENV"
ExecStart=$SYSTEMD_EXEC
WorkingDirectory=${PKG[directory]}
Restart=always
RestartSec=5
[Install]
WantedBy=multi-user.target
EOM
	sudo chown root:root "$TMP_SERVICE"
	sudo mv "$TMP_SERVICE" "$SYSTEMD/${PKG[service]}" || return 3
}
systemd::reload() {
	log::debug "starting"
	sudo systemctl daemon-reload || return 1
}
wallet::create() {
	log::debug "starting"
	char WALLET_TYPE WALLET_NAME
	if [[ $1 ]]; then
		WALLET_TYPE="$1"
		case "$WALLET_TYPE" in
			--generate-new-wallet|*new*)           WALLET_TYPE=new;;
			--generate-from-view-key|*view*)       WALLET_TYPE=view;;
			--restore-from-seed|*seed*)            WALLET_TYPE=seed;;
			--generate-from-json|*json*)           WALLET_TYPE=json;;
			--generate-from-spend-key|*spend*)     WALLET_TYPE=spend;;
			--generate-from-device|*device*)       WALLET_TYPE=device;;
			--generate-from-keys|*private*)        WALLET_TYPE=private;;
			--generate-from-multisig-keys|*multi*) WALLET_TYPE=multisig;;
			*) print::exit "Invalid wallet type!"
		esac
		printf "${BWHITE}%s${BRED}%s${OFF}\n" \
			"Creating wallet with type: " \
			"[${WALLET_TYPE}]"
			if [[ $WALLET_TYPE = json ]]; then
				printf "${BWHITE}%s${OFF}" "JSON file path: "
				read -r WALLET_NAME
				case "$WALLET_NAME" in
					"")    print::exit "Empty input";;
					*)     :;;
				esac
			else
				printf "${BWHITE}%s${OFF}" "Wallet name: "
				read -r WALLET_NAME
				case "$WALLET_NAME" in
					"")    print::exit "Empty input";;
					*" "*) print::exit "Wallet name cannot have spaces";;
					*)     :;;
				esac
			fi
	else
	while :; do
		while :; do
			echo
			printf "${BPURPLE}%s${OFF}%s${BRED}%s${OFF}\n" \
				"--generate-new-wallet         " "| " "[new]" \
				"--generate-from-view-key      " "| " "[view]" \
				"--restore-from-seed           " "| " "[seed]" \
				"--generate-from-json          " "| " "[json]" \
				"--generate-from-spend-key     " "| " "[spend]" \
				"--generate-from-device        " "| " "[device]" \
				"--generate-from-keys          " "| " "[private]" \
				"--generate-from-multisig-keys " "| " "[multisig]" \
				""
			printf "${BYELLOW}%s${OFF}" "Select which wallet type to create: "
			read -r WALLET_TYPE
			case "$WALLET_TYPE" in
				--generate-new-wallet|*new*)           WALLET_TYPE=new;break;;
				--generate-from-view-key|*view*)       WALLET_TYPE=view;break;;
				--restore-from-seed|*seed*)            WALLET_TYPE=seed;break;;
				--generate-from-json|*json*)           WALLET_TYPE=json;break;;
				--generate-from-spend-key|*spend*)     WALLET_TYPE=spend;break;;
				--generate-from-device|*device*)       WALLET_TYPE=device;break;;
				--generate-from-keys|*private*)        WALLET_TYPE=private;break;;
				--generate-from-multisig-keys|*multi*) WALLET_TYPE=multisig;break;;
				*) print::error "Invalid wallet type!"
			esac
		done
		printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}" \
			"Create wallet type: " \
			"[${WALLET_TYPE}]" \
			"? (Y/n) "
		if ask::yes; then
			break
		fi
	done
	fi
	if [[ -z $WALLET_NAME ]]; then
	while :; do
		if [[ $WALLET_TYPE = json ]]; then
			printf "${BWHITE}%s${OFF}" "JSON file path: "
			read -r WALLET_NAME
			case "$WALLET_NAME" in
				"")    print::error "Empty input";;
				*)     break;;
			esac
		else
			printf "${BWHITE}%s${OFF}" "Wallet name: "
			read -r WALLET_NAME
			case "$WALLET_NAME" in
				"")    print::error "Empty input";;
				*" "*) print::error "Wallet name cannot have spaces";;
				*)     break;;
			esac
		fi
	done
	fi
	log::debug "creating wallet [$WALLET_NAME] with type [$WALLET_TYPE] inside $WALLETS"
	log::debug "cd'ing to $EXPORT_IMPORT for wallet files"
	cd "$EXPORT_IMPORT"
	safety::pkg monero
	printf "\n"
	if case "$WALLET_TYPE" in
	new)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-new-wallet "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_WALLET"
			;;
	view)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-view-key "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_WALLET"
			;;
	seed)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-new-wallet "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_WALLET" \
			--restore-from-seed
			;;
	json)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-json "$WALLET_NAME" \
			--config-file "$CONFIG_WALLET"
			;;
	spend)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-spend-key "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_WALLET"
			;;
	device)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-device "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_WALLET"
			;;
	private)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-keys "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_WALLET"
			;;
	multisig)
			"$PKG_MONERO/monero-wallet-cli" \
			--generate-from-multisig-keys "$WALLETS/$WALLET_NAME" \
			--config-file "$CONFIG_WALLET"
			;;
	esac; then
		log::debug "monero-wallet-cli exit successfully"
		exit 0
	else
		print::error "monero-wallet-cli error has occurred"
		exit 1
	fi
}
wallet::list() {
	log::debug "starting"
	char WALLET_LIST_ALL
	local WALLET_COUNT WALLET_LIST i
	WALLET_LIST_ALL=("$(ls "$WALLETS" | grep -v ".keys" | sort)")
	WALLET_COUNT="$(echo "${WALLET_LIST_ALL[@]}" | wc -w)"
	for i in ${WALLET_LIST_ALL[@]}; do
		WALLET_LIST="[${i}]  $WALLET_LIST"
	done
	printf "${BWHITE}%s${OFF}" "$WALLET_COUNT "
	if [[ $WALLET_COUNT = 1 ]]; then
		printf "%s\n" "wallet found"
	else
		printf "%s\n" "wallets found"
	fi
	echo
	[[ $WALLET_COUNT != 0 ]] && printf "${BWHITE}%s${OFF}\n\n" "$WALLET_LIST"
	return 0
}
wallet::open() {
	log::debug "starting"
	if [[ -e "$WALLETS/$1" ]]; then
		printf "${BWHITE}%s${BYELLOW}%s${OFF}\n" "Opening wallet: " "[$1]"
	else
		print::exit "Wallet [$1] not found!"
	fi
	if [[ $2 = "-v" || $2 = "--verbose" ]]; then
		wallet::password "$3"
	else
		wallet::password
	fi
	printf "\n\n"
	wallet::start
}
wallet::password() {
	log::debug "starting"
	trap 'crypto::key::remove' EXIT
	crypto::key::create
	if [[ $1 ]]; then
		WALLET_PASSWORD="$1"
	else
		printf "${BWHITE}%s${OFF}" "Password: "
		read -s -r WALLET_PASSWORD
	fi
	WALLET_PASSWORD="$(crypto::encrypt "$WALLET_PASSWORD" "$(cat $CRYPTO_KEY)")"
}
wallet::select() {
	log::debug "starting"
	___BEGIN___ERROR___TRACE___
	char WALLET_SELECTION
	local i
	while :; do
	printf "${BYELLOW}%s${OFF}%s${BPURPLE}%s${OFF}%s" \
		"Select a wallet " \
		"or " \
		"[new]" \
		": "
	read -r WALLET_SELECTION
	for i in ${WALLET_LIST_ALL[@]}; do
		[[ $WALLET_SELECTION = "$i" ]] && break
	done
	case "$WALLET_SELECTION" in
		"$i") break;;
		new|New|NEW) break;;
		"")   print::error "Empty input";;
		*)    print::error "Wallet not found";;
	esac
	done
	if [[ $i = new || $i = New || $i = NEW ]]; then
		while :; do
			printf "${BWHITE}%s\n${BYELLOW}%s${OFF}%s${BRED}%s${OFF}" \
				"Wallet name is similar to option..." \
				"SELECT " \
				"or " \
				"CREATE? "
			local SELECT_CREATE
			read -r SELECT_CREATE
			case $SELECT_CREATE in
			select|Select|SELECT)
				printf "${BWHITE}%s${BRED}%s${OFF}\n" \
				"Selecting " \
				"[$WALLET_SELECTION]"
				wallet::password
				printf "\n\n"
				wallet::start
				exit
				;;
			create|Create|CREATE)
				printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
				"Creating a " \
				"[new] " \
				"wallet"
				wallet::create
				exit
				;;
			*) print::error "Invalid option!" ;;
			esac
		done
	fi
	case "$WALLET_SELECTION" in
		new|New|NEW)
			printf "${BWHITE}%s${BRED}%s${BWHITE}%s${OFF}\n" \
			"Creating a " \
			"[new] " \
			"wallet"
			wallet::create
			exit
			;;
	esac
	wallet::password
	printf "\n\n"
	wallet::start
	___ENDOF___ERROR___TRACE___
	exit 0
}
wallet::start() {
	log::debug "starting wallet: $WALLETS/$WALLET_SELECTION"
	safety::pkg monero
	log::debug "cd'ing to $EXPORT_IMPORT for wallet files"
	cd "$EXPORT_IMPORT"
	if [[ $AUTO_START_MONEROD = true ]]; then
		struct::pkg monero
		process::start
	fi
	___ENDOF___ERROR___TRACE___
	if "$PKG_MONERO/monero-wallet-cli" \
		--wallet-file "$WALLETS/$WALLET_SELECTION" \
		--config-file "$CONFIG_WALLET" \
		--password "$(crypto::decrypt "$WALLET_PASSWORD" "$(cat $CRYPTO_KEY)")"; then
		log::debug "monero-wallet-cli exit successfully"
	else
		local WALLET_ERROR=true
		print::error "monero-wallet-cli error has occurred"
	fi
	___BEGIN___ERROR___TRACE___
	if [[ $AUTO_STOP_MONEROD = true ]]; then
		struct::pkg monero
		process::stop
	fi
	[[ $WALLET_ERROR = true ]] && exit 1 || exit 0
}
declare -frg crypto::key::create
declare -frg crypto::key::remove
declare -frg DEBUG
declare -frg monero_bash::install:trap::user
declare -frg monero_bash::install::trap::clean
declare -frg monero_bash::install
declare -frg monero_bash::uninstall
declare -frg parse::config
declare -frg parse::options::process
declare -frg parse::options::systemd
declare -frg parse::options
declare -frg parse::p2pool
declare -frg parse::state
declare -frg pkg::download
declare -frg pkg::download::sig
declare -frg pkg::download::hash
declare -frg pkg::download::pkg
declare -frg pkg::download::find_tar
declare -frg pkg::extract
declare -frg pkg::extract::multi
declare -frg pkg::hook::pre
declare -frg pkg::hook::post
declare -frg pkg::hook::post::state
declare -frg pkg::hook::post::changes
declare -frg pkg::hook::post::config
declare -frg pkg::hook::post::systemd
declare -frg pkg::hook::post::bash
declare -frg pkg::info
declare -frg pkg::info::down
declare -frg pkg::info::hash
declare -frg pkg::info::sig
declare -frg pkg::info::changes
declare -frg pkg::prompt
declare -frg pkg::prompt::check::install
declare -frg pkg::prompt::check::old
declare -frg pkg::remove::prompt
declare -frg pkg::remove
declare -frg pkg::tmp::download
declare -frg pkg::tmp::info
declare -frg pkg::tmp::remove
declare -frg pkg::trap::pkg_folders
declare -frg pkg::trap::state::old
declare -frg pkg::trap::remove
declare -frg pkg::update
declare -frg pkg::update::multi
declare -frg pkg::update::ver
declare -frg pkg::update::result
declare -frg pkg::upgrade
declare -frg pkg::verify
declare -frg pkg::verify::hash_calc
declare -frg pkg::verify::check_key
declare -frg pkg::verify::hash
declare -frg pkg::verify::pgp
declare -frg print::changes::list
declare -frg print::changes
declare -frg print::compromised::hash
declare -frg print::compromised::pgp
declare -frg print::eol
declare -frg print::error
declare -frg print::exit
declare -frg print::help
declare -frg print::help::command
declare -frg print::pkg::download
declare -frg print::pkg::update
declare -frg print::pkg::remove
declare -frg print::pkg::verify
declare -frg print::pkg::install
declare -frg print::pkg::upgrade
declare -frg print::pkg::hook::pre
declare -frg print::pkg::hook::post
declare -frg print::pkg::installed
declare -frg print::pkg::upgraded
declare -frg print::pkg::upgrade_fail
declare -frg print::pkg::removed
declare -frg print::pkg::updated
declare -frg print::size
declare -frg print::title
declare -frg print::version
declare -frg process::reset_files
declare -frg rpc
declare -frg rpc::quote
declare -frg rpc::parse_arr
declare -frg rpc::parse_nv
declare -frg safety::path
declare -frg safety::pipe
declare -frg safety::pkg
declare -frg safety::root
declare -frg safety::wget_curl
declare -frg status::p2pool
declare -frg status::table
declare -frg struct::pkg
declare -frg systemd::create
declare -frg systemd::reload
declare -frg wallet::create
declare -frg wallet::list
declare -frg wallet::open
declare -frg wallet::password
declare -frg wallet::select
declare -frg wallet::start
trap - ERR || exit 117
set +eo pipefail || exit 118

#-------------------------------------------------------------------------------- BEGIN MAIN
main() {
log::debug "main() started"
if [[ $1 = DEBUG ]]; then
	log::debug "starting DEBUG mode"
	safety::wget_curl
	parse::state
	parse::config
	DEBUG "$@"
fi
log::debug "starting safety checks"
if set -m; then
	log::debug "set -m | job control | OK"
else
	print::error "Job control could not be enabled | set -m | FAIL"
	print::exit  "Exiting for safety..."
fi
if safety::gnu_linux; then
	log::debug "safety::gnu_linux | $OSTYPE | OK"
else
	log::debug "safety::gnu_linux | $OSTYPE | FAIL"
	print::error "Non GNU/Linux OS detected!"
	print::error "[monero-bash] only works on GNU/Linux"
	print::exit  "Exiting for safety..."
fi
if safety::bash; then
	log::debug "safety::bash | ${BASH_VERSINFO[0]} | OK"
else
	log::debug "safety::bash | ${BASH_VERSINFO[0]} | FAIL"
	print::error "Bash version is not v5+"
	print::error "[monero-bash] only works with Bash v5+"
	print::exit  "Exiting for safety..."
fi
safety::root
safety::pipe
safety::wget_curl
___BEGIN___ERROR___TRACE___
parse::state
parse::config
___ENDOF___ERROR___TRACE___
safety::path
if [[ $FIRST_TIME = true ]]; then
	___BEGIN___ERROR___TRACE___
	log::debug "FIRST_TIME = true | starting installation"
	monero_bash::install
	___ENDOF___ERROR___TRACE___
else
	log::debug "FIRST_TIME = false | skipping installation"
fi
[[ $# != 0 ]] && parse::options "$@"
print::title
[[ $AUTO_UPDATE = true ]] && update && echo
wallet::list
wallet::select
exit 0
}
main "$@"
#-------------------------------------------------------------------------------- ENDOF MAIN
